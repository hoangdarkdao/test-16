[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6587839776378479,
            0.7878844141960144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6587839776378479,
            0.7878844141960144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6587839776378479,
            0.7878844141960144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9434579015333912,
            0.23075997829437256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9434579015333912,
            0.23075997829437256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9434579015333912,
            0.23075997829437256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This heuristic function selects a solution from the archive with the highest potential for improvement by combining crowding distance and objective diversity, then applies a hybrid local search operator that combines edge insertion with a novel segment relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 + np.random.rand()) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment of length between 2 and min(6, n//2)\n    seg_length = np.random.randint(2, min(6, n//2) + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = base_solution[start:start+seg_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    remaining = np.concatenate([base_solution[:start], base_solution[start+seg_length:]])\n    insert_pos = np.random.randint(0, len(remaining) - seg_length + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Apply edge insertion for diversification\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8733647118179252,
            0.23261624574661255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([(obj[0] + obj[1]) * (1 + np.random.rand()) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment of length between 2 and min(6, n//2)\n    seg_length = np.random.randint(2, min(6, n//2) + 1)\n    start = np.random.randint(0, n - seg_length)\n    segment = base_solution[start:start+seg_length]\n\n    # Step 2: Remove the segment and insert it in a new position\n    remaining = np.concatenate([base_solution[:start], base_solution[start+seg_length:]])\n    insert_pos = np.random.randint(0, len(remaining) - seg_length + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Apply edge insertion for diversification\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search that combines edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective score (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(combined_scores)  # Select the solution with the best combined score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Option 1: Reverse the segment (similar to 2-opt but more flexible)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    # Option 2: Insert segment elsewhere (edge insertion)\n    else:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, repair by filling missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.7620799816939337,
            0.23520970344543457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective score (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(combined_scores)  # Select the solution with the best combined score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Option 1: Reverse the segment (similar to 2-opt but more flexible)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    # Option 2: Insert segment elsewhere (edge insertion)\n    else:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, repair by filling missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9019487432652015,
            0.12188470363616943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9019487432652015,
            0.12188470363616943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the Pareto front, then applies a novel local search strategy combining adaptive segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Sort objectives by each dimension\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distance\n    crowding_distance = [0.0] * n\n\n    # Calculate crowding distance for each objective\n    for dim in [0, 1]:\n        sorted_indices = sorted_obj1 if dim == 0 else sorted_obj2\n        crowding_distance[sorted_indices[0]] = float('inf')\n        crowding_distance[sorted_indices[-1]] = float('inf')\n        if n > 2:\n            min_obj = objectives[sorted_indices[0]][dim]\n            max_obj = objectives[sorted_indices[-1]][dim]\n            for i in range(1, n-1):\n                prev = objectives[sorted_indices[i-1]][dim]\n                next = objectives[sorted_indices[i+1]][dim]\n                if max_obj - min_obj > 0:\n                    crowding_distance[sorted_indices[i]] += (next - prev) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    max_crowding = max(crowding_distance)\n    candidates = [i for i in range(n) if crowding_distance[i] == max_crowding]\n    base_solution = solutions[random.choice(candidates)].copy()\n\n    # Adaptive segment reversal and edge swapping\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Edge swapping\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8431834405373214,
            0.21518230438232422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Sort objectives by each dimension\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distance\n    crowding_distance = [0.0] * n\n\n    # Calculate crowding distance for each objective\n    for dim in [0, 1]:\n        sorted_indices = sorted_obj1 if dim == 0 else sorted_obj2\n        crowding_distance[sorted_indices[0]] = float('inf')\n        crowding_distance[sorted_indices[-1]] = float('inf')\n        if n > 2:\n            min_obj = objectives[sorted_indices[0]][dim]\n            max_obj = objectives[sorted_indices[-1]][dim]\n            for i in range(1, n-1):\n                prev = objectives[sorted_indices[i-1]][dim]\n                next = objectives[sorted_indices[i+1]][dim]\n                if max_obj - min_obj > 0:\n                    crowding_distance[sorted_indices[i]] += (next - prev) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    max_crowding = max(crowding_distance)\n    candidates = [i for i in range(n) if crowding_distance[i] == max_crowding]\n    base_solution = solutions[random.choice(candidates)].copy()\n\n    # Adaptive segment reversal and edge swapping\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Edge swapping\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive based on crowding distance in the objective space, then applies a novel local search combining segment rotation and path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Select solution with maximum crowding distance\n    if len(non_dominated) > 1:\n        objectives = [obj for _, obj in archive]\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n        crowding = {}\n        for sol, obj in archive:\n            idx1 = sorted_obj1.index(obj)\n            idx2 = sorted_obj2.index(obj)\n\n            if idx1 == 0 or idx1 == len(sorted_obj1) - 1:\n                crowding_dist1 = float('inf')\n            else:\n                crowding_dist1 = sorted_obj1[idx1 + 1][0] - sorted_obj1[idx1 - 1][0]\n\n            if idx2 == 0 or idx2 == len(sorted_obj2) - 1:\n                crowding_dist2 = float('inf')\n            else:\n                crowding_dist2 = sorted_obj2[idx2 + 1][1] - sorted_obj2[idx2 - 1][1]\n\n            crowding[sol.tobytes()] = crowding_dist1 + crowding_dist2\n\n        base_solution = max(non_dominated, key=lambda x: crowding[x.tobytes()])\n    else:\n        base_solution = non_dominated[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        rotated = np.roll(segment, -1)\n        new_solution[a:b] = rotated\n\n        # Path inversion with probability\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.818450117839925,
            0.6151801943778992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Select solution with maximum crowding distance\n    if len(non_dominated) > 1:\n        objectives = [obj for _, obj in archive]\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n        crowding = {}\n        for sol, obj in archive:\n            idx1 = sorted_obj1.index(obj)\n            idx2 = sorted_obj2.index(obj)\n\n            if idx1 == 0 or idx1 == len(sorted_obj1) - 1:\n                crowding_dist1 = float('inf')\n            else:\n                crowding_dist1 = sorted_obj1[idx1 + 1][0] - sorted_obj1[idx1 - 1][0]\n\n            if idx2 == 0 or idx2 == len(sorted_obj2) - 1:\n                crowding_dist2 = float('inf')\n            else:\n                crowding_dist2 = sorted_obj2[idx2 + 1][1] - sorted_obj2[idx2 - 1][1]\n\n            crowding[sol.tobytes()] = crowding_dist1 + crowding_dist2\n\n        base_solution = max(non_dominated, key=lambda x: crowding[x.tobytes()])\n    else:\n        base_solution = non_dominated[0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        rotated = np.roll(segment, -1)\n        new_solution[a:b] = rotated\n\n        # Path inversion with probability\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Randomly select two segments and swap them\n    seg1_start, seg1_end = sorted(np.random.choice(range(n), 2, replace=False))\n    seg2_start, seg2_end = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Ensure segments are of reasonable size\n    seg1_len = seg1_end - seg1_start + 1\n    seg2_len = seg2_end - seg2_start + 1\n    if seg1_len > n // 2 or seg2_len > n // 2:\n        return new_solution\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Swap segments\n    if seg1_len == seg2_len:\n        new_solution[seg1_start:seg1_end+1] = seg2\n        new_solution[seg2_start:seg2_end+1] = seg1\n    else:\n        # For unequal lengths, perform a more complex swap\n        temp = np.concatenate((seg1, seg2))\n        np.random.shuffle(temp)\n        new_solution[seg1_start:seg1_end+1] = temp[:seg1_len]\n        new_solution[seg2_start:seg2_end+1] = temp[seg1_len:]\n\n    # Apply a guided local search to improve the solution\n    for i in range(n):\n        for j in range(i+2, n):\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.15 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.15 * abs(delta2)):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7523764164105002,
            0.8490074872970581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Randomly select two segments and swap them\n    seg1_start, seg1_end = sorted(np.random.choice(range(n), 2, replace=False))\n    seg2_start, seg2_end = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Ensure segments are of reasonable size\n    seg1_len = seg1_end - seg1_start + 1\n    seg2_len = seg2_end - seg2_start + 1\n    if seg1_len > n // 2 or seg2_len > n // 2:\n        return new_solution\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n\n    # Swap segments\n    if seg1_len == seg2_len:\n        new_solution[seg1_start:seg1_end+1] = seg2\n        new_solution[seg2_start:seg2_end+1] = seg1\n    else:\n        # For unequal lengths, perform a more complex swap\n        temp = np.concatenate((seg1, seg2))\n        np.random.shuffle(temp)\n        new_solution[seg1_start:seg1_end+1] = temp[:seg1_len]\n        new_solution[seg2_start:seg2_end+1] = temp[seg1_len:]\n\n    # Apply a guided local search to improve the solution\n    for i in range(n):\n        for j in range(i+2, n):\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.15 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.15 * abs(delta2)):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This novel algorithm combines a Pareto-dominant selection mechanism with a multi-phase local search that first performs a guided segment rotation followed by a constrained edge insertion, prioritizing solutions with balanced objective costs to enhance convergence while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmin(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Phase 1: Guided segment rotation\n    k = np.random.randint(2, min(5, n//2))\n    rotation_point = np.random.randint(0, n - k)\n    segment = new_solution[rotation_point:rotation_point+k]\n    rotated_segment = np.roll(segment, np.random.randint(1, k))\n    new_solution[rotation_point:rotation_point+k] = rotated_segment\n\n    # Phase 2: Constrained edge insertion\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7823848131907103,
            0.26564282178878784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmin(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Phase 1: Guided segment rotation\n    k = np.random.randint(2, min(5, n//2))\n    rotation_point = np.random.randint(0, n - k)\n    segment = new_solution[rotation_point:rotation_point+k]\n    rotated_segment = np.roll(segment, np.random.randint(1, k))\n    new_solution[rotation_point:rotation_point+k] = rotated_segment\n\n    # Phase 2: Constrained edge insertion\n    for _ in range(2):\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        if j - i > 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search that combines a novel path fragmentation and reassembly strategy with a guided node reinsertion mechanism to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        variance = abs(obj[0] - obj[1])\n        quality = - (obj[0] + obj[1])  # Higher score for better quality\n        scores.append(variance + quality)\n\n    if len(scores) > 0:\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: path fragmentation and reassembly + guided node reinsertion\n    # Step 1: Fragment the path into 3 segments and reassemble in a different order\n    points = sorted(random.sample(range(1, n), 2))\n    a, b = points[0], points[1]\n    segments = [new_solution[:a], new_solution[a:b], new_solution[b:]]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Step 2: Guided node reinsertion based on distance improvement\n    for i in range(1, n-1):\n        node = new_solution[i]\n        # Remove node from current position\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Find best insertion point that improves both objectives\n        best_pos = i\n        best_delta = (0, 0)\n        for j in range(1, n-1):\n            if j == i:\n                continue\n            prev = new_solution[j-1]\n            curr = new_solution[j]\n            delta1 = (distance_matrix_1[prev, node] + distance_matrix_1[node, curr] -\n                     distance_matrix_1[prev, curr])\n            delta2 = (distance_matrix_2[prev, node] + distance_matrix_2[node, curr] -\n                     distance_matrix_2[prev, curr])\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.2 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.2 * abs(delta2)):\n                if abs(delta1) + abs(delta2) > abs(best_delta[0]) + abs(best_delta[1]):\n                    best_pos = j\n                    best_delta = (delta1, delta2)\n        # Insert node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6850453687472421,
            1.1826446652412415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        variance = abs(obj[0] - obj[1])\n        quality = - (obj[0] + obj[1])  # Higher score for better quality\n        scores.append(variance + quality)\n\n    if len(scores) > 0:\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: path fragmentation and reassembly + guided node reinsertion\n    # Step 1: Fragment the path into 3 segments and reassemble in a different order\n    points = sorted(random.sample(range(1, n), 2))\n    a, b = points[0], points[1]\n    segments = [new_solution[:a], new_solution[a:b], new_solution[b:]]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Step 2: Guided node reinsertion based on distance improvement\n    for i in range(1, n-1):\n        node = new_solution[i]\n        # Remove node from current position\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        # Find best insertion point that improves both objectives\n        best_pos = i\n        best_delta = (0, 0)\n        for j in range(1, n-1):\n            if j == i:\n                continue\n            prev = new_solution[j-1]\n            curr = new_solution[j]\n            delta1 = (distance_matrix_1[prev, node] + distance_matrix_1[node, curr] -\n                     distance_matrix_1[prev, curr])\n            delta2 = (distance_matrix_2[prev, node] + distance_matrix_2[node, curr] -\n                     distance_matrix_2[prev, curr])\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.2 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.2 * abs(delta2)):\n                if abs(delta1) + abs(delta2) > abs(best_delta[0]) + abs(best_delta[1]):\n                    best_pos = j\n                    best_delta = (delta1, delta2)\n        # Insert node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9346614731157932,
            0.19465023279190063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator combines a probabilistic node clustering with a multi-objective edge reversal strategy, prioritizing solutions with balanced objective costs to maintain diversity while ensuring feasibility through constrained segment swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    balanced_scores = [min(obj) / (max(obj) + 1e-6) for _, obj in archive]\n    if len(balanced_scores) > 0:\n        selected_idx = np.argmax(balanced_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Probabilistic node clustering\n    cluster_size = max(2, min(5, n // 4))\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        if len(cluster) > 1:\n            new_solution[i:i+cluster_size] = cluster[::-1]\n\n    # Multi-objective edge reversal\n    for i in range(n):\n        for j in range(i+2, min(i+6, n)):\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.2 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.2 * abs(delta2)):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5537806046493574,
            4.106411695480347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    balanced_scores = [min(obj) / (max(obj) + 1e-6) for _, obj in archive]\n    if len(balanced_scores) > 0:\n        selected_idx = np.argmax(balanced_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Probabilistic node clustering\n    cluster_size = max(2, min(5, n // 4))\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        if len(cluster) > 1:\n            new_solution[i:i+cluster_size] = cluster[::-1]\n\n    # Multi-objective edge reversal\n    for i in range(n):\n        for j in range(i+2, min(i+6, n)):\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.2 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.2 * abs(delta2)):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the Pareto front, then applies a novel local search strategy combining adaptive segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Sort objectives by each dimension\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distance\n    crowding_distance = [0.0] * n\n\n    # Calculate crowding distance for each objective\n    for dim in [0, 1]:\n        sorted_indices = sorted_obj1 if dim == 0 else sorted_obj2\n        crowding_distance[sorted_indices[0]] = float('inf')\n        crowding_distance[sorted_indices[-1]] = float('inf')\n        if n > 2:\n            min_obj = objectives[sorted_indices[0]][dim]\n            max_obj = objectives[sorted_indices[-1]][dim]\n            for i in range(1, n-1):\n                prev = objectives[sorted_indices[i-1]][dim]\n                next = objectives[sorted_indices[i+1]][dim]\n                if max_obj - min_obj > 0:\n                    crowding_distance[sorted_indices[i]] += (next - prev) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    max_crowding = max(crowding_distance)\n    candidates = [i for i in range(n) if crowding_distance[i] == max_crowding]\n    base_solution = solutions[random.choice(candidates)].copy()\n\n    # Adaptive segment reversal and edge swapping\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Edge swapping\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The algorithm combines quality-aware selection based on objective space coverage with a novel local search strategy that adaptively combines segment rotation and node insertion, ensuring feasibility through careful validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Quality-aware selection: prioritize solutions with balanced objective values\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    # Calculate normalized objective values\n    norm_obj1 = [obj[0] for obj in objectives]\n    norm_obj2 = [obj[1] for obj in objectives]\n    if max(norm_obj1) > 0:\n        norm_obj1 = [x / max(norm_obj1) for x in norm_obj1]\n    if max(norm_obj2) > 0:\n        norm_obj2 = [x / max(norm_obj2) for x in norm_obj2]\n\n    # Select solution with balanced objectives (minimize the sum of normalized objectives)\n    balanced_indices = sorted(range(n), key=lambda i: norm_obj1[i] + norm_obj2[i])\n    base_solution = solutions[balanced_indices[0]].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment rotation\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        rotation = random.randint(1, segment_length - 1)\n        new_solution[start:end] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Node insertion\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7179159245834057,
            0.2418752908706665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Quality-aware selection: prioritize solutions with balanced objective values\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    # Calculate normalized objective values\n    norm_obj1 = [obj[0] for obj in objectives]\n    norm_obj2 = [obj[1] for obj in objectives]\n    if max(norm_obj1) > 0:\n        norm_obj1 = [x / max(norm_obj1) for x in norm_obj1]\n    if max(norm_obj2) > 0:\n        norm_obj2 = [x / max(norm_obj2) for x in norm_obj2]\n\n    # Select solution with balanced objectives (minimize the sum of normalized objectives)\n    balanced_indices = sorted(range(n), key=lambda i: norm_obj1[i] + norm_obj2[i])\n    base_solution = solutions[balanced_indices[0]].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment rotation\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        rotation = random.randint(1, segment_length - 1)\n        new_solution[start:end] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Node insertion\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        new_solution = np.insert(new_solution, i, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining segment reversal and edge reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest crowding distance\n    if len(non_dominated) > 1:\n        objectives = np.array([obj for _, obj in non_dominated])\n        crowding = np.zeros(len(non_dominated))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge reinsertion\n    if n > 3:\n        # Step 1: Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Edge reinsertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8311481514389127,
            0.3776355981826782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select solution with highest crowding distance\n    if len(non_dominated) > 1:\n        objectives = np.array([obj for _, obj in non_dominated])\n        crowding = np.zeros(len(non_dominated))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge reinsertion\n    if n > 3:\n        # Step 1: Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Edge reinsertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search operator combines a randomized block relocation with a Pareto-guided edge insertion strategy, prioritizing solutions with high crowding distance in the objective space to enhance diversity while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: randomized block relocation + Pareto-guided edge insertion\n    # Random block relocation\n    block_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - block_size)\n    block = new_solution[start:start+block_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+block_size:], block])\n\n    # Pareto-guided edge insertion\n    for i in range(n):\n        for j in range(n):\n            if i == j or j == (i+1)%n:\n                continue\n\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if Pareto improvement\n            if (delta1 <= 0 and delta2 <= 0) and (delta1 < 0 or delta2 < 0):\n                # Perform edge insertion\n                if i < j:\n                    new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:], new_solution[i+1:j+1], [new_solution[j]]])\n                else:\n                    new_solution = np.concatenate([new_solution[:j+1], new_solution[i+1:], new_solution[j+1:i+1], [new_solution[i]]])\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8739242382097259,
            1.1163862943649292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: randomized block relocation + Pareto-guided edge insertion\n    # Random block relocation\n    block_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - block_size)\n    block = new_solution[start:start+block_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+block_size:], block])\n\n    # Pareto-guided edge insertion\n    for i in range(n):\n        for j in range(n):\n            if i == j or j == (i+1)%n:\n                continue\n\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[(i+1)%n], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if Pareto improvement\n            if (delta1 <= 0 and delta2 <= 0) and (delta1 < 0 or delta2 < 0):\n                # Perform edge insertion\n                if i < j:\n                    new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:], new_solution[i+1:j+1], [new_solution[j]]])\n                else:\n                    new_solution = np.concatenate([new_solution[:j+1], new_solution[i+1:], new_solution[j+1:i+1], [new_solution[i]]])\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive with the highest crowding distance to promote diversity, then applies a hybrid local search combining 3-opt and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Calculate crowding distance for non-dominated solutions\n        sorted_solutions = sorted(non_dominated, key=lambda x: (x[1][0], x[1][1]))\n        crowding_distances = [0.0] * len(sorted_solutions)\n\n        for m in range(2):  # For both objectives\n            sorted_solutions.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_solutions)-1):\n                crowding_distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m])\n\n        # Select solution with highest crowding distance\n        max_cd = max(crowding_distances)\n        candidates = [sol for i, (sol, _) in enumerate(sorted_solutions) if crowding_distances[i] == max_cd]\n        base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt and segment reversal\n    if n > 4:\n        # 3-opt: select 3 edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Segment reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8107005733052586,
            0.22998100519180298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Calculate crowding distance for non-dominated solutions\n        sorted_solutions = sorted(non_dominated, key=lambda x: (x[1][0], x[1][1]))\n        crowding_distances = [0.0] * len(sorted_solutions)\n\n        for m in range(2):  # For both objectives\n            sorted_solutions.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_solutions)-1):\n                crowding_distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m])\n\n        # Select solution with highest crowding distance\n        max_cd = max(crowding_distances)\n        candidates = [sol for i, (sol, _) in enumerate(sorted_solutions) if crowding_distances[i] == max_cd]\n        base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt and segment reversal\n    if n > 4:\n        # 3-opt: select 3 edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Segment reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the Pareto front, then applies a novel local search strategy combining adaptive segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Sort objectives by each dimension\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distance\n    crowding_distance = [0.0] * n\n\n    # Calculate crowding distance for each objective\n    for dim in [0, 1]:\n        sorted_indices = sorted_obj1 if dim == 0 else sorted_obj2\n        crowding_distance[sorted_indices[0]] = float('inf')\n        crowding_distance[sorted_indices[-1]] = float('inf')\n        if n > 2:\n            min_obj = objectives[sorted_indices[0]][dim]\n            max_obj = objectives[sorted_indices[-1]][dim]\n            for i in range(1, n-1):\n                prev = objectives[sorted_indices[i-1]][dim]\n                next = objectives[sorted_indices[i+1]][dim]\n                if max_obj - min_obj > 0:\n                    crowding_distance[sorted_indices[i]] += (next - prev) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    max_crowding = max(crowding_distance)\n    candidates = [i for i in range(n) if crowding_distance[i] == max_crowding]\n    base_solution = solutions[random.choice(candidates)].copy()\n\n    # Adaptive segment reversal and edge swapping\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Edge swapping\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest hypervolume contribution, then applies a novel local search strategy combining adaptive node clustering and path reconfiguration to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) + 1.0  # Reference point slightly worse than worst solutions\n    volumes = np.zeros(len(archive))\n\n    # Sort solutions by first objective\n    sorted_idx = np.argsort(objectives[:, 0])\n    for i in range(len(archive)):\n        current_obj = objectives[sorted_idx[i]]\n        if i == 0:\n            prev_obj = np.array([0.0, 0.0])\n        else:\n            prev_obj = objectives[sorted_idx[i-1]]\n\n        # Calculate hypervolume contribution\n        width = current_obj[0] - prev_obj[0]\n        height = ref_point[1] - max(current_obj[1], prev_obj[1])\n        volumes[sorted_idx[i]] = width * height\n\n    # Select solution with highest hypervolume contribution\n    max_volume = np.max(volumes)\n    candidates = [i for i in range(len(archive)) if volumes[i] == max_volume]\n    base_solution = archive[random.choice(candidates)][0].copy()\n\n    # Adaptive node clustering and path reconfiguration\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Step 1: Adaptive node clustering\n        cluster_size = random.randint(2, min(4, n_nodes // 3))\n        clusters = []\n        current_pos = 0\n        while current_pos < n_nodes:\n            end_pos = min(current_pos + cluster_size, n_nodes)\n            clusters.append(new_solution[current_pos:end_pos])\n            current_pos = end_pos\n\n        # Step 2: Path reconfiguration\n        if len(clusters) > 1:\n            # Randomly select two clusters and swap their positions\n            i, j = sorted(random.sample(range(len(clusters)), 2))\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n\n        # Reconstruct the solution from clusters\n        new_solution = np.concatenate(clusters)\n\n        # Step 3: Local reordering within a cluster\n        if len(clusters) > 0:\n            cluster_idx = random.randint(0, len(clusters)-1)\n            cluster = clusters[cluster_idx]\n            if len(cluster) > 2:\n                start = random.randint(0, len(cluster)-2)\n                end = random.randint(start+1, len(cluster))\n                cluster[start:end] = cluster[start:end][::-1]\n                clusters[cluster_idx] = cluster\n                new_solution = np.concatenate(clusters)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6737654219716371,
            0.30107229948043823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) + 1.0  # Reference point slightly worse than worst solutions\n    volumes = np.zeros(len(archive))\n\n    # Sort solutions by first objective\n    sorted_idx = np.argsort(objectives[:, 0])\n    for i in range(len(archive)):\n        current_obj = objectives[sorted_idx[i]]\n        if i == 0:\n            prev_obj = np.array([0.0, 0.0])\n        else:\n            prev_obj = objectives[sorted_idx[i-1]]\n\n        # Calculate hypervolume contribution\n        width = current_obj[0] - prev_obj[0]\n        height = ref_point[1] - max(current_obj[1], prev_obj[1])\n        volumes[sorted_idx[i]] = width * height\n\n    # Select solution with highest hypervolume contribution\n    max_volume = np.max(volumes)\n    candidates = [i for i in range(len(archive)) if volumes[i] == max_volume]\n    base_solution = archive[random.choice(candidates)][0].copy()\n\n    # Adaptive node clustering and path reconfiguration\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Step 1: Adaptive node clustering\n        cluster_size = random.randint(2, min(4, n_nodes // 3))\n        clusters = []\n        current_pos = 0\n        while current_pos < n_nodes:\n            end_pos = min(current_pos + cluster_size, n_nodes)\n            clusters.append(new_solution[current_pos:end_pos])\n            current_pos = end_pos\n\n        # Step 2: Path reconfiguration\n        if len(clusters) > 1:\n            # Randomly select two clusters and swap their positions\n            i, j = sorted(random.sample(range(len(clusters)), 2))\n            clusters[i], clusters[j] = clusters[j], clusters[i]\n\n        # Reconstruct the solution from clusters\n        new_solution = np.concatenate(clusters)\n\n        # Step 3: Local reordering within a cluster\n        if len(clusters) > 0:\n            cluster_idx = random.randint(0, len(clusters)-1)\n            cluster = clusters[cluster_idx]\n            if len(cluster) > 2:\n                start = random.randint(0, len(cluster)-2)\n                end = random.randint(start+1, len(cluster))\n                cluster[start:end] = cluster[start:end][::-1]\n                clusters[cluster_idx] = cluster\n                new_solution = np.concatenate(clusters)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment inversion, node relocation, and objective-aware edge selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: combine segment inversion, node relocation, and objective-aware edge selection\n    if n > 3:\n        # Step 1: Segment inversion with objective-aware selection\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b].copy()\n\n        # Calculate improvement potential for the segment\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        cost_after = (distance_matrix_1[new_solution[a-1], segment[-1]] +\n                      distance_matrix_1[segment[0], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], segment[-1]] +\n                      distance_matrix_2[segment[0], new_solution[b]])\n\n        if cost_after < cost_before:\n            new_solution[a:b] = segment[::-1]\n\n        # Step 2: Node relocation based on objective improvement\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(n-1):\n            # Calculate improvement for both objectives\n            improvement = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                          distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Objective-aware edge selection\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        # Only perform swap if it improves both objectives\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) and \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7686772538831921,
            1.1105096936225891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: combine segment inversion, node relocation, and objective-aware edge selection\n    if n > 3:\n        # Step 1: Segment inversion with objective-aware selection\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b].copy()\n\n        # Calculate improvement potential for the segment\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        cost_after = (distance_matrix_1[new_solution[a-1], segment[-1]] +\n                      distance_matrix_1[segment[0], new_solution[b]] +\n                      distance_matrix_2[new_solution[a-1], segment[-1]] +\n                      distance_matrix_2[segment[0], new_solution[b]])\n\n        if cost_after < cost_before:\n            new_solution[a:b] = segment[::-1]\n\n        # Step 2: Node relocation based on objective improvement\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(n-1):\n            # Calculate improvement for both objectives\n            improvement = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                          distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Objective-aware edge selection\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        # Only perform swap if it improves both objectives\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) and \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining segment inversion and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive length\n        segment_length = min(3, n // 2)\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Node swapping based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8706596952963149,
            0.37422508001327515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive length\n        segment_length = min(3, n // 2)\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Node swapping based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment relinking, node reinsertion with distance-based optimization, and a novel adaptive perturbation strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search combining segment relinking, node reinsertion, and adaptive perturbation\n    if n > 3:\n        # Step 1: Segment relinking with distance-based optimization\n        a, b = sorted(random.sample(range(n), 2))\n        segment = base_solution[a:b]\n\n        # Find the best insertion point in the new solution\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n - len(segment) + 1):\n            temp = np.concatenate([new_solution[:pos], segment, new_solution[pos + len(segment):]])\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos + len(segment):]])\n\n        # Step 2: Node reinsertion with adaptive perturbation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find the position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            temp = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Adaptive perturbation based on current solution quality\n        if random.random() < 0.3:  # Higher chance for poor solutions\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9319501253660611,
            0.9100479483604431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search combining segment relinking, node reinsertion, and adaptive perturbation\n    if n > 3:\n        # Step 1: Segment relinking with distance-based optimization\n        a, b = sorted(random.sample(range(n), 2))\n        segment = base_solution[a:b]\n\n        # Find the best insertion point in the new solution\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n - len(segment) + 1):\n            temp = np.concatenate([new_solution[:pos], segment, new_solution[pos + len(segment):]])\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos + len(segment):]])\n\n        # Step 2: Node reinsertion with adaptive perturbation\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n\n        # Find the position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            temp = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Step 3: Adaptive perturbation based on current solution quality\n        if random.random() < 0.3:  # Higher chance for poor solutions\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and node centrality, then applies a hybrid local search combining node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        # Calculate centrality score (average distance to other nodes)\n        centrality = 0\n        for i in range(len(sol)):\n            centrality += np.mean(distance_matrix_1[sol[i], sol])\n            centrality += np.mean(distance_matrix_2[sol[i], sol])\n        weight = 0.4 * (obj[0] + obj[1]) + 0.6 * centrality\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion and segment rotation\n    if n > 4:\n        # Step 1: Node insertion (move a random node to a new position)\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment rotation (rotate a segment by a random amount)\n        a, b = sorted(random.sample(range(n), 2))\n        k = random.randint(1, b-a)\n        segment = new_solution[a:b]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b] = rotated\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8454345751952429,
            4.817922413349152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        # Calculate centrality score (average distance to other nodes)\n        centrality = 0\n        for i in range(len(sol)):\n            centrality += np.mean(distance_matrix_1[sol[i], sol])\n            centrality += np.mean(distance_matrix_2[sol[i], sol])\n        weight = 0.4 * (obj[0] + obj[1]) + 0.6 * centrality\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion and segment rotation\n    if n > 4:\n        # Step 1: Node insertion (move a random node to a new position)\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Segment rotation (rotate a segment by a random amount)\n        a, b = sorted(random.sample(range(n), 2))\n        k = random.randint(1, b-a)\n        segment = new_solution[a:b]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[a:b] = rotated\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective diversity and local improvement potential, then applies a novel segment-based local search that combines partial reversal and segment swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = None\n    best_score = float('inf')\n    for sol, obj in archive:\n        score = max(obj[0], obj[1])  # Simple Pareto front distance approximation\n        if score < best_score:\n            best_score = score\n            best_solution = sol\n\n    base_solution = best_solution.copy() if best_solution is not None else random.choice(archive)[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment-based local search\n        # Step 1: Split into two segments and swap them\n        split_point = random.randint(1, n-2)\n        segment1 = new_solution[:split_point]\n        segment2 = new_solution[split_point:]\n        new_solution = np.concatenate([segment2, segment1])\n\n        # Step 2: Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8431798002623518,
            0.2262769341468811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = None\n    best_score = float('inf')\n    for sol, obj in archive:\n        score = max(obj[0], obj[1])  # Simple Pareto front distance approximation\n        if score < best_score:\n            best_score = score\n            best_solution = sol\n\n    base_solution = best_solution.copy() if best_solution is not None else random.choice(archive)[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment-based local search\n        # Step 1: Split into two segments and swap them\n        split_point = random.randint(1, n-2)\n        segment1 = new_solution[:split_point]\n        segment2 = new_solution[split_point:]\n        new_solution = np.concatenate([segment2, segment1])\n\n        # Step 2: Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Verify feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining segment reversal, node reinsertion, and guided edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate potential insertion positions based on both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swap based on both objectives\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Evaluate before and after swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9558274769611513,
            0.8373363018035889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate potential insertion positions based on both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swap based on both objectives\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Evaluate before and after swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining segment reversal, node reinsertion, and guided edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate potential insertion positions based on both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swap based on both objectives\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Evaluate before and after swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9558274769611513,
            0.8373363018035889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate potential insertion positions based on both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swap based on both objectives\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Evaluate before and after swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search that combines edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective score (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(combined_scores)  # Select the solution with the best combined score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Option 1: Reverse the segment (similar to 2-opt but more flexible)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    # Option 2: Insert segment elsewhere (edge insertion)\n    else:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, repair by filling missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9607322286408637,
            0.1317448616027832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a promising solution from the archive based on a combined objective score, then applies a hybrid local search that combines edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective score (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_scores.mean(axis=1)\n    selected_idx = np.argmin(combined_scores)  # Select the solution with the best combined score\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Option 1: Reverse the segment (similar to 2-opt but more flexible)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    # Option 2: Insert segment elsewhere (edge insertion)\n    else:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        # If duplicates exist, repair by filling missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9607322286408637,
            0.1317448616027832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized dominance score that considers both objectives, then applies a hybrid local search combining node insertion and edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(obj[0] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion and edge reversal\n    if n > 3:\n        # Step 1: Node insertion (move a random node to a new position)\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Edge reversal (reverse a random edge)\n        k = random.randint(0, n-2)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8263190014426308,
            0.24198079109191895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(obj[0] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion and edge reversal\n    if n > 3:\n        # Step 1: Node insertion (move a random node to a new position)\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Edge reversal (reverse a random edge)\n        k = random.randint(0, n-2)\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9699668844998457,
            0.1808682680130005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9699668844998457,
            0.1808682680130005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement in both objectives, then applies a novel hybrid local search combining segment reversal, node shifting, and objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (prioritize those with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment reversal, node shifting, and objective-aware edge swaps\n    if n > 3:\n        # Step 1: Segment reversal with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        if random.random() < 0.5:  # Reverse if it improves both objectives\n            reversed_segment = segment[::-1]\n            original_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n            original_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or random.random() < 0.3:\n                new_solution[i:j] = reversed_segment\n\n        # Step 2: Node shifting with objective-aware selection\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Step 3: Objective-aware edge swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a > 0 and b < n-1:\n            original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n            swapped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n            original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n            swapped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n            if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or random.random() < 0.2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8953357804069126,
            0.2189672589302063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (prioritize those with high potential for improvement)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment reversal, node shifting, and objective-aware edge swaps\n    if n > 3:\n        # Step 1: Segment reversal with objective-aware selection\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        if random.random() < 0.5:  # Reverse if it improves both objectives\n            reversed_segment = segment[::-1]\n            original_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n            original_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[(k+1)%len(reversed_segment)]] for k in range(len(reversed_segment)))\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or random.random() < 0.3:\n                new_solution[i:j] = reversed_segment\n\n        # Step 2: Node shifting with objective-aware selection\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Step 3: Objective-aware edge swaps\n        a, b = sorted(random.sample(range(n), 2))\n        if a > 0 and b < n-1:\n            original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n            swapped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n            original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n            swapped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n            if (swapped_cost1 < original_cost1 and swapped_cost2 < original_cost2) or random.random() < 0.2:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining node insertion and partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Node insertion (remove a random node and insert it elsewhere)\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Partial path reversal (reverse a segment between two nodes)\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8607245174902282,
            0.21043455600738525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Node insertion (remove a random node and insert it elsewhere)\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Step 2: Partial path reversal (reverse a segment between two nodes)\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the Pareto front, then applies a novel local search strategy combining adaptive segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Sort objectives by each dimension\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distance\n    crowding_distance = [0.0] * n\n\n    # Calculate crowding distance for each objective\n    for dim in [0, 1]:\n        sorted_indices = sorted_obj1 if dim == 0 else sorted_obj2\n        crowding_distance[sorted_indices[0]] = float('inf')\n        crowding_distance[sorted_indices[-1]] = float('inf')\n        if n > 2:\n            min_obj = objectives[sorted_indices[0]][dim]\n            max_obj = objectives[sorted_indices[-1]][dim]\n            for i in range(1, n-1):\n                prev = objectives[sorted_indices[i-1]][dim]\n                next = objectives[sorted_indices[i+1]][dim]\n                if max_obj - min_obj > 0:\n                    crowding_distance[sorted_indices[i]] += (next - prev) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    max_crowding = max(crowding_distance)\n    candidates = [i for i in range(n) if crowding_distance[i] == max_crowding]\n    base_solution = solutions[random.choice(candidates)].copy()\n\n    # Adaptive segment reversal and edge swapping\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Edge swapping\n        i, j = sorted(random.sample(range(n_nodes), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the best balance between objective values (using a geometric mean-based selection), then applies a novel local search strategy combining adaptive path reinsertion and multi-objective edge optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best balance between objectives (geometric mean)\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Calculate geometric mean for each solution\n    geometric_means = [(obj[0] * obj[1]) ** 0.5 for obj in objectives]\n\n    # Select solution with best balance\n    best_idx = np.argmin(geometric_means)\n    base_solution = solutions[best_idx].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive path reinsertion\n        segment_length = random.randint(2, min(4, n_nodes // 3))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Remove segment and reinsert at random position\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Multi-objective edge optimization\n        i, j = sorted(random.sample(range(n_nodes - segment_length + 1), 2))\n        if i != j:\n            # Calculate total distance before swap\n            dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate total distance after swap\n            dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Apply swap if it improves at least one objective\n            if (dist1_after <= dist1_before and dist2_after <= dist2_before) and (dist1_after < dist1_before or dist2_after < dist2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.787702405034798,
            0.23358303308486938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best balance between objectives (geometric mean)\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(objectives)\n\n    if n == 0:\n        return solutions[0].copy()\n\n    # Calculate geometric mean for each solution\n    geometric_means = [(obj[0] * obj[1]) ** 0.5 for obj in objectives]\n\n    # Select solution with best balance\n    best_idx = np.argmin(geometric_means)\n    base_solution = solutions[best_idx].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 3:\n        # Adaptive path reinsertion\n        segment_length = random.randint(2, min(4, n_nodes // 3))\n        start = random.randint(0, n_nodes - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Remove segment and reinsert at random position\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Multi-objective edge optimization\n        i, j = sorted(random.sample(range(n_nodes - segment_length + 1), 2))\n        if i != j:\n            # Calculate total distance before swap\n            dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate total distance after swap\n            dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Apply swap if it improves at least one objective\n            if (dist1_after <= dist1_before and dist2_after <= dist2_before) and (dist1_after < dist1_before or dist2_after < dist2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a hybrid local search combining random segment reversal and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge swapping\n    if n > 3:\n        # Step 1: Random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8157282295649605,
            0.2193279266357422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: random segment reversal and edge swapping\n    if n > 3:\n        # Step 1: Random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and distance metrics, then applies a hybrid local search combining edge reversal and segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = -float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        # Weighted score combining objectives and distance metrics\n        score = -obj[0] - obj[1] + 0.5 * (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]])\n        if score > best_score:\n            best_score = score\n            best_solution = sol\n\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal and segment insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment insertion (move a segment to a new position)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7237450981149779,
            0.23474550247192383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = -float('inf')\n    best_solution = None\n    for sol, obj in archive:\n        # Weighted score combining objectives and distance metrics\n        score = -obj[0] - obj[1] + 0.5 * (distance_matrix_1[sol[-1], sol[0]] + distance_matrix_2[sol[-1], sol[0]])\n        if score > best_score:\n            best_score = score\n            best_solution = sol\n\n    base_solution = best_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge reversal and segment insertion\n    if n > 3:\n        # Step 1: Edge reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Segment insertion (move a segment to a new position)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume-based selection criterion, then applies a novel local search operator combining adaptive segment rotation and distance-aware node insertion to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1  # Reference point for hypervolume calculation\n    hypervolumes = []\n    for obj in objectives:\n        hypervolumes.append((ref_point[0] - obj[0]) * (ref_point[1] - obj[1]))\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive segment rotation and distance-aware insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a segment to rotate adaptively\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(segment, rotation)\n\n        # Find a position to insert the rotated segment\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            # Calculate improvement potential based on distance matrices\n            original_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], rotated_segment[0]] +\n                        distance_matrix_2[new_solution[pos-1], rotated_segment[0]])\n            improvement = original_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                rotated_segment,\n                new_solution[best_pos+segment_length:]\n            ])\n\n        # Distance-aware node insertion\n        nodes_to_insert = np.setdiff1d(np.arange(n), new_solution)\n        if len(nodes_to_insert) > 0:\n            for node in nodes_to_insert:\n                best_insert_pos = -1\n                best_insert_value = float('inf')\n                for pos in range(n):\n                    # Calculate insertion cost based on both distance matrices\n                    cost = (distance_matrix_1[new_solution[pos-1], node] +\n                            distance_matrix_1[node, new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], node] +\n                            distance_matrix_2[node, new_solution[pos]])\n                    if cost < best_insert_value:\n                        best_insert_value = cost\n                        best_insert_pos = pos\n                if best_insert_pos != -1:\n                    new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[np.where(new_solution == unique_nodes[i])[0][0]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9219477201089967,
            0.31579649448394775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1  # Reference point for hypervolume calculation\n    hypervolumes = []\n    for obj in objectives:\n        hypervolumes.append((ref_point[0] - obj[0]) * (ref_point[1] - obj[1]))\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive segment rotation and distance-aware insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select a segment to rotate adaptively\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(segment, rotation)\n\n        # Find a position to insert the rotated segment\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n - segment_length + 1):\n            if pos == start:\n                continue\n            # Calculate improvement potential based on distance matrices\n            original_cost = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n            new_cost = (distance_matrix_1[new_solution[pos-1], rotated_segment[0]] +\n                        distance_matrix_2[new_solution[pos-1], rotated_segment[0]])\n            improvement = original_cost - new_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                rotated_segment,\n                new_solution[best_pos+segment_length:]\n            ])\n\n        # Distance-aware node insertion\n        nodes_to_insert = np.setdiff1d(np.arange(n), new_solution)\n        if len(nodes_to_insert) > 0:\n            for node in nodes_to_insert:\n                best_insert_pos = -1\n                best_insert_value = float('inf')\n                for pos in range(n):\n                    # Calculate insertion cost based on both distance matrices\n                    cost = (distance_matrix_1[new_solution[pos-1], node] +\n                            distance_matrix_1[node, new_solution[pos]] +\n                            distance_matrix_2[new_solution[pos-1], node] +\n                            distance_matrix_2[node, new_solution[pos]])\n                    if cost < best_insert_value:\n                        best_insert_value = cost\n                        best_insert_pos = pos\n                if best_insert_pos != -1:\n                    new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[np.where(new_solution == unique_nodes[i])[0][0]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid scoring metric combining objective diversity and Pareto dominance, then applies a novel local search combining 3-opt and segment-based reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominated_count = 0\n        diversity_score = 0\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated_count += 1\n            diversity_score += abs(other_obj[0] - obj[0]) + abs(other_obj[1] - obj[1])\n        scores.append((-dominated_count, diversity_score))\n\n    if scores:\n        # Select solution with best combined score\n        selected_idx = max(range(len(scores)), key=lambda i: (scores[i][0], scores[i][1]))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Novel local search: 3-opt with segment-based reordering\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Reorder segments in a non-trivial way\n        new_solution[i:k] = np.concatenate([\n            segment1[::-1] if random.random() > 0.5 else segment1,\n            segment2[::-1] if random.random() > 0.5 else segment2\n        ])\n\n        # Additional segment-based reordering\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b] = np.concatenate([\n                new_solution[a:a+1],\n                new_solution[b-1:b],\n                new_solution[a+1:b-1][::-1]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8023971874100948,
            1.2562241554260254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominated_count = 0\n        diversity_score = 0\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated_count += 1\n            diversity_score += abs(other_obj[0] - obj[0]) + abs(other_obj[1] - obj[1])\n        scores.append((-dominated_count, diversity_score))\n\n    if scores:\n        # Select solution with best combined score\n        selected_idx = max(range(len(scores)), key=lambda i: (scores[i][0], scores[i][1]))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Novel local search: 3-opt with segment-based reordering\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Reorder segments in a non-trivial way\n        new_solution[i:k] = np.concatenate([\n            segment1[::-1] if random.random() > 0.5 else segment1,\n            segment2[::-1] if random.random() > 0.5 else segment2\n        ])\n\n        # Additional segment-based reordering\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b] = np.concatenate([\n                new_solution[a:a+1],\n                new_solution[b-1:b],\n                new_solution[a+1:b-1][::-1]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective score, then applies a hybrid local search combining segment rotation, node reinsertion, and adaptive edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    new_solution[a:b+1] = np.roll(segment, rotate_amount)\n\n    # Step 2: Node reinsertion based on distance improvement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        best_pos = 0\n        min_cost = float('inf')\n        for j in range(len(new_solution)):\n            temp = np.insert(new_solution, j, node)\n            cost = (distance_matrix_1[temp[j-1], temp[j]] + distance_matrix_1[temp[j], temp[(j+1)%n]]) + \\\n                   (distance_matrix_2[temp[j-1], temp[j]] + distance_matrix_2[temp[j], temp[(j+1)%n]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Adaptive edge flipping based on objective space\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            # Flip in first objective space\n            cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if cost_after < cost_before:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Flip in second objective space\n            cost_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            cost_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if cost_after < cost_before:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8655131991519646,
            0.7447720766067505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    new_solution[a:b+1] = np.roll(segment, rotate_amount)\n\n    # Step 2: Node reinsertion based on distance improvement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        best_pos = 0\n        min_cost = float('inf')\n        for j in range(len(new_solution)):\n            temp = np.insert(new_solution, j, node)\n            cost = (distance_matrix_1[temp[j-1], temp[j]] + distance_matrix_1[temp[j], temp[(j+1)%n]]) + \\\n                   (distance_matrix_2[temp[j-1], temp[j]] + distance_matrix_2[temp[j], temp[(j+1)%n]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Adaptive edge flipping based on objective space\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            # Flip in first objective space\n            cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            cost_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if cost_after < cost_before:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Flip in second objective space\n            cost_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            cost_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if cost_after < cost_before:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator combining segment relocation with a biased random walk to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with biased random walk\n    if n > 3:\n        # Select a segment to relocate\n        segment_start = random.randint(0, n - 3)\n        segment_length = random.randint(1, min(5, n - segment_start - 1))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n        # Find a new position for the segment based on biased random walk\n        # Calculate potential insertion positions and their quality\n        insertion_positions = []\n        for pos in range(n - segment_length + 1):\n            # Temporary insertion to evaluate quality\n            temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            quality = 0.4 * cost1 + 0.6 * cost2  # Biased towards second objective\n            insertion_positions.append((pos, quality))\n\n        # Select the position with best quality\n        best_pos = min(insertion_positions, key=lambda x: x[1])[0]\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.844680931301565,
            1.834187924861908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a balance between objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with biased random walk\n    if n > 3:\n        # Select a segment to relocate\n        segment_start = random.randint(0, n - 3)\n        segment_length = random.randint(1, min(5, n - segment_start - 1))\n        segment = new_solution[segment_start:segment_start + segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n        # Find a new position for the segment based on biased random walk\n        # Calculate potential insertion positions and their quality\n        insertion_positions = []\n        for pos in range(n - segment_length + 1):\n            # Temporary insertion to evaluate quality\n            temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            quality = 0.4 * cost1 + 0.6 * cost2  # Biased towards second objective\n            insertion_positions.append((pos, quality))\n\n        # Select the position with best quality\n        best_pos = min(insertion_positions, key=lambda x: x[1])[0]\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment inversion with a guided edge exchange strategy, prioritizing solutions with high variance in objective costs to balance exploration and exploitation while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    if len(variances) > 0:\n        selected_idx = np.argmax(variances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Random segment inversion\n    start, end = sorted(np.random.choice(range(n), 2, replace=False))\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Guided edge exchange\n    for i in range(n):\n        for j in range(i+2, n):\n            # Calculate cost change in both objectives\n            a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n            delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n            # Accept if both objectives improve or one improves significantly\n            if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.1 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.1 * abs(delta2)):\n                # Perform edge exchange\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of Pareto dominance and objective variance, then applies a novel hybrid local search combining adaptive segment reversal and guided node swapping, while prioritizing improvements in the objective with higher variance to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select solution with highest variance in objectives\n        variances = [abs(obj[0] - obj[1]) for _, obj in non_dominated]\n        selected_idx = np.argmax(variances)\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and guided node swapping\n    if n > 3:\n        # Adaptive segment reversal based on objective variance\n        obj1_var = np.var([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        obj2_var = np.var([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n\n        if obj1_var > obj2_var:\n            # Reverse a segment to potentially improve objective 1\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            # Reverse a segment to potentially improve objective 2\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Guided node swapping based on edge cost improvement\n        for i in range(n):\n            for j in range(i+2, min(i+5, n)):\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n                delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n                delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n                if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.2 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.2 * abs(delta2)):\n                    # Perform node swap\n                    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n                    break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7038770968525465,
            5.126727223396301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if non_dominated:\n        # Select solution with highest variance in objectives\n        variances = [abs(obj[0] - obj[1]) for _, obj in non_dominated]\n        selected_idx = np.argmax(variances)\n        base_solution = non_dominated[selected_idx][0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and guided node swapping\n    if n > 3:\n        # Adaptive segment reversal based on objective variance\n        obj1_var = np.var([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        obj2_var = np.var([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n\n        if obj1_var > obj2_var:\n            # Reverse a segment to potentially improve objective 1\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            # Reverse a segment to potentially improve objective 2\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Guided node swapping based on edge cost improvement\n        for i in range(n):\n            for j in range(i+2, min(i+5, n)):\n                a, b, c, d = new_solution[i], new_solution[i+1], new_solution[j], new_solution[(j+1)%n]\n                delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n                delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n\n                if (delta1 < 0 and delta2 < 0) or (delta1 < 0 and abs(delta2) < 0.2 * abs(delta1)) or (delta2 < 0 and abs(delta1) < 0.2 * abs(delta2)):\n                    # Perform node swap\n                    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n                    break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search combining segment reversal, node swapping, and partial path relinking to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Calculate diversity scores based on Euclidean distance in objective space\n        diversity_scores = []\n        for i in range(len(archive)):\n            distances = [np.linalg.norm(np.array(objectives[i]) - np.array(objectives[j])) for j in range(len(archive)) if i != j]\n            diversity_scores.append(np.mean(distances))\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: combine segment reversal, node swapping, and partial path relinking\n    if n > 3:\n        # Step 1: Segment reversal with high potential\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Node swapping based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swapping i and j improves both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Partial path relinking (swap segments based on objective improvement)\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(5, n//2))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            # Swap nodes if it improves at least one objective\n            if p+1 < n:\n                current_cost1 = distance_matrix_1[new_solution[p], new_solution[p+1]]\n                current_cost2 = distance_matrix_2[new_solution[p], new_solution[p+1]]\n                new_cost1 = distance_matrix_1[base_solution[p], base_solution[p+1]]\n                new_cost2 = distance_matrix_2[base_solution[p], base_solution[p+1]]\n                if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or random.random() < 0.2:\n                    new_solution[p], new_solution[p+1] = base_solution[p], base_solution[p+1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reconstruct solution if invalid\n        missing = set(range(n)) - set(unique_nodes)\n        new_solution = np.concatenate([new_solution, list(missing)])\n        random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7376591592634465,
            10.30337393283844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Calculate diversity scores based on Euclidean distance in objective space\n        diversity_scores = []\n        for i in range(len(archive)):\n            distances = [np.linalg.norm(np.array(objectives[i]) - np.array(objectives[j])) for j in range(len(archive)) if i != j]\n            diversity_scores.append(np.mean(distances))\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: combine segment reversal, node swapping, and partial path relinking\n    if n > 3:\n        # Step 1: Segment reversal with high potential\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Node swapping based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swapping i and j improves both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Partial path relinking (swap segments based on objective improvement)\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(5, n//2))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            # Swap nodes if it improves at least one objective\n            if p+1 < n:\n                current_cost1 = distance_matrix_1[new_solution[p], new_solution[p+1]]\n                current_cost2 = distance_matrix_2[new_solution[p], new_solution[p+1]]\n                new_cost1 = distance_matrix_1[base_solution[p], base_solution[p+1]]\n                new_cost2 = distance_matrix_2[base_solution[p], base_solution[p+1]]\n                if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or random.random() < 0.2:\n                    new_solution[p], new_solution[p+1] = base_solution[p], base_solution[p+1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reconstruct solution if invalid\n        missing = set(range(n)) - set(unique_nodes)\n        new_solution = np.concatenate([new_solution, list(missing)])\n        random.shuffle(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining segment reversal, node reinsertion, and guided path relinking to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with adaptive length\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(1, min(7, n//3))\n    seg_end = min(seg_start + seg_length, n)\n    new_solution[seg_start:seg_end] = np.flip(new_solution[seg_start:seg_end])\n\n    # Step 2: Guided node reinsertion based on distance matrices\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        # Find insertion position that minimizes both distances\n        best_pos = 0\n        best_score = float('inf')\n        for j in range(len(new_solution)):\n            if j == 0:\n                d1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n                d2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                d1 = distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[j]]\n                d2 = distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[j]]\n            score = d1 + d2\n            if score < best_score:\n                best_score = score\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided path relinking with objective-aware selection\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(4, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            # Prefer swaps that improve both objectives\n            current_node = new_solution[p]\n            base_node = base_solution[p]\n            d1_current = distance_matrix_1[new_solution[p-1], current_node] + distance_matrix_1[current_node, new_solution[(p+1)%n]]\n            d2_current = distance_matrix_2[new_solution[p-1], current_node] + distance_matrix_2[current_node, new_solution[(p+1)%n]]\n            d1_base = distance_matrix_1[new_solution[p-1], base_node] + distance_matrix_1[base_node, new_solution[(p+1)%n]]\n            d2_base = distance_matrix_2[new_solution[p-1], base_node] + distance_matrix_2[base_node, new_solution[(p+1)%n]]\n            if (d1_base + d2_base) < (d1_current + d2_current):\n                new_solution[p] = base_node\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8277514746215262,
            0.3002780079841614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with adaptive length\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(1, min(7, n//3))\n    seg_end = min(seg_start + seg_length, n)\n    new_solution[seg_start:seg_end] = np.flip(new_solution[seg_start:seg_end])\n\n    # Step 2: Guided node reinsertion based on distance matrices\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        # Find insertion position that minimizes both distances\n        best_pos = 0\n        best_score = float('inf')\n        for j in range(len(new_solution)):\n            if j == 0:\n                d1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n                d2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                d1 = distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[j]]\n                d2 = distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[j]]\n            score = d1 + d2\n            if score < best_score:\n                best_score = score\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided path relinking with objective-aware selection\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(4, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            # Prefer swaps that improve both objectives\n            current_node = new_solution[p]\n            base_node = base_solution[p]\n            d1_current = distance_matrix_1[new_solution[p-1], current_node] + distance_matrix_1[current_node, new_solution[(p+1)%n]]\n            d2_current = distance_matrix_2[new_solution[p-1], current_node] + distance_matrix_2[current_node, new_solution[(p+1)%n]]\n            d1_base = distance_matrix_1[new_solution[p-1], base_node] + distance_matrix_1[base_node, new_solution[(p+1)%n]]\n            d2_base = distance_matrix_2[new_solution[p-1], base_node] + distance_matrix_2[base_node, new_solution[(p+1)%n]]\n            if (d1_base + d2_base) < (d1_current + d2_current):\n                new_solution[p] = base_node\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment insertion and random segment shuffling to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.exp(objectives * weights)\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Insert segment and shuffle\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n    # Option 2: Random segment swap with insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8466090374961941,
            0.12832921743392944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.exp(objectives * weights)\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Insert segment and shuffle\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n    # Option 2: Random segment swap with insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The algorithm selects a solution from the archive based on the worst objective value, then applies a hybrid local search combining node swapping with a probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = worst_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Perform node swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.3:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([\n                new_solution[:k],\n                [new_solution[l]],\n                new_solution[k:l],\n                [new_solution[k]],\n                new_solution[l:]\n            ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(worst_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8686109153900015,
            0.16374021768569946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = worst_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Perform node swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.3:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([\n                new_solution[:k],\n                [new_solution[l]],\n                new_solution[k:l],\n                [new_solution[k]],\n                new_solution[l:]\n            ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(worst_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hyperbolic weighted combination of objectives, then applies a hybrid local search combining segment reversal, random insertion, and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hyperbolic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.reciprocal(objectives * weights + 1)\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Option 1: Reverse segment and insert node\n    if np.random.rand() < 0.4:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        node = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    # Option 2: Swap nodes and reverse segment\n    else:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.889085053398976,
            0.30541491508483887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hyperbolic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.reciprocal(objectives * weights + 1)\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Option 1: Reverse segment and insert node\n    if np.random.rand() < 0.4:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        node = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n    # Option 2: Swap nodes and reverse segment\n    else:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized combination of objective values, then applies a hybrid local search combining edge swapping with a randomized segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    weighted_solutions = []\n    for sol, obj in archive:\n        normalized_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        normalized_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        score = 0.5 * normalized_obj1 + 0.5 * normalized_obj2\n        weighted_solutions.append((score, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: randomly choose between edge swap and segment reversal\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8927192608962059,
            0.2658594250679016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    weighted_solutions = []\n    for sol, obj in archive:\n        normalized_obj1 = obj[0] / max_obj1 if max_obj1 != 0 else 0\n        normalized_obj2 = obj[1] / max_obj2 if max_obj2 != 0 else 0\n        score = 0.5 * normalized_obj1 + 0.5 * normalized_obj2\n        weighted_solutions.append((score, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: randomly choose between edge swap and segment reversal\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that prioritizes solutions with high diversity and low objective values, then applies a hybrid local search combining node swaps, inversions, and adaptive path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel selection based on diversity and objective values\n    def score(sol, obj):\n        diversity = len(set(sol))\n        return (diversity / len(sol)) * (1 / (obj[0] + obj[1] + 1))\n\n    scored = [(sol, obj, score(sol, obj)) for (sol, obj) in archive]\n    scored.sort(key=lambda x: -x[2])\n    base_solution = scored[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive node swaps and inversions\n    n = len(new_solution)\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Adaptive path relinking\n    relink_length = random.randint(1, min(5, n//3))\n    for _ in range(relink_length):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7457843371298842,
            0.29120004177093506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel selection based on diversity and objective values\n    def score(sol, obj):\n        diversity = len(set(sol))\n        return (diversity / len(sol)) * (1 / (obj[0] + obj[1] + 1))\n\n    scored = [(sol, obj, score(sol, obj)) for (sol, obj) in archive]\n    scored.sort(key=lambda x: -x[2])\n    base_solution = scored[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive node swaps and inversions\n    n = len(new_solution)\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Adaptive path relinking\n    relink_length = random.randint(1, min(5, n//3))\n    for _ in range(relink_length):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto-dominance aware selection, then applies a hybrid local search combining segment inversion with a probabilistic node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance aware selection\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with probabilistic node swap\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        if np.random.rand() < 0.3:  # 30% chance of additional swap\n            c, d = sorted(random.sample(range(n), 2))\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[i] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9463886281800731,
            0.3718452453613281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance aware selection\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with probabilistic node swap\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        if np.random.rand() < 0.3:  # 30% chance of additional swap\n            c, d = sorted(random.sample(range(n), 2))\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[i] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and spatial proximity, then applies a novel local search operator combining adaptive segment reversal with spatial-aware node insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and spatial diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    combined_scores = 0.6 * norm_objectives[:, 0] + 0.4 * norm_objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on spatial proximity\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_coords = instance[segment, :2]  # Using first space coordinates\n        centroid = segment_coords.mean(axis=0)\n        distances = np.linalg.norm(segment_coords - centroid, axis=1)\n        if random.random() < 0.7:  # Higher probability for reversal\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Spatial-aware node insertion\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        node_coords = instance[node, :2]\n        distances = np.linalg.norm(instance[:, :2] - node_coords, axis=1)\n        distances[new_solution] = np.inf  # Exclude current nodes\n        closest_pos = np.argmin(distances)\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, closest_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8300927209474441,
            0.2968295216560364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and spatial diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    combined_scores = 0.6 * norm_objectives[:, 0] + 0.4 * norm_objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal based on spatial proximity\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_coords = instance[segment, :2]  # Using first space coordinates\n        centroid = segment_coords.mean(axis=0)\n        distances = np.linalg.norm(segment_coords - centroid, axis=1)\n        if random.random() < 0.7:  # Higher probability for reversal\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Spatial-aware node insertion\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        node_coords = instance[node, :2]\n        distances = np.linalg.norm(instance[:, :2] - node_coords, axis=1)\n        distances[new_solution] = np.inf  # Exclude current nodes\n        closest_pos = np.argmin(distances)\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, closest_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining node relocations, segment reversals, and guided edge insertions to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Relocate a segment of nodes\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n//3))\n    seg_end = min(seg_start + seg_length, n)\n    segment = new_solution[seg_start:seg_end]\n    new_solution = np.delete(new_solution, slice(seg_start, seg_end))\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Reverse a random segment\n    rev_start = random.randint(0, n-1)\n    rev_length = random.randint(2, min(5, n//3))\n    rev_end = min(rev_start + rev_length, n)\n    new_solution[rev_start:rev_end] = np.flip(new_solution[rev_start:rev_end])\n\n    # Step 3: Guided edge insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8680571286780838,
            0.23493188619613647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential\n    selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Relocate a segment of nodes\n    seg_start = random.randint(0, n-1)\n    seg_length = random.randint(2, min(5, n//3))\n    seg_end = min(seg_start + seg_length, n)\n    segment = new_solution[seg_start:seg_end]\n    new_solution = np.delete(new_solution, slice(seg_start, seg_end))\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Reverse a random segment\n    rev_start = random.randint(0, n-1)\n    rev_length = random.randint(2, min(5, n//3))\n    rev_end = min(rev_start + rev_length, n)\n    new_solution[rev_start:rev_end] = np.flip(new_solution[rev_start:rev_end])\n\n    # Step 3: Guided edge insertion\n    for _ in range(2):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic selection criterion that balances objective values and solution quality, then applies a novel local search operator that combines segment rotations, node relocations, and adaptive edge exchanges to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection criterion: balance between objective values and solution diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([len(np.unique(sol)) for sol, _ in archive]) / len(archive[0][0])\n    selection_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator\n    # Step 1: Segment rotation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(1, min(5, n//2))\n    rotated_segment = np.roll(new_solution[a:b+1], k)\n\n    # Step 2: Node relocation with adaptive position\n    node = new_solution[np.random.randint(n)]\n    current_pos = np.where(new_solution == node)[0][0]\n    new_pos = (current_pos + np.random.randint(-5, 6)) % n\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Adaptive edge exchange\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7689281915291842,
            0.3294845223426819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection criterion: balance between objective values and solution diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([len(np.unique(sol)) for sol, _ in archive]) / len(archive[0][0])\n    selection_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search operator\n    # Step 1: Segment rotation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(1, min(5, n//2))\n    rotated_segment = np.roll(new_solution[a:b+1], k)\n\n    # Step 2: Node relocation with adaptive position\n    node = new_solution[np.random.randint(n)]\n    current_pos = np.where(new_solution == node)[0][0]\n    new_pos = (current_pos + np.random.randint(-5, 6)) % n\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Adaptive edge exchange\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and distance-based diversity, then applies a novel local search operator combining multi-segment relocation with adaptive perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        base_solution = archive[0][0].copy()\n        max_diversity = 0\n        for sol, _ in archive[1:]:\n            diversity = sum(distance_matrix_1[base_solution[i], sol[i]] for i in range(len(base_solution)))\n            if diversity > max_diversity:\n                max_diversity = diversity\n                base_solution = sol.copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment relocation with adaptive perturbation\n        num_segments = random.randint(1, min(3, n//4))\n        segments = []\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        # Sort segments by length (longer segments first)\n        segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n        for a, b in segments:\n            segment = new_solution[a:b]\n            # Find insertion point that minimizes total distance in both objectives\n            best_pos = a\n            best_cost = float('inf')\n            for pos in range(n - len(segment) + 1):\n                if pos >= a and pos < b:\n                    continue\n                temp = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n                cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                total_cost = 0.4 * cost1 + 0.6 * cost2\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:best_pos+len(segment)],\n                new_solution[best_pos+len(segment):]\n            ])\n\n        # Adaptive perturbation\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9382837662317309,
            1.5880826711654663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        base_solution = archive[0][0].copy()\n        max_diversity = 0\n        for sol, _ in archive[1:]:\n            diversity = sum(distance_matrix_1[base_solution[i], sol[i]] for i in range(len(base_solution)))\n            if diversity > max_diversity:\n                max_diversity = diversity\n                base_solution = sol.copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment relocation with adaptive perturbation\n        num_segments = random.randint(1, min(3, n//4))\n        segments = []\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        # Sort segments by length (longer segments first)\n        segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n        for a, b in segments:\n            segment = new_solution[a:b]\n            # Find insertion point that minimizes total distance in both objectives\n            best_pos = a\n            best_cost = float('inf')\n            for pos in range(n - len(segment) + 1):\n                if pos >= a and pos < b:\n                    continue\n                temp = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:pos+len(segment)],\n                    new_solution[pos+len(segment):]\n                ])\n                cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                total_cost = 0.4 * cost1 + 0.6 * cost2\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:best_pos+len(segment)],\n                new_solution[best_pos+len(segment):]\n            ])\n\n        # Adaptive perturbation\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines objective values and solution structure, then applies a hybrid local search combining segment relinking and adaptive node swaps to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware metric\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate diversity score (combination of objective values and structural diversity)\n    diversity_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        obj_score = obj[0] + obj[1]\n        struct_score = sum(1 for j in range(n) if sol[j] != archive[(i+1)%len(archive)][0][j])\n        diversity_scores.append(obj_score * struct_score)\n\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Segment relinking with adaptive length\n    segment_length = min(5, n//3)\n    for _ in range(2):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        if random.random() < 0.5:\n            # Relink with another random segment from base solution\n            other_start = random.randint(0, n - segment_length)\n            other_end = other_start + segment_length\n            new_solution[start:end] = base_solution[other_start:other_end]\n        else:\n            # Reverse segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Adaptive node swaps based on distance matrices\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (dist1_after < dist1_before and dist2_after < dist2_before) or random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.7723634614556388,
            0.23441004753112793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware metric\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Calculate diversity score (combination of objective values and structural diversity)\n    diversity_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        obj_score = obj[0] + obj[1]\n        struct_score = sum(1 for j in range(n) if sol[j] != archive[(i+1)%len(archive)][0][j])\n        diversity_scores.append(obj_score * struct_score)\n\n    selected_idx = np.argmin(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Segment relinking with adaptive length\n    segment_length = min(5, n//3)\n    for _ in range(2):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        if random.random() < 0.5:\n            # Relink with another random segment from base solution\n            other_start = random.randint(0, n - segment_length)\n            other_end = other_start + segment_length\n            new_solution[start:end] = base_solution[other_start:other_end]\n        else:\n            # Reverse segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Adaptive node swaps based on distance matrices\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (dist1_after < dist1_before and dist2_after < dist2_before) or random.random() < 0.2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive by prioritizing those with the highest Pareto dominance, then applies a hybrid local search combining edge insertion and node reordering to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and node reordering\n    if n > 3:\n        # Step 1: Edge insertion (randomly select 3 edges and reorder them)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j]\n        new_solution[i:j] = np.concatenate([segment[1:], segment[:1]])\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Step 2: Node reordering (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid of objective dominance and randomness, then applies a novel local search combining segment reversal and edge exchange to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if random.random() < 0.7:  # 70% chance to pick a non-dominated solution\n        non_dominated = []\n        for sol, obj in archive:\n            dominated = False\n            for _, other_obj in archive:\n                if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(sol)\n        if non_dominated:\n            base_solution = random.choice(non_dominated).copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment reversal and edge exchange\n    if n > 3:\n        # Step 1: Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Exchange two random edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(base_solution), sorted(unique_nodes)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9264409204773305,
            0.220661461353302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if random.random() < 0.7:  # 70% chance to pick a non-dominated solution\n        non_dominated = []\n        for sol, obj in archive:\n            dominated = False\n            for _, other_obj in archive:\n                if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append(sol)\n        if non_dominated:\n            base_solution = random.choice(non_dominated).copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: segment reversal and edge exchange\n    if n > 3:\n        # Step 1: Reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Step 2: Exchange two random edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(sorted(base_solution), sorted(unique_nodes)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps, while also incorporating adaptive segment selection and objective-aware segment swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])  # Adaptive weights\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective differences\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Objective-aware segment swapping\n    if np.random.rand() < 0.6:  # Higher probability for complex operation\n        # Reverse and swap segments with objective consideration\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1)) + sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n        cost2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1)) + sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n\n        if cost1 > cost2:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c+1:]])\n\n        # Additional reversal for diversity\n        if np.random.rand() < 0.3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Random swap with objective-aware node selection\n        swap_nodes = np.random.choice(new_solution, size=2, replace=False)\n        i, j = np.where(new_solution == swap_nodes[0])[0][0], np.where(new_solution == swap_nodes[1])[0][0]\n\n        # Calculate potential cost change\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost or np.random.rand() < 0.2:  # Accept if better or with small probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.7726261297809631,
            0.34598827362060547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])  # Adaptive weights\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective differences\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Objective-aware segment swapping\n    if np.random.rand() < 0.6:  # Higher probability for complex operation\n        # Reverse and swap segments with objective consideration\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1)) + sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n        cost2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1)) + sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n\n        if cost1 > cost2:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c+1:]])\n\n        # Additional reversal for diversity\n        if np.random.rand() < 0.3:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Random swap with objective-aware node selection\n        swap_nodes = np.random.choice(new_solution, size=2, replace=False)\n        i, j = np.where(new_solution == swap_nodes[0])[0][0], np.where(new_solution == swap_nodes[1])[0][0]\n\n        # Calculate potential cost change\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost or np.random.rand() < 0.2:  # Accept if better or with small probability\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9756998337097224,
            0.19906485080718994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9756998337097224,
            0.19906485080718994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic score combining objective values and solution diversity, then applies a hybrid local search involving adaptive edge swaps, partial path relinking, and constrained insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        # Score combines normalized objectives and solution diversity\n        norm_obj = (obj[0] / max(1, max(o[0] for _, o in archive)), obj[1] / max(1, max(o[1] for _, o in archive)))\n        diversity = len(set(sol)) / len(sol)\n        scores.append(norm_obj[0] * 0.4 + norm_obj[1] * 0.4 + diversity * 0.2)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive edge swap based on distance matrices\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j+1]\n    # Evaluate swap impact using both distance matrices\n    orig_cost = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + \\\n                sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    rev_segment = segment[::-1]\n    new_cost = sum(distance_matrix_1[rev_segment[k], rev_segment[k+1]] for k in range(len(rev_segment)-1)) + \\\n               sum(distance_matrix_2[rev_segment[k], rev_segment[k+1]] for k in range(len(rev_segment)-1))\n    if new_cost < orig_cost:\n        new_solution[i:j+1] = rev_segment\n\n    # Partial path relinking with probabilistic swaps\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(7, n//3))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            # Swap with node from base solution if beneficial\n            candidate = base_solution[p]\n            if candidate not in new_solution[:p] and candidate not in new_solution[p+1:]:\n                new_solution[p] = candidate\n\n    # Constrained insertion to maintain feasibility\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    # Insert at position with minimal combined distance impact\n    min_cost = float('inf')\n    best_pos = 0\n    for pos in range(len(new_solution)):\n        cost = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] + \\\n               distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8231668434382604,
            2.4572489857673645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        # Score combines normalized objectives and solution diversity\n        norm_obj = (obj[0] / max(1, max(o[0] for _, o in archive)), obj[1] / max(1, max(o[1] for _, o in archive)))\n        diversity = len(set(sol)) / len(sol)\n        scores.append(norm_obj[0] * 0.4 + norm_obj[1] * 0.4 + diversity * 0.2)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive edge swap based on distance matrices\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j+1]\n    # Evaluate swap impact using both distance matrices\n    orig_cost = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + \\\n                sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n    rev_segment = segment[::-1]\n    new_cost = sum(distance_matrix_1[rev_segment[k], rev_segment[k+1]] for k in range(len(rev_segment)-1)) + \\\n               sum(distance_matrix_2[rev_segment[k], rev_segment[k+1]] for k in range(len(rev_segment)-1))\n    if new_cost < orig_cost:\n        new_solution[i:j+1] = rev_segment\n\n    # Partial path relinking with probabilistic swaps\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(7, n//3))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            # Swap with node from base solution if beneficial\n            candidate = base_solution[p]\n            if candidate not in new_solution[:p] and candidate not in new_solution[p+1:]:\n                new_solution[p] = candidate\n\n    # Constrained insertion to maintain feasibility\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    # Insert at position with minimal combined distance impact\n    min_cost = float('inf')\n    best_pos = 0\n    for pos in range(len(new_solution)):\n        cost = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] + \\\n               distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if cost < min_cost:\n            min_cost = cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm selects a solution from the archive, applies a hybrid local search combining node swaps, path inversions, and objective-aware edge replacements to generate neighbors, while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential improvement (non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    node_i, node_j = new_solution[i], new_solution[j]\n\n    # Evaluate swap impact on both objectives\n    cost_before = (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                  distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n    cost_after = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                 distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n                 distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                 distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]])\n\n    if cost_after < cost_before:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Path inversion with segment selection\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Step 3: Edge replacement based on objective trade-off\n    k = random.randint(0, n-1)\n    candidates = [node for node in range(n) if node not in new_solution]\n\n    if candidates:\n        best_node = None\n        best_score = float('inf')\n\n        for node in candidates:\n            # Evaluate impact on both objectives\n            score = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                    distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n            if score < best_score:\n                best_score = score\n                best_node = node\n\n        if best_node is not None:\n            new_solution[k] = best_node\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8916188060091901,
            0.2954157590866089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential improvement (non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Objective-aware node swap\n    i, j = random.sample(range(n), 2)\n    node_i, node_j = new_solution[i], new_solution[j]\n\n    # Evaluate swap impact on both objectives\n    cost_before = (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                  distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                  distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n    cost_after = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                 distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n                 distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                 distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]])\n\n    if cost_after < cost_before:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Path inversion with segment selection\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Step 3: Edge replacement based on objective trade-off\n    k = random.randint(0, n-1)\n    candidates = [node for node in range(n) if node not in new_solution]\n\n    if candidates:\n        best_node = None\n        best_score = float('inf')\n\n        for node in candidates:\n            # Evaluate impact on both objectives\n            score = (distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] +\n                    distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]])\n\n            if score < best_score:\n                best_score = score\n                best_node = node\n\n        if best_node is not None:\n            new_solution[k] = best_node\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel local search operator combining adaptive segment reversal with a randomized node reinsertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (differing from the best solution)\n    best_solution = archive[0][0]\n    max_diversity = -1\n    selected_solution = None\n\n    for sol, _ in archive:\n        diversity = np.sum(sol != best_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = best_solution.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment reversal based on distance matrices\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_1[segment[-1], segment[0]]\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Reverse segment if it improves both objectives\n        if segment_cost1 > 0 and segment_cost2 > 0:\n            new_solution[a:b] = np.flip(segment)\n\n        # Randomized node reinsertion\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8466762489877241,
            0.42642438411712646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (differing from the best solution)\n    best_solution = archive[0][0]\n    max_diversity = -1\n    selected_solution = None\n\n    for sol, _ in archive:\n        diversity = np.sum(sol != best_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = best_solution.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment reversal based on distance matrices\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_1[segment[-1], segment[0]]\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Reverse segment if it improves both objectives\n        if segment_cost1 > 0 and segment_cost2 > 0:\n            new_solution[a:b] = np.flip(segment)\n\n        # Randomized node reinsertion\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining segment reversal, node reinsertion, and guided edge swaps to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate potential insertion positions based on both objectives\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n-1):\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swap based on both objectives\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Evaluate before and after swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement and applies a hybrid local search combining node clustering, guided segment relocation, and adaptive edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., high combined cost)\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Node clustering and relocation\n    cluster_size = random.randint(2, min(5, n//4))\n    start = random.randint(0, n - cluster_size)\n    cluster = new_solution[start:start+cluster_size]\n\n    # Evaluate insertion positions based on both objectives\n    best_pos = start\n    min_cost = float('inf')\n    for pos in range(n - cluster_size + 1):\n        if pos >= start and pos <= start + cluster_size - 1:\n            continue  # Skip current position\n        temp_solution = np.delete(new_solution, range(start, start+cluster_size))\n        temp_solution = np.insert(temp_solution, pos, cluster)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.delete(new_solution, range(start, start+cluster_size))\n    new_solution = np.insert(new_solution, best_pos, cluster)\n\n    # Step 2: Adaptive edge insertion\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n        # Evaluate insertion of node i before node j\n        temp_solution = np.delete(new_solution, i)\n        temp_solution = np.insert(temp_solution, j, new_solution[i])\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n\n        # Evaluate original cost\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        original_total = original_cost1 + original_cost2\n\n        if total_cost < original_total:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.668785472051215,
            0.9501115679740906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential (e.g., high combined cost)\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Node clustering and relocation\n    cluster_size = random.randint(2, min(5, n//4))\n    start = random.randint(0, n - cluster_size)\n    cluster = new_solution[start:start+cluster_size]\n\n    # Evaluate insertion positions based on both objectives\n    best_pos = start\n    min_cost = float('inf')\n    for pos in range(n - cluster_size + 1):\n        if pos >= start and pos <= start + cluster_size - 1:\n            continue  # Skip current position\n        temp_solution = np.delete(new_solution, range(start, start+cluster_size))\n        temp_solution = np.insert(temp_solution, pos, cluster)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.delete(new_solution, range(start, start+cluster_size))\n    new_solution = np.insert(new_solution, best_pos, cluster)\n\n    # Step 2: Adaptive edge insertion\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n        # Evaluate insertion of node i before node j\n        temp_solution = np.delete(new_solution, i)\n        temp_solution = np.insert(temp_solution, j, new_solution[i])\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = cost1 + cost2\n\n        # Evaluate original cost\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n        original_total = original_cost1 + original_cost2\n\n        if total_cost < original_total:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized and exponentially weighted combination of objectives, then applies a hybrid local search combining path relinking with a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    min_obj1, max_obj1 = min(obj1), max(obj1)\n    min_obj2, max_obj2 = min(obj2), max(obj2)\n\n    weighted_solutions = []\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        weight = 0.6 * norm_obj1 + 0.4 * norm_obj2  # Different weighting\n        weighted_solutions.append((weight, sol))\n\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking with segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Insert the inverted segment at a random position\n        insert_pos = random.randint(0, n - len(inverted_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            inverted_segment,\n            new_solution[insert_pos:insert_pos + len(inverted_segment)],\n            new_solution[insert_pos + len(inverted_segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8997708660532449,
            0.20984911918640137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    min_obj1, max_obj1 = min(obj1), max(obj1)\n    min_obj2, max_obj2 = min(obj2), max(obj2)\n\n    weighted_solutions = []\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        weight = 0.6 * norm_obj1 + 0.4 * norm_obj2  # Different weighting\n        weighted_solutions.append((weight, sol))\n\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking with segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Insert the inverted segment at a random position\n        insert_pos = random.randint(0, n - len(inverted_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            inverted_segment,\n            new_solution[insert_pos:insert_pos + len(inverted_segment)],\n            new_solution[insert_pos + len(inverted_segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining node reinsertion with a randomized segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.4 * obj[0] + 0.6 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node reinsertion: remove a random node and reinsert at a random position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Segment rotation: rotate a random segment by a random amount\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        rotate_by = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        rotated_segment = np.concatenate([segment[rotate_by:], segment[:rotate_by]])\n        new_solution[a:b] = rotated_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.794397686319626,
            0.27692002058029175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.4 * obj[0] + 0.6 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node reinsertion: remove a random node and reinsert at a random position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Segment rotation: rotate a random segment by a random amount\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        rotate_by = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        rotated_segment = np.concatenate([segment[rotate_by:], segment[:rotate_by]])\n        new_solution[a:b] = rotated_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify diverse solutions, then applies a hybrid local search combining edge insertion with a randomized segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (diverse solutions)\n    if len(archive) > 1:\n        objs = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objs[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[j]] += (objs[sorted_idx[j+1], i] - objs[sorted_idx[j-1], i])\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge insertion + segment reversal\n        # Select a random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select a random segment to insert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Insert the segment and reverse it\n        insert_pos = random.randint(0, n - len(segment))\n        new_segment = segment[::-1]  # Reverse the segment\n\n        # Reconstruct the solution\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_segment,\n            new_solution[j:]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8089614599866655,
            0.2793172597885132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (diverse solutions)\n    if len(archive) > 1:\n        objs = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objs[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[j]] += (objs[sorted_idx[j+1], i] - objs[sorted_idx[j-1], i])\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge insertion + segment reversal\n        # Select a random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select a random segment to insert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Insert the segment and reverse it\n        insert_pos = random.randint(0, n - len(segment))\n        new_segment = segment[::-1]  # Reverse the segment\n\n        # Reconstruct the solution\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_segment,\n            new_solution[j:]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The algorithm selects a solution from the archive based on the ratio of its objectives, then applies a hybrid local search combining edge swaps with a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sol = max(archive, key=lambda x: x[1][0] / x[1][1])[0].copy()\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: edge swaps with probabilistic segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.3:  # 30% chance of segment reversal\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = selected_sol.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8698943650795801,
            0.20556634664535522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_sol = max(archive, key=lambda x: x[1][0] / x[1][1])[0].copy()\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: edge swaps with probabilistic segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.3:  # 30% chance of segment reversal\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:  # Edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = selected_sol.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid scoring function that combines objective values and diversity, then applies a novel local search combining 3-opt moves, path relinking, and randomized edge insertions to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid scoring function: combine objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity = len(set(sol)) / len(sol)\n        scores.append(obj_score * (1 + diversity))\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: combine 3-opt, path relinking, and randomized insertions\n    if n >= 3:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment2, segment1])\n        new_solution[i:k] = new_segment\n\n    # Path relinking with probability\n    if random.random() < 0.4:\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(5, n//3))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if random.random() < 0.4:\n                new_solution[p] = base_solution[p]\n\n    # Randomized edge insertion\n    if random.random() < 0.3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8848459462579102,
            0.4244200587272644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid scoring function: combine objective values and diversity\n    scores = []\n    for sol, obj in archive:\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity = len(set(sol)) / len(sol)\n        scores.append(obj_score * (1 + diversity))\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: combine 3-opt, path relinking, and randomized insertions\n    if n >= 3:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_segment = np.concatenate([segment2, segment1])\n        new_solution[i:k] = new_segment\n\n    # Path relinking with probability\n    if random.random() < 0.4:\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(5, n//3))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if random.random() < 0.4:\n                new_solution[p] = base_solution[p]\n\n    # Randomized edge insertion\n    if random.random() < 0.3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a Pareto-dominance aware selection, then applies a hybrid local search combining segment inversion with a probabilistic node swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance aware selection\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    selected_idx = np.random.choice(len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with probabilistic node swap\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        if np.random.rand() < 0.3:  # 30% chance of additional swap\n            c, d = sorted(random.sample(range(n), 2))\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[i] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance aware selection, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance aware selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with probabilistic edge insertion\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        if np.random.rand() < 0.4:  # 40% chance of edge insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[i] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8011568843001651,
            0.4144632816314697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance aware selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with probabilistic edge insertion\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        if np.random.rand() < 0.4:  # 40% chance of edge insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = random.randint(0, len(new_solution)-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[i] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on the worst objective value, then applies a hybrid local search combining node swapping with a probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    worst_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = worst_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Perform node swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.3:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([\n                new_solution[:k],\n                [new_solution[l]],\n                new_solution[k:l],\n                [new_solution[k]],\n                new_solution[l:]\n            ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(worst_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a novel \"path fragmentation and reassembly\" operator with a probabilistic node relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            idx1 = sorted_obj1.index((obj1, obj2))\n            idx2 = sorted_obj2.index((obj1, obj2))\n\n            dist1 = (sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]) if idx1 > 0 and idx1 < len(sorted_obj1)-1 else float('inf')\n            dist2 = (sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]) if idx2 > 0 and idx2 < len(sorted_obj2)-1 else float('inf')\n\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solution with minimum crowding distance (most crowded area)\n    selected_idx = crowding_distances.index(min(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path fragmentation and reassembly\n        k = random.randint(2, n-2)\n        split_points = sorted(random.sample(range(1, n-1), k-1))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(new_solution[prev:point])\n            prev = point\n        segments.append(new_solution[prev:])\n\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic node relocation\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.7163731630881391,
            0.2416452169418335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            idx1 = sorted_obj1.index((obj1, obj2))\n            idx2 = sorted_obj2.index((obj1, obj2))\n\n            dist1 = (sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]) if idx1 > 0 and idx1 < len(sorted_obj1)-1 else float('inf')\n            dist2 = (sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]) if idx2 > 0 and idx2 < len(sorted_obj2)-1 else float('inf')\n\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solution with minimum crowding distance (most crowded area)\n    selected_idx = crowding_distances.index(min(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path fragmentation and reassembly\n        k = random.randint(2, n-2)\n        split_points = sorted(random.sample(range(1, n-1), k-1))\n        segments = []\n        prev = 0\n        for point in split_points:\n            segments.append(new_solution[prev:point])\n            prev = point\n        segments.append(new_solution[prev:])\n\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic node relocation\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search combining reverse-segment relocation, crossover with a random solution, and adaptive edge perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_diversity_idx = max(range(len(objectives)), key=lambda i: objectives[i][0] * objectives[i][1])\n    base_solution = archive[max_diversity_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Reverse-segment relocation with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    new_solution[start_pos:start_pos+segment_length] = np.flip(new_solution[start_pos:start_pos+segment_length])\n\n    # Step 2: Crossover with a random solution from archive\n    if len(archive) > 1:\n        other_solution = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Step 3: Adaptive edge perturbation based on objective values\n    obj1, obj2 = archive[max_diversity_idx][1]\n    perturbation_rate = min(0.5, (obj1 + obj2) / (2 * n * 1000))  # Normalized perturbation rate\n\n    for i in range(n):\n        if random.random() < perturbation_rate:\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.916927041972878,
            0.30050110816955566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_diversity_idx = max(range(len(objectives)), key=lambda i: objectives[i][0] * objectives[i][1])\n    base_solution = archive[max_diversity_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Reverse-segment relocation with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    new_solution[start_pos:start_pos+segment_length] = np.flip(new_solution[start_pos:start_pos+segment_length])\n\n    # Step 2: Crossover with a random solution from archive\n    if len(archive) > 1:\n        other_solution = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Step 3: Adaptive edge perturbation based on objective values\n    obj1, obj2 = archive[max_diversity_idx][1]\n    perturbation_rate = min(0.5, (obj1 + obj2) / (2 * n * 1000))  # Normalized perturbation rate\n\n    for i in range(n):\n        if random.random() < perturbation_rate:\n            j = random.randint(0, n-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment insertion and random segment shuffling to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.exp(objectives * weights)\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Insert segment and shuffle\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n    # Option 2: Random segment swap with insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective ranking, then applies a hybrid local search combining multi-segment rotation and adaptive edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware objective ranking\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-6)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation\n    if n > 4:\n        k = random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Adaptive edge flipping\n        flip_prob = min(0.5, 1.0 / (n * 0.2))\n        for i in range(n-1):\n            if random.random() < flip_prob:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(len(missing_nodes)):\n            new_solution[np.where(new_solution == unique_nodes[i])[0][0]] = missing_nodes[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7430011640723976,
            0.41416895389556885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on diversity-aware objective ranking\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-6)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation\n    if n > 4:\n        k = random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Adaptive edge flipping\n        flip_prob = min(0.5, 1.0 / (n * 0.2))\n        for i in range(n-1):\n            if random.random() < flip_prob:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(len(missing_nodes)):\n            new_solution[np.where(new_solution == unique_nodes[i])[0][0]] = missing_nodes[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining node relocation and partial tour reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values and good diversity\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    candidates = [i for i, obj in enumerate(objectives) if obj == max_obj]\n    selected_idx = random.choice(candidates) if candidates else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: node relocation and partial tour reversal\n    if n > 3:\n        # Node relocation: move a random node to a random position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Partial tour reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9067474538347101,
            0.27735644578933716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective values and good diversity\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    candidates = [i for i, obj in enumerate(objectives) if obj == max_obj]\n    selected_idx = random.choice(candidates) if candidates else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: node relocation and partial tour reversal\n    if n > 3:\n        # Node relocation: move a random node to a random position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Partial tour reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a novel multi-segment inversion and edge rotation strategy to generate a neighbor solution while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_idx = np.lexsort((objectives[:, 0], objectives[:, 1]))\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-6)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and edge rotation\n    num_segments = random.randint(2, min(5, n//3))\n    segment_lengths = np.random.randint(2, n//num_segments, size=num_segments)\n    segment_lengths = segment_lengths / segment_lengths.sum() * (n - num_segments)\n    segment_lengths = np.round(segment_lengths).astype(int)\n    segment_lengths[-1] += n - sum(segment_lengths) - num_segments\n\n    start = 0\n    for length in segment_lengths:\n        if length > 1:\n            if random.random() < 0.5:\n                new_solution[start:start+length] = new_solution[start:start+length][::-1]\n            else:\n                rotation = random.randint(1, length-1)\n                new_solution[start:start+length] = np.roll(new_solution[start:start+length], rotation)\n        start += length + 1\n\n    # Repair mechanism to ensure feasibility\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    if len(unique_nodes) != n or np.any(counts > 1):\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        extra = new_solution[np.where(counts > 1)[0][0]] if np.any(counts > 1) else None\n\n        for node in missing:\n            pos = np.where(new_solution == extra)[0][0] if extra is not None else random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n            extra = new_solution[pos] if pos < len(new_solution) else None\n\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8423843849775106,
            0.28142476081848145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_idx = np.lexsort((objectives[:, 0], objectives[:, 1]))\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-6)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and edge rotation\n    num_segments = random.randint(2, min(5, n//3))\n    segment_lengths = np.random.randint(2, n//num_segments, size=num_segments)\n    segment_lengths = segment_lengths / segment_lengths.sum() * (n - num_segments)\n    segment_lengths = np.round(segment_lengths).astype(int)\n    segment_lengths[-1] += n - sum(segment_lengths) - num_segments\n\n    start = 0\n    for length in segment_lengths:\n        if length > 1:\n            if random.random() < 0.5:\n                new_solution[start:start+length] = new_solution[start:start+length][::-1]\n            else:\n                rotation = random.randint(1, length-1)\n                new_solution[start:start+length] = np.roll(new_solution[start:start+length], rotation)\n        start += length + 1\n\n    # Repair mechanism to ensure feasibility\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    if len(unique_nodes) != n or np.any(counts > 1):\n        missing = np.setdiff1d(np.arange(n), unique_nodes)\n        extra = new_solution[np.where(counts > 1)[0][0]] if np.any(counts > 1) else None\n\n        for node in missing:\n            pos = np.where(new_solution == extra)[0][0] if extra is not None else random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n            extra = new_solution[pos] if pos < len(new_solution) else None\n\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining edge exchange with a randomized node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive.sort(key=lambda x: x[1][0] + x[1][1])\n        base_solution = archive[-1][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid edge exchange with randomized reinsertion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n\n        # Randomly reinsert a node\n        node_to_reinsert = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_reinsert)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_reinsert)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.903489271308896,
            0.35523444414138794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive.sort(key=lambda x: x[1][0] + x[1][1])\n        base_solution = archive[-1][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid edge exchange with randomized reinsertion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]  # Reverse segment\n\n        # Randomly reinsert a node\n        node_to_reinsert = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_reinsert)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_reinsert)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining node swaps, segment reversals, and guided path relinking to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Node swap with guided selection\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal with objective-aware selection\n    segment_start = random.randint(0, n-2)\n    segment_length = random.randint(2, min(5, n-segment_start))\n    segment_end = segment_start + segment_length\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 3: Guided path relinking\n    for k in range(n):\n        if random.random() < 0.2:\n            if distance_matrix_1[new_solution[k-1]][new_solution[k]] > distance_matrix_1[base_solution[k-1]][base_solution[k]]:\n                new_solution[k] = base_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9333431946229539,
            0.22335606813430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Node swap with guided selection\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal with objective-aware selection\n    segment_start = random.randint(0, n-2)\n    segment_length = random.randint(2, min(5, n-segment_start))\n    segment_end = segment_start + segment_length\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Step 3: Guided path relinking\n    for k in range(n):\n        if random.random() < 0.2:\n            if distance_matrix_1[new_solution[k-1]][new_solution[k]] > distance_matrix_1[base_solution[k-1]][base_solution[k]]:\n                new_solution[k] = base_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on the worst objective value, then applies a hybrid local search combining node swapping with a probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    worst_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = worst_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Perform node swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.3:\n            k, l = sorted(random.sample(range(n), 2))\n            new_solution = np.concatenate([\n                new_solution[:k],\n                [new_solution[l]],\n                new_solution[k:l],\n                [new_solution[k]],\n                new_solution[l:]\n            ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(worst_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The algorithm selects a solution from the archive based on a diversity-aware criterion, then applies a hybrid local search combining segment reversal with adaptive node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    base_solution = archive[diversity_scores.index(max(diversity_scores))][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node relocation\n        if random.random() < 0.5:\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.7290078144616823,
            0.7330941557884216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    base_solution = archive[diversity_scores.index(max(diversity_scores))][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node relocation\n        if random.random() < 0.5:\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a randomized node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    scored_solutions = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0]/max_obj1, obj[1]/max_obj2)\n        score = 0.5 * normalized_obj[0] + 0.5 * normalized_obj[1]\n        scored_solutions.append((score, sol))\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal combined with node swap\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_segment = segment[::-1]  # Reverse the segment\n\n        # Randomly swap two nodes in the segment\n        if len(new_segment) > 1:\n            i, j = random.sample(range(len(new_segment)), 2)\n            new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n\n        # Insert the modified segment back\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_segment,\n            new_solution[b:]\n        ])\n\n        # Ensure feasibility by removing duplicates and restoring missing nodes\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9638471075953843,
            0.3840113878250122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    scored_solutions = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0]/max_obj1, obj[1]/max_obj2)\n        score = 0.5 * normalized_obj[0] + 0.5 * normalized_obj[1]\n        scored_solutions.append((score, sol))\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal combined with node swap\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_segment = segment[::-1]  # Reverse the segment\n\n        # Randomly swap two nodes in the segment\n        if len(new_segment) > 1:\n            i, j = random.sample(range(len(new_segment)), 2)\n            new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n\n        # Insert the modified segment back\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_segment,\n            new_solution[b:]\n        ])\n\n        # Ensure feasibility by removing duplicates and restoring missing nodes\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge insertion with a randomized segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(obj[0] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    normalized_scores = []\n    for sol, obj in archive:\n        if max_obj1 != min_obj1 and max_obj2 != min_obj2:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1)\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2)\n            score = 0.4 * norm_obj1 + 0.6 * norm_obj2\n        else:\n            score = obj[0] + obj[1]\n        normalized_scores.append((score, sol))\n\n    normalized_scores.sort(key=lambda x: x[0])\n    base_solution = normalized_scores[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge insertion with randomized segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a new random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:insert_pos + len(reversed_segment)],\n            new_solution[insert_pos + len(reversed_segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9161461071416654,
            0.1570873260498047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(obj[0] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    normalized_scores = []\n    for sol, obj in archive:\n        if max_obj1 != min_obj1 and max_obj2 != min_obj2:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1)\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2)\n            score = 0.4 * norm_obj1 + 0.6 * norm_obj2\n        else:\n            score = obj[0] + obj[1]\n        normalized_scores.append((score, sol))\n\n    normalized_scores.sort(key=lambda x: x[0])\n    base_solution = normalized_scores[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge insertion with randomized segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a new random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:insert_pos + len(reversed_segment)],\n            new_solution[insert_pos + len(reversed_segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator combining segment inversion with adaptive path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and moderate objective values\n    objectives = [obj for (sol, obj) in archive]\n    avg_obj = np.mean(objectives, axis=0)\n    selected_idx = 0\n    max_diversity = -1\n\n    for i, (sol, obj) in enumerate(archive):\n        diversity = np.sum(np.abs(np.array(obj) - avg_obj))\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    seg_length = random.randint(2, min(5, n//3))\n    start_pos = random.randint(0, n - seg_length)\n    new_solution[start_pos:start_pos+seg_length] = np.flip(new_solution[start_pos:start_pos+seg_length])\n\n    # Adaptive path relinking with objective-based selection\n    if random.random() < 0.5:\n        ref_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        ref_solution = archive[ref_idx][0]\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(3, n//2))\n\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if ref_solution[p] in new_solution and new_solution[p] in ref_solution:\n                new_solution[p], ref_solution[p] = ref_solution[p], new_solution[p]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7272730308900135,
            0.3951415419578552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and moderate objective values\n    objectives = [obj for (sol, obj) in archive]\n    avg_obj = np.mean(objectives, axis=0)\n    selected_idx = 0\n    max_diversity = -1\n\n    for i, (sol, obj) in enumerate(archive):\n        diversity = np.sum(np.abs(np.array(obj) - avg_obj))\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    seg_length = random.randint(2, min(5, n//3))\n    start_pos = random.randint(0, n - seg_length)\n    new_solution[start_pos:start_pos+seg_length] = np.flip(new_solution[start_pos:start_pos+seg_length])\n\n    # Adaptive path relinking with objective-based selection\n    if random.random() < 0.5:\n        ref_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        ref_solution = archive[ref_idx][0]\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(3, n//2))\n\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if ref_solution[p] in new_solution and new_solution[p] in ref_solution:\n                new_solution[p], ref_solution[p] = ref_solution[p], new_solution[p]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a randomized node swap and a segment reversal with dynamic segment length to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for selection\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n_solutions = len(solutions)\n\n    if n_solutions == 1:\n        base_solution = solutions[0].copy()\n    else:\n        # Sort by each objective\n        sorted_obj1 = sorted(range(n_solutions), key=lambda i: objectives[i][0])\n        sorted_obj2 = sorted(range(n_solutions), key=lambda i: objectives[i][1])\n\n        crowding = np.zeros(n_solutions)\n        for i in range(n_solutions):\n            if i == 0 or i == n_solutions - 1:\n                crowding[i] = float('inf')\n            else:\n                # Crowding distance calculation\n                obj1_diff = (objectives[sorted_obj1[i+1]][0] - objectives[sorted_obj1[i-1]][0]) / (max(obj[0] for obj in objectives) - min(obj[0] for obj in objectives) + 1e-6)\n                obj2_diff = (objectives[sorted_obj2[i+1]][1] - objectives[sorted_obj2[i-1]][1]) / (max(obj[1] for obj in objectives) - min(obj[1] for obj in objectives) + 1e-6)\n                crowding[i] = obj1_diff + obj2_diff\n\n        # Select solution with highest crowding distance (most in need of improvement)\n        selected_idx = np.argmax(crowding)\n        base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomized node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Dynamic segment reversal\n        segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n        a = random.randint(0, n - segment_length)\n        new_solution[a:a+segment_length] = new_solution[a:a+segment_length][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7934330389978196,
            1.084966242313385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for selection\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n_solutions = len(solutions)\n\n    if n_solutions == 1:\n        base_solution = solutions[0].copy()\n    else:\n        # Sort by each objective\n        sorted_obj1 = sorted(range(n_solutions), key=lambda i: objectives[i][0])\n        sorted_obj2 = sorted(range(n_solutions), key=lambda i: objectives[i][1])\n\n        crowding = np.zeros(n_solutions)\n        for i in range(n_solutions):\n            if i == 0 or i == n_solutions - 1:\n                crowding[i] = float('inf')\n            else:\n                # Crowding distance calculation\n                obj1_diff = (objectives[sorted_obj1[i+1]][0] - objectives[sorted_obj1[i-1]][0]) / (max(obj[0] for obj in objectives) - min(obj[0] for obj in objectives) + 1e-6)\n                obj2_diff = (objectives[sorted_obj2[i+1]][1] - objectives[sorted_obj2[i-1]][1]) / (max(obj[1] for obj in objectives) - min(obj[1] for obj in objectives) + 1e-6)\n                crowding[i] = obj1_diff + obj2_diff\n\n        # Select solution with highest crowding distance (most in need of improvement)\n        selected_idx = np.argmax(crowding)\n        base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomized node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Dynamic segment reversal\n        segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n        a = random.randint(0, n - segment_length)\n        new_solution[a:a+segment_length] = new_solution[a:a+segment_length][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted hypervolume score combining normalized objective values with a bias towards solutions with better objective 1, then applies a hybrid local search combining edge reassignment and a randomized segment inversion with adjusted segment length probabilities to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted towards better objective 1\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment with probability-based selection\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-2)\n\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n            )\n\n        # Randomized segment inversion with adjusted segment length probabilities\n        segment_length = min(n // 2, max(2, int(np.random.exponential(scale=2))))\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8456398947034943,
            0.2995138168334961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted towards better objective 1\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment with probability-based selection\n        if random.random() < 0.6:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-2)\n\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n            )\n\n        # Randomized segment inversion with adjusted segment length probabilities\n        segment_length = min(n // 2, max(2, int(np.random.exponential(scale=2))))\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective score combining normalized objectives and diversity, then applies a hybrid local search using segment rotation and node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic objective score combining normalized objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.array([np.std(sol) for sol, _ in archive])\n    combined_scores = np.sqrt(normalized[:, 0]**2 + normalized[:, 1]**2) * (1 + diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three points\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Option 1: Rotate segment and swap nodes\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n    # Option 2: Swap segments with node insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        insert_pos = np.random.randint(a, min(b+1, len(new_solution)))\n        new_solution = np.insert(new_solution, insert_pos, new_solution[insert_pos])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.884942388998115,
            0.2983940839767456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic objective score combining normalized objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.array([np.std(sol) for sol, _ in archive])\n    combined_scores = np.sqrt(normalized[:, 0]**2 + normalized[:, 1]**2) * (1 + diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three points\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Option 1: Rotate segment and swap nodes\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        rotated = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n    # Option 2: Swap segments with node insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        insert_pos = np.random.randint(a, min(b+1, len(new_solution)))\n        new_solution = np.insert(new_solution, insert_pos, new_solution[insert_pos])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining a novel \"node cluster inversion\" and a \"multi-objective edge swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective differences\n        diversity_scores = []\n        for i, (sol1, obj1) in enumerate(archive):\n            score = 0\n            for j, (sol2, obj2) in enumerate(archive):\n                if i != j:\n                    score += abs(obj1[0] - obj2[0]) + abs(obj1[1] - obj2[1])\n            diversity_scores.append(score)\n        selected_idx = diversity_scores.index(max(diversity_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node cluster inversion\n    if n > 4:\n        cluster_size = random.randint(2, min(5, n//2))\n        start_pos = random.randint(0, n - cluster_size)\n        cluster = new_solution[start_pos:start_pos+cluster_size]\n\n        # Calculate cluster center in both spaces\n        cluster_coords = instance[cluster]\n        center1 = np.mean(cluster_coords[:, :2], axis=0)\n        center2 = np.mean(cluster_coords[:, 2:], axis=0)\n\n        # Find farthest node in the cluster from the center\n        distances1 = np.linalg.norm(cluster_coords[:, :2] - center1, axis=1)\n        distances2 = np.linalg.norm(cluster_coords[:, 2:] - center2, axis=1)\n        combined_dist = distances1 + distances2\n        farthest_idx = np.argmax(combined_dist)\n\n        # Invert the cluster around the farthest node\n        cluster = np.roll(cluster, -farthest_idx)\n        cluster = np.concatenate([cluster[:1], cluster[1:][::-1]])\n        new_solution[start_pos:start_pos+cluster_size] = cluster\n\n    # Multi-objective edge swap\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate edge costs before and after swap\n        before_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        after_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        before_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        after_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8841319745448519,
            2.148020029067993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective differences\n        diversity_scores = []\n        for i, (sol1, obj1) in enumerate(archive):\n            score = 0\n            for j, (sol2, obj2) in enumerate(archive):\n                if i != j:\n                    score += abs(obj1[0] - obj2[0]) + abs(obj1[1] - obj2[1])\n            diversity_scores.append(score)\n        selected_idx = diversity_scores.index(max(diversity_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node cluster inversion\n    if n > 4:\n        cluster_size = random.randint(2, min(5, n//2))\n        start_pos = random.randint(0, n - cluster_size)\n        cluster = new_solution[start_pos:start_pos+cluster_size]\n\n        # Calculate cluster center in both spaces\n        cluster_coords = instance[cluster]\n        center1 = np.mean(cluster_coords[:, :2], axis=0)\n        center2 = np.mean(cluster_coords[:, 2:], axis=0)\n\n        # Find farthest node in the cluster from the center\n        distances1 = np.linalg.norm(cluster_coords[:, :2] - center1, axis=1)\n        distances2 = np.linalg.norm(cluster_coords[:, 2:] - center2, axis=1)\n        combined_dist = distances1 + distances2\n        farthest_idx = np.argmax(combined_dist)\n\n        # Invert the cluster around the farthest node\n        cluster = np.roll(cluster, -farthest_idx)\n        cluster = np.concatenate([cluster[:1], cluster[1:][::-1]])\n        new_solution[start_pos:start_pos+cluster_size] = cluster\n\n    # Multi-objective edge swap\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate edge costs before and after swap\n        before_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        after_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        before_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        after_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept swap if it improves at least one objective\n        if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining edge swaps, insertions, and path relinking, while ensuring feasibility through validation and correction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on normalized objective values\n    objectives = [obj for (sol, obj) in archive]\n    normalized = [(obj[0] / (sum(o[0] for o in objectives) + 1e-8), obj[1] / (sum(o[1] for o in objectives) + 1e-8)) for obj in objectives]\n    selected_idx = np.argmax([(1 - n[0]) * (1 - n[1]) for n in normalized])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive parameters\n    n = len(new_solution)\n    k = min(3, n // 4)\n\n    # Step 1: Multiple edge swaps\n    for _ in range(k):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Step 2: Adaptive node insertion\n    for _ in range(k):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Selective path relinking\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(4, n//3))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8482663117167176,
            0.2453012466430664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on normalized objective values\n    objectives = [obj for (sol, obj) in archive]\n    normalized = [(obj[0] / (sum(o[0] for o in objectives) + 1e-8), obj[1] / (sum(o[1] for o in objectives) + 1e-8)) for obj in objectives]\n    selected_idx = np.argmax([(1 - n[0]) * (1 - n[1]) for n in normalized])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive parameters\n    n = len(new_solution)\n    k = min(3, n // 4)\n\n    # Step 1: Multiple edge swaps\n    for _ in range(k):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Step 2: Adaptive node insertion\n    for _ in range(k):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Selective path relinking\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(4, n//3))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This new algorithm prioritizes solutions with high objective diversity, then applies a hybrid local search combining segment relinking and randomized edge flipping to generate diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = []\n    for i, obj in enumerate(objectives):\n        diversity = sum(abs(obj[0] - o[0]) + abs(obj[1] - o[1]) for o in objectives)\n        diversity_scores.append((diversity, i))\n    diversity_scores.sort(reverse=True)\n    selected_idx = diversity_scores[0][1]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relinking and randomized edge flipping\n    n = len(new_solution)\n\n    # Segment relinking: replace a segment with a segment from another solution\n    if len(archive) > 1:\n        other_solution = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    # Randomized edge flipping: flip edges with a probability based on their potential improvement\n    for i in range(n-1):\n        if random.random() < 0.2:  # 20% probability to flip\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7372230314797951,
            2.960522174835205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = []\n    for i, obj in enumerate(objectives):\n        diversity = sum(abs(obj[0] - o[0]) + abs(obj[1] - o[1]) for o in objectives)\n        diversity_scores.append((diversity, i))\n    diversity_scores.sort(reverse=True)\n    selected_idx = diversity_scores[0][1]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relinking and randomized edge flipping\n    n = len(new_solution)\n\n    # Segment relinking: replace a segment with a segment from another solution\n    if len(archive) > 1:\n        other_solution = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    # Randomized edge flipping: flip edges with a probability based on their potential improvement\n    for i in range(n-1):\n        if random.random() < 0.2:  # 20% probability to flip\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining segment rotation and edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: choose a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum()  # Higher diversity is better\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation: rotate a random segment by a random amount\n    a, b = sorted(random.sample(range(n), 2))\n    rotation = random.randint(1, b - a)\n    segment = new_solution[a:b]\n    new_segment = np.roll(segment, rotation)\n    new_solution[a:b] = new_segment\n\n    # Edge flipping: flip a random edge if it improves both objectives\n    i = random.randint(0, n-2)\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[(i+2)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[(i+2)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+2)%n]] + distance_matrix_1[new_solution[(i+2)%n], new_solution[i+1]]\n    new_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+2)%n]] + distance_matrix_2[new_solution[(i+2)%n], new_solution[i+1]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[i+1], new_solution[(i+2)%n] = new_solution[(i+2)%n], new_solution[i+1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8205075146760612,
            0.29405027627944946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: choose a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0).sum()  # Higher diversity is better\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation: rotate a random segment by a random amount\n    a, b = sorted(random.sample(range(n), 2))\n    rotation = random.randint(1, b - a)\n    segment = new_solution[a:b]\n    new_segment = np.roll(segment, rotation)\n    new_solution[a:b] = new_segment\n\n    # Edge flipping: flip a random edge if it improves both objectives\n    i = random.randint(0, n-2)\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[(i+2)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[(i+2)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+2)%n]] + distance_matrix_1[new_solution[(i+2)%n], new_solution[i+1]]\n    new_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+2)%n]] + distance_matrix_2[new_solution[(i+2)%n], new_solution[i+1]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[i+1], new_solution[(i+2)%n] = new_solution[(i+2)%n], new_solution[i+1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a novel local search strategy combining segment reversal, node reinsertion with objective-aware placement, and guided path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    objectives = [obj for (sol, obj) in archive]\n    if len(objectives) > 1:\n        # Select a solution that is not the best in either objective\n        best_obj1 = min(objectives, key=lambda x: x[0])\n        best_obj2 = min(objectives, key=lambda x: x[1])\n        candidates = [i for i, obj in enumerate(objectives)\n                     if obj != best_obj1 and obj != best_obj2]\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search strategy\n    # Step 1: Segment reversal with objective-aware selection\n    segment_length = random.randint(2, min(5, n//3))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Evaluate segment reversal in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]]\n                        for i in range(segment_length))\n    reversed_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]]\n                         for i in range(segment_length-1))\n    if reversed_cost1 < original_cost1:\n        new_solution[start_pos:start_pos+segment_length] = np.flip(segment)\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position considering both objectives\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                distance_matrix_1[node, new_solution[pos]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n        cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                distance_matrix_2[node, new_solution[pos]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            # Swap nodes if it improves both objectives\n            node_new = new_solution[p]\n            node_base = base_solution[p]\n            cost1_new = (distance_matrix_1[new_solution[p-1], node_base] +\n                        distance_matrix_1[node_base, new_solution[(p+1)%n]] -\n                        distance_matrix_1[new_solution[p-1], new_solution[(p+1)%n]])\n            cost2_new = (distance_matrix_2[new_solution[p-1], node_base] +\n                        distance_matrix_2[node_base, new_solution[(p+1)%n]] -\n                        distance_matrix_2[new_solution[p-1], new_solution[(p+1)%n]])\n            if cost1_new < 0 and cost2_new < 0:\n                new_solution[p] = node_base\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.874290092661411,
            0.3391525149345398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective diversity\n    objectives = [obj for (sol, obj) in archive]\n    if len(objectives) > 1:\n        # Select a solution that is not the best in either objective\n        best_obj1 = min(objectives, key=lambda x: x[0])\n        best_obj2 = min(objectives, key=lambda x: x[1])\n        candidates = [i for i, obj in enumerate(objectives)\n                     if obj != best_obj1 and obj != best_obj2]\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search strategy\n    # Step 1: Segment reversal with objective-aware selection\n    segment_length = random.randint(2, min(5, n//3))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Evaluate segment reversal in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]]\n                        for i in range(segment_length))\n    reversed_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]]\n                         for i in range(segment_length-1))\n    if reversed_cost1 < original_cost1:\n        new_solution[start_pos:start_pos+segment_length] = np.flip(segment)\n\n    # Step 2: Node reinsertion with objective-aware placement\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position considering both objectives\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                distance_matrix_1[node, new_solution[pos]] -\n                distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n        cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                distance_matrix_2[node, new_solution[pos]] -\n                distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            # Swap nodes if it improves both objectives\n            node_new = new_solution[p]\n            node_base = base_solution[p]\n            cost1_new = (distance_matrix_1[new_solution[p-1], node_base] +\n                        distance_matrix_1[node_base, new_solution[(p+1)%n]] -\n                        distance_matrix_1[new_solution[p-1], new_solution[(p+1)%n]])\n            cost2_new = (distance_matrix_2[new_solution[p-1], node_base] +\n                        distance_matrix_2[node_base, new_solution[(p+1)%n]] -\n                        distance_matrix_2[new_solution[p-1], new_solution[(p+1)%n]])\n            if cost1_new < 0 and cost2_new < 0:\n                new_solution[p] = node_base\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a hybrid local search combining segment reversal, node reinsertion, and adaptive path relinking to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine segment reversal, node reinsertion, and adaptive path relinking\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    new_solution[start_pos:start_pos+segment_length] = np.flip(new_solution[start_pos:start_pos+segment_length])\n\n    # Step 2: Node reinsertion with cost-based selection\n    candidates = random.sample(range(n), min(3, n))\n    for node_pos in sorted(candidates, reverse=True):\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Adaptive path relinking (partial swap based on distance improvement)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(8, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.7:  # Higher probability for swaps\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8215662510105435,
            0.2265651822090149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine segment reversal, node reinsertion, and adaptive path relinking\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    new_solution[start_pos:start_pos+segment_length] = np.flip(new_solution[start_pos:start_pos+segment_length])\n\n    # Step 2: Node reinsertion with cost-based selection\n    candidates = random.sample(range(n), min(3, n))\n    for node_pos in sorted(candidates, reverse=True):\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Adaptive path relinking (partial swap based on distance improvement)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(8, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.7:  # Higher probability for swaps\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining a probabilistic edge swap and a partial tour reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_scores = [sum(obj) for _, obj in archive]\n    best_idx = np.argmax(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Probabilistic edge swap\n        p = 0.7  # Probability of performing swap\n        if random.random() < p:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Partial tour reversal\n        k = random.randint(2, min(5, n-1))  # Segment size\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.873365722268779,
            0.21865272521972656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_scores = [sum(obj) for _, obj in archive]\n    best_idx = np.argmax(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Probabilistic edge swap\n        p = 0.7  # Probability of performing swap\n        if random.random() < p:\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Partial tour reversal\n        k = random.randint(2, min(5, n-1))  # Segment size\n        start = random.randint(0, n - k)\n        new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized combination of objective values, then applies a hybrid local search combining a randomized edge swap with a segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomly select two distinct edges and swap them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n        new_solution[j], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[j]\n\n        # Randomly invert a segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) == n:\n        return new_solution\n    else:\n        # If infeasible, revert to base solution\n        return base_solution\n\n",
        "score": [
            -0.840245579625526,
            0.25705355405807495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomly select two distinct edges and swap them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n        new_solution[j], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[j]\n\n        # Randomly invert a segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) == n:\n        return new_solution\n    else:\n        # If infeasible, revert to base solution\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The new algorithm selects a solution from the archive based on the most crowded region in the objective space, then applies a novel local search operator combining segment reversal with a guided insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the most crowded region in objective space\n    objectives = [obj for (sol, obj) in archive]\n    if len(objectives) > 1:\n        # Find the most crowded region (simplified by selecting the median)\n        objectives_sorted = sorted(objectives)\n        median_obj = objectives_sorted[len(objectives_sorted)//2]\n        selected_idx = [i for i, obj in enumerate(objectives) if obj == median_obj][0]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with guided insertion\n    if n > 3:\n        # Select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        reversed_segment = np.flip(segment)\n\n        # Insert the reversed segment at a guided position\n        # Guided by the objective improvement potential\n        obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n        obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n        # Try inserting at different positions and select the one with best improvement\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n - len(reversed_segment) + 1):\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                reversed_segment,\n                new_solution[pos + len(reversed_segment):]\n            ])\n            temp_obj1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            temp_obj2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            improvement = (obj1 - temp_obj1) + (obj2 - temp_obj2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            reversed_segment,\n            new_solution[best_pos + len(reversed_segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9621612308731147,
            0.46748799085617065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the most crowded region in objective space\n    objectives = [obj for (sol, obj) in archive]\n    if len(objectives) > 1:\n        # Find the most crowded region (simplified by selecting the median)\n        objectives_sorted = sorted(objectives)\n        median_obj = objectives_sorted[len(objectives_sorted)//2]\n        selected_idx = [i for i, obj in enumerate(objectives) if obj == median_obj][0]\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with guided insertion\n    if n > 3:\n        # Select a segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        reversed_segment = np.flip(segment)\n\n        # Insert the reversed segment at a guided position\n        # Guided by the objective improvement potential\n        obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n        obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n        # Try inserting at different positions and select the one with best improvement\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n - len(reversed_segment) + 1):\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                reversed_segment,\n                new_solution[pos + len(reversed_segment):]\n            ])\n            temp_obj1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            temp_obj2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n))\n            improvement = (obj1 - temp_obj1) + (obj2 - temp_obj2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            reversed_segment,\n            new_solution[best_pos + len(reversed_segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining node relocations, segment rotations, and probabilistic edge flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (low similarity to others)\n    def similarity(sol1, sol2):\n        matches = sum(1 for a, b in zip(sol1, sol2) if a == b)\n        return matches / len(sol1)\n\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, _) in enumerate(archive):\n        avg_similarity = sum(similarity(sol, other_sol) for j, (other_sol, _) in enumerate(archive) if i != j) / (len(archive) - 1)\n        diversity = 1 - avg_similarity\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search combining node relocations, segment rotations, and probabilistic edge flips\n    if n > 4:\n        # Node relocation: move a random node to a new position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Segment rotation: rotate a random segment by a random amount\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n - seg_start - 1))\n        seg_end = seg_start + seg_length\n        rotation = random.randint(1, seg_length - 1)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n        # Probabilistic edge flips: flip edges with a certain probability\n        for i in range(n-1):\n            if random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.6874125382030924,
            2.928176999092102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (low similarity to others)\n    def similarity(sol1, sol2):\n        matches = sum(1 for a, b in zip(sol1, sol2) if a == b)\n        return matches / len(sol1)\n\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, _) in enumerate(archive):\n        avg_similarity = sum(similarity(sol, other_sol) for j, (other_sol, _) in enumerate(archive) if i != j) / (len(archive) - 1)\n        diversity = 1 - avg_similarity\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search combining node relocations, segment rotations, and probabilistic edge flips\n    if n > 4:\n        # Node relocation: move a random node to a new position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Segment rotation: rotate a random segment by a random amount\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n - seg_start - 1))\n        seg_end = seg_start + seg_length\n        rotation = random.randint(1, seg_length - 1)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n        # Probabilistic edge flips: flip edges with a certain probability\n        for i in range(n-1):\n            if random.random() < 0.2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment insertion and random segment shuffling to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.exp(objectives * weights)\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Insert segment and shuffle\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n    # Option 2: Random segment swap with insertion\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        np.random.shuffle(new_solution[a:b+1])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure metrics, then applies a hybrid local search combining node sequence reversal and adaptive segment transposition to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9360222566253205,
            0.11905956268310547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values, then applies a hybrid local search combining partial reversal, node relocation, and adaptive path relinking to generate a neighbor solution while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Partial reversal with adaptive segment size\n    segment_size = min(10, n // 3)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Step 2: Node relocation with distance-based probability\n    for i in range(n):\n        if random.random() < 0.3:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Adaptive path relinking with objective awareness\n    for i in range(n):\n        if random.random() < 0.2:\n            # Swap with node from same objective space\n            obj_space = random.randint(0, 1)\n            candidate_nodes = [j for j in range(n) if j != i and instance[new_solution[j]][obj_space*2] == instance[new_solution[i]][obj_space*2]]\n            if candidate_nodes:\n                j = random.choice(candidate_nodes)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7618211782760076,
            0.35858285427093506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Partial reversal with adaptive segment size\n    segment_size = min(10, n // 3)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Step 2: Node relocation with distance-based probability\n    for i in range(n):\n        if random.random() < 0.3:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Adaptive path relinking with objective awareness\n    for i in range(n):\n        if random.random() < 0.2:\n            # Swap with node from same objective space\n            obj_space = random.randint(0, 1)\n            candidate_nodes = [j for j in range(n) if j != i and instance[new_solution[j]][obj_space*2] == instance[new_solution[i]][obj_space*2]]\n            if candidate_nodes:\n                j = random.choice(candidate_nodes)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9849316061852513,
            2.2882574796676636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation, selective edge flipping, and adaptive path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation, selective edge flipping, and adaptive path relinking\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n        # Adaptive path relinking\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(5, n//2))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if random.random() < 0.3:\n                new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9158429527429205,
            0.47701776027679443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation, selective edge flipping, and adaptive path relinking\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n        # Adaptive path relinking\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(5, n//2))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if random.random() < 0.3:\n                new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining edge swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping and segment reversal\n    if n > 3:\n        # Step 1: Edge swapping (swap two random edges)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Segment reversal (reverse a random segment)\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of normalized objective values, then applies a hybrid local search combining edge swapping and segment reversal with adaptive segment sizes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    weighted_solutions = []\n    for i, (sol, obj) in enumerate(archive):\n        norm1 = (obj[0] - min1) / (max1 - min1 + 1e-8) if max1 > min1 else 0.5\n        norm2 = (obj[1] - min2) / (max2 - min2 + 1e-8) if max2 > min2 else 0.5\n        weight = 0.3 * norm1 + 0.7 * norm2 + 0.2 * (norm1 * norm2)\n        weighted_solutions.append((weight, i))\n\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = archive[weighted_solutions[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive edge swapping\n        k = min(3, n // 4)\n        indices = sorted(random.sample(range(1, n-1), k))\n        for i in range(0, len(indices), 2):\n            if i+1 < len(indices):\n                new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Adaptive segment reversal\n        seg_size = max(2, n // 5)\n        a = random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7577666334715452,
            0.2821187376976013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    min1, max1 = min(obj1), max(obj1)\n    min2, max2 = min(obj2), max(obj2)\n\n    weighted_solutions = []\n    for i, (sol, obj) in enumerate(archive):\n        norm1 = (obj[0] - min1) / (max1 - min1 + 1e-8) if max1 > min1 else 0.5\n        norm2 = (obj[1] - min2) / (max2 - min2 + 1e-8) if max2 > min2 else 0.5\n        weight = 0.3 * norm1 + 0.7 * norm2 + 0.2 * (norm1 * norm2)\n        weighted_solutions.append((weight, i))\n\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = archive[weighted_solutions[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive edge swapping\n        k = min(3, n // 4)\n        indices = sorted(random.sample(range(1, n-1), k))\n        for i in range(0, len(indices), 2):\n            if i+1 < len(indices):\n                new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Adaptive segment reversal\n        seg_size = max(2, n // 5)\n        a = random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(10, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.5:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and structural entropy, then applies a hybrid local search combining adaptive segment inversion and distance-aware node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective balance and structural entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n\n    # Calculate structural entropy (simplified)\n    entropy_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        entropy_scores.append(len(unique_pairs) / len(sol))\n\n    combined_scores = 0.7 * balance_scores + 0.3 * np.array(entropy_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and distance-aware swapping\n    if n > 4:\n        # Adaptive segment inversion\n        segment_size = max(2, min(10, n // 4))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n        # Distance-aware node swapping\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n                dist1 += distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                dist2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                dist2 += distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n\n                if dist1 < dist2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9052315624271001,
            0.3728877902030945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective balance and structural entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n\n    # Calculate structural entropy (simplified)\n    entropy_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        entropy_scores.append(len(unique_pairs) / len(sol))\n\n    combined_scores = 0.7 * balance_scores + 0.3 * np.array(entropy_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and distance-aware swapping\n    if n > 4:\n        # Adaptive segment inversion\n        segment_size = max(2, min(10, n // 4))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n        # Distance-aware node swapping\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n                dist1 += distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                dist2 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                dist2 += distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n\n                if dist1 < dist2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a novel edge exchange with a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = [0.0] * len(archive)\n\n    for i in range(2):\n        if len(archive) <= 2:\n            continue\n        sorted_archive.sort(key=lambda x: x[1][i])\n        distances[0] = float('inf')\n        distances[-1] = float('inf')\n        for j in range(1, len(archive)-1):\n            if sorted_archive[-1][1][i] == sorted_archive[0][1][i]:\n                continue\n            distances[j] += (sorted_archive[j+1][1][i] - sorted_archive[j-1][1][i]) / (sorted_archive[-1][1][i] - sorted_archive[0][1][i])\n\n    # Select solution with highest crowding distance (most in need of improvement)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Novel edge exchange: select three random nodes and create a new path segment\n        a, b, c = random.sample(range(n), 3)\n        if a > b:\n            a, b = b, a\n        if b > c:\n            b, c = c, b\n        if a > b:\n            a, b = b, a\n\n        # Create new segment by inserting c between a and b\n        segment = new_solution[a:b+1].tolist()\n        segment.insert(random.randint(1, len(segment)-1), new_solution[c])\n        new_solution[a:b+1] = segment[:len(new_solution[a:b+1])]\n\n        # Probabilistic segment reversal: reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9368498486408576,
            0.5208574533462524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    distances = [0.0] * len(archive)\n\n    for i in range(2):\n        if len(archive) <= 2:\n            continue\n        sorted_archive.sort(key=lambda x: x[1][i])\n        distances[0] = float('inf')\n        distances[-1] = float('inf')\n        for j in range(1, len(archive)-1):\n            if sorted_archive[-1][1][i] == sorted_archive[0][1][i]:\n                continue\n            distances[j] += (sorted_archive[j+1][1][i] - sorted_archive[j-1][1][i]) / (sorted_archive[-1][1][i] - sorted_archive[0][1][i])\n\n    # Select solution with highest crowding distance (most in need of improvement)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Novel edge exchange: select three random nodes and create a new path segment\n        a, b, c = random.sample(range(n), 3)\n        if a > b:\n            a, b = b, a\n        if b > c:\n            b, c = c, b\n        if a > b:\n            a, b = b, a\n\n        # Create new segment by inserting c between a and b\n        segment = new_solution[a:b+1].tolist()\n        segment.insert(random.randint(1, len(segment)-1), new_solution[c])\n        new_solution[a:b+1] = segment[:len(new_solution[a:b+1])]\n\n        # Probabilistic segment reversal: reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{The new algorithm selects a solution from the archive based on a rank-based selection combined with objective normalization, then applies a hybrid local search combining segment rotation and adaptive swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection with objective normalization\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    rank_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(rank_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three points\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Option 1: Rotate segments and swap\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Adaptive swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        if np.random.rand() < 0.3:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], new_solution[c+1:]])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.6012361696286874,
            0.1624608039855957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank-based selection with objective normalization\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    rank_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(rank_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three points\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Option 1: Rotate segments and swap\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Adaptive swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        if np.random.rand() < 0.3:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], new_solution[c+1:]])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps with adaptive segment lengths to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted objective score with adaptive weights\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / np.max(objectives, axis=0)\n    weights = np.array([0.5, 0.5]) * (1 + np.random.rand(2) * 0.2)  # Randomized weights\n    weighted_scores = norm_objectives * weights\n    combined_scores = np.sum(weighted_scores, axis=1)  # Sum instead of Euclidean distance\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with adaptive segment lengths\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments with adaptive lengths\n    segment_length = max(2, int(np.random.normal(loc=n/4, scale=n/8)))\n    a = np.random.randint(0, n - segment_length)\n    b = a + segment_length\n    c = np.random.randint(b, n)\n\n    # Option 1: Reverse segments and swap with adaptive probabilities\n    if np.random.rand() < 0.6:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a], new_solution[c-1] = new_solution[c-1], new_solution[a]\n    # Option 2: Random swap of segments with adaptive lengths\n    else:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8076402254756427,
            0.30591583251953125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic weighted objective score with adaptive weights\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / np.max(objectives, axis=0)\n    weights = np.array([0.5, 0.5]) * (1 + np.random.rand(2) * 0.2)  # Randomized weights\n    weighted_scores = norm_objectives * weights\n    combined_scores = np.sum(weighted_scores, axis=1)  # Sum instead of Euclidean distance\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with adaptive segment lengths\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments with adaptive lengths\n    segment_length = max(2, int(np.random.normal(loc=n/4, scale=n/8)))\n    a = np.random.randint(0, n - segment_length)\n    b = a + segment_length\n    c = np.random.randint(b, n)\n\n    # Option 1: Reverse segments and swap with adaptive probabilities\n    if np.random.rand() < 0.6:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a], new_solution[c-1] = new_solution[c-1], new_solution[a]\n    # Option 2: Random swap of segments with adaptive lengths\n    else:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and spatial diversity, then applies a hybrid local search combining adaptive segment rearrangement and probabilistic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=0) - objectives\n    spatial_diversity = np.array([np.std(instance[sol, :2], axis=0).mean() for sol, _ in archive])\n    combined_scores = 0.6 * improvement_potential[:,0] + 0.4 * improvement_potential[:,1] + 0.3 * spatial_diversity\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rearrangement and probabilistic edge reversal\n    if n > 5:\n        # Adaptive segment rearrangement\n        k = random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic edge reversal\n        for i in range(1, n-1):\n            if random.random() < 0.2:  # 20% chance to reverse edge\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9038321017138672,
            0.6558732390403748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=0) - objectives\n    spatial_diversity = np.array([np.std(instance[sol, :2], axis=0).mean() for sol, _ in archive])\n    combined_scores = 0.6 * improvement_potential[:,0] + 0.4 * improvement_potential[:,1] + 0.3 * spatial_diversity\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rearrangement and probabilistic edge reversal\n    if n > 5:\n        # Adaptive segment rearrangement\n        k = random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic edge reversal\n        for i in range(1, n-1):\n            if random.random() < 0.2:  # 20% chance to reverse edge\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and spatial clustering, then applies a hybrid local search combining multi-segment reversal and targeted node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and spatial clustering\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n\n    # Cluster solutions based on spatial similarity\n    coords = instance[:, :2]  # Using first objective space coordinates\n    centroids = np.array([np.mean(coords[sol], axis=0) for sol, _ in archive])\n    pairwise_dist = np.linalg.norm(centroids[:, None] - centroids[None, :], axis=2)\n    cluster_scores = np.sum(pairwise_dist < np.median(pairwise_dist), axis=1)\n    combined_scores = scores * cluster_scores\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment reversal and targeted insertion\n    if n > 4:\n        # Multi-segment reversal\n        segments = sorted(random.sample(range(1, n-1), 2))\n        a, b = segments\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n        # Targeted node insertion\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9685302494427104,
            1.8942465782165527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and spatial clustering\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n\n    # Cluster solutions based on spatial similarity\n    coords = instance[:, :2]  # Using first objective space coordinates\n    centroids = np.array([np.mean(coords[sol], axis=0) for sol, _ in archive])\n    pairwise_dist = np.linalg.norm(centroids[:, None] - centroids[None, :], axis=2)\n    cluster_scores = np.sum(pairwise_dist < np.median(pairwise_dist), axis=1)\n    combined_scores = scores * cluster_scores\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment reversal and targeted insertion\n    if n > 4:\n        # Multi-segment reversal\n        segments = sorted(random.sample(range(1, n-1), 2))\n        a, b = segments\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n        # Targeted node insertion\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel scoring function that combines objective values and diversity, then applies a hybrid local search combining 3-opt moves, node repositioning, and adaptive path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on normalized objectives and diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = [len(np.unique(sol)) / len(sol) for sol, _ in archive]\n    scores = np.sum(normalized_obj, axis=1) * np.array(diversity_scores)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Adaptive node repositioning\n    for _ in range(2):\n        node_idx = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Adaptive path relinking\n    relink_length = random.randint(1, max(3, n//4))\n    for _ in range(relink_length):\n        if random.random() < 0.4:\n            pos1, pos2 = random.sample(range(n), 2)\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.755136076582896,
            0.5180873870849609
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on normalized objectives and diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = [len(np.unique(sol)) / len(sol) for sol, _ in archive]\n    scores = np.sum(normalized_obj, axis=1) * np.array(diversity_scores)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Adaptive node repositioning\n    for _ in range(2):\n        node_idx = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Adaptive path relinking\n    relink_length = random.randint(1, max(3, n//4))\n    for _ in range(relink_length):\n        if random.random() < 0.4:\n            pos1, pos2 = random.sample(range(n), 2)\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure entropy, then applies a hybrid local search combining adaptive segment crossover and probabilistic edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate entropy for each solution\n    entropies = []\n    for sol in solutions:\n        # Calculate edge direction changes to estimate entropy\n        changes = 0\n        for i in range(n-1):\n            if (sol[i+1] - sol[i]) * (sol[(i+2)%n] - sol[i+1]) < 0:\n                changes += 1\n        entropies.append(changes)\n\n    # Normalize objectives and entropies\n    norm_obj1 = (objectives[:, 0] - np.min(objectives[:, 0])) / (np.max(objectives[:, 0]) - np.min(objectives[:, 0]) + 1e-6)\n    norm_obj2 = (objectives[:, 1] - np.min(objectives[:, 1])) / (np.max(objectives[:, 1]) - np.min(objectives[:, 1]) + 1e-6)\n    norm_entropy = (np.array(entropies) - np.min(entropies)) / (np.max(entropies) - np.min(entropies) + 1e-6)\n\n    # Combined score: higher weight for entropy to encourage exploration\n    scores = 0.3 * norm_obj1 + 0.3 * norm_obj2 + 0.4 * norm_entropy\n    selected_idx = np.argmin(scores)  # Select solution with lowest score (best potential)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    if n > 5:\n        # Adaptive segment crossover\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n        # Probabilistic edge inversion\n        for i in range(n-1):\n            if random.random() < 0.15:  # 15% chance per edge\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9005853865858067,
            0.4098854660987854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate entropy for each solution\n    entropies = []\n    for sol in solutions:\n        # Calculate edge direction changes to estimate entropy\n        changes = 0\n        for i in range(n-1):\n            if (sol[i+1] - sol[i]) * (sol[(i+2)%n] - sol[i+1]) < 0:\n                changes += 1\n        entropies.append(changes)\n\n    # Normalize objectives and entropies\n    norm_obj1 = (objectives[:, 0] - np.min(objectives[:, 0])) / (np.max(objectives[:, 0]) - np.min(objectives[:, 0]) + 1e-6)\n    norm_obj2 = (objectives[:, 1] - np.min(objectives[:, 1])) / (np.max(objectives[:, 1]) - np.min(objectives[:, 1]) + 1e-6)\n    norm_entropy = (np.array(entropies) - np.min(entropies)) / (np.max(entropies) - np.min(entropies) + 1e-6)\n\n    # Combined score: higher weight for entropy to encourage exploration\n    scores = 0.3 * norm_obj1 + 0.3 * norm_obj2 + 0.4 * norm_entropy\n    selected_idx = np.argmin(scores)  # Select solution with lowest score (best potential)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    if n > 5:\n        # Adaptive segment crossover\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n        # Probabilistic edge inversion\n        for i in range(n-1):\n            if random.random() < 0.15:  # 15% chance per edge\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure metrics, then applies a hybrid local search combining node sequence reversal and adaptive segment transposition to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and spatial proximity, then applies a hybrid local search combining adaptive node insertion and multi-objective segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Calculate spatial proximity to instance centroid\n    centroid = np.mean(instance, axis=0)\n    centroid_distances = []\n    for sol, _ in archive:\n        sol_coords = instance[sol]\n        avg_dist = np.mean(np.linalg.norm(sol_coords[:, :2] - centroid[:2], axis=1))\n        centroid_distances.append(avg_dist)\n\n    # Combine selection criteria\n    selection_scores = []\n    for i in range(len(archive)):\n        score = 0.6 * (1 if i in pareto_front else 0) - 0.4 * centroid_distances[i]\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node insertion and multi-objective segment rotation\n    if n > 4:\n        # Adaptive node insertion\n        insert_pos = random.randint(0, n-1)\n        node_to_move = new_solution[random.randint(0, n-1)]\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [node_to_move],\n            new_solution[insert_pos:]\n        ])\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n        # Multi-objective segment rotation\n        segment_length = min(4, n // 3)\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1]][segment[i]] for i in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1]][segment[i]] for i in range(segment_length))\n\n        # Rotate segment based on objective balance\n        if segment_cost1 > segment_cost2:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        new_solution[start:start+segment_length] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7994703407290257,
            0.7030230164527893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    # Calculate spatial proximity to instance centroid\n    centroid = np.mean(instance, axis=0)\n    centroid_distances = []\n    for sol, _ in archive:\n        sol_coords = instance[sol]\n        avg_dist = np.mean(np.linalg.norm(sol_coords[:, :2] - centroid[:2], axis=1))\n        centroid_distances.append(avg_dist)\n\n    # Combine selection criteria\n    selection_scores = []\n    for i in range(len(archive)):\n        score = 0.6 * (1 if i in pareto_front else 0) - 0.4 * centroid_distances[i]\n        selection_scores.append(score)\n\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node insertion and multi-objective segment rotation\n    if n > 4:\n        # Adaptive node insertion\n        insert_pos = random.randint(0, n-1)\n        node_to_move = new_solution[random.randint(0, n-1)]\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [node_to_move],\n            new_solution[insert_pos:]\n        ])\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n        # Multi-objective segment rotation\n        segment_length = min(4, n // 3)\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1]][segment[i]] for i in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1]][segment[i]] for i in range(segment_length))\n\n        # Rotate segment based on objective balance\n        if segment_cost1 > segment_cost2:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        new_solution[start:start+segment_length] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and structural novelty, then applies a hybrid local search combining adaptive segment shuffling and targeted edge replacements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and structural novelty\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment shuffling and targeted edge replacements\n    if n > 4:\n        # Adaptive segment shuffling\n        segment_size = max(2, n // 4)\n        num_segments = n // segment_size\n        segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Targeted edge replacements based on distance matrices\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]]) < \\\n               (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7883895851776822,
            0.2754982113838196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and structural novelty\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment shuffling and targeted edge replacements\n    if n > 4:\n        # Adaptive segment shuffling\n        segment_size = max(2, n // 4)\n        num_segments = n // segment_size\n        segments = [new_solution[i*segment_size:(i+1)*segment_size] for i in range(num_segments)]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Targeted edge replacements based on distance matrices\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]]) < \\\n               (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel local search strategy that combines segment reversals, node relocations, and guided path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_size = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_size)\n    new_solution[start_pos:start_pos+segment_size] = np.flip(new_solution[start_pos:start_pos+segment_size])\n\n    # Step 2: Guided node relocation\n    for _ in range(2):\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Guided path relinking\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(4, n//3))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8956641875562119,
            0.17883163690567017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with guided selection\n    segment_size = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_size)\n    new_solution[start_pos:start_pos+segment_size] = np.flip(new_solution[start_pos:start_pos+segment_size])\n\n    # Step 2: Guided node relocation\n    for _ in range(2):\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Guided path relinking\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(4, n//3))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.4:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure metrics, then applies a hybrid local search combining node sequence reversal and adaptive segment transposition to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour entropy, then applies a hybrid local search combining adaptive segment rotation and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and tour entropy\n    objectives = np.array([obj for _, obj in archive])\n    dominated_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                dominated_counts[i] += 1\n\n    entropy_scores = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-6) / len(sol))\n        entropy_scores.append(entropy)\n\n    combined_scores = dominated_counts + np.array(entropy_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and probabilistic edge swapping\n    if n > 4:\n        # Adaptive segment rotation\n        segment_length = min(4, n // 3)\n        start = random.randint(0, n - segment_length)\n        rotation = random.randint(1, segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Probabilistic edge swapping\n        for i in range(n):\n            if random.random() < 0.3:\n                j = random.randint(0, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8015207980162095,
            0.5550267696380615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and tour entropy\n    objectives = np.array([obj for _, obj in archive])\n    dominated_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                dominated_counts[i] += 1\n\n    entropy_scores = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-6) / len(sol))\n        entropy_scores.append(entropy)\n\n    combined_scores = dominated_counts + np.array(entropy_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and probabilistic edge swapping\n    if n > 4:\n        # Adaptive segment rotation\n        segment_length = min(4, n // 3)\n        start = random.randint(0, n - segment_length)\n        rotation = random.randint(1, segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Probabilistic edge swapping\n        for i in range(n):\n            if random.random() < 0.3:\n                j = random.randint(0, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance metric, then applies a hybrid local search combining edge reinsertion and a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    n = len(sorted_archive)\n    crowding = [0.0] * n\n\n    for m in range(2):  # For each objective\n        sorted_archive.sort(key=lambda x: x[1][m])\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, n-1):\n            crowding[i] += (sorted_archive[i+1][1][m] - sorted_archive[i-1][1][m]) / (sorted_archive[-1][1][m] - sorted_archive[0][1][m] + 1e-6)\n\n    # Select solution with highest crowding distance\n    base_solution = max(zip(crowding, archive), key=lambda x: x[0])[1][0].copy()\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 4:\n        # Edge reinsertion: remove a random edge and reinsert it elsewhere\n        i = random.randint(0, n_nodes-2)\n        node1, node2 = new_solution[i], new_solution[i+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+2:]])\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, [node1, node2])\n\n        # Probabilistic segment reversal: reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n_nodes), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8664711430559477,
            0.2986895442008972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    n = len(sorted_archive)\n    crowding = [0.0] * n\n\n    for m in range(2):  # For each objective\n        sorted_archive.sort(key=lambda x: x[1][m])\n        crowding[0] = crowding[-1] = float('inf')\n        for i in range(1, n-1):\n            crowding[i] += (sorted_archive[i+1][1][m] - sorted_archive[i-1][1][m]) / (sorted_archive[-1][1][m] - sorted_archive[0][1][m] + 1e-6)\n\n    # Select solution with highest crowding distance\n    base_solution = max(zip(crowding, archive), key=lambda x: x[0])[1][0].copy()\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    if n_nodes > 4:\n        # Edge reinsertion: remove a random edge and reinsert it elsewhere\n        i = random.randint(0, n_nodes-2)\n        node1, node2 = new_solution[i], new_solution[i+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+2:]])\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, [node1, node2])\n\n        # Probabilistic segment reversal: reverse a segment with probability 0.3\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n_nodes), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n_nodes:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining edge exchange with a randomized node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol_i, obj_i))\n\n    # Select a random non-dominated solution\n    if non_dominated:\n        base_solution, _ = random.choice(non_dominated)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Perform edge exchange\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n        # Randomly swap two nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.914906727117892,
            0.22474104166030884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol_i, obj_i))\n\n    # Select a random non-dominated solution\n    if non_dominated:\n        base_solution, _ = random.choice(non_dominated)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly select two edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Perform edge exchange\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n        # Randomly swap two nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure metrics, then applies a hybrid local search combining node sequence reversal and adaptive segment transposition to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure metrics, then applies a hybrid local search combining adaptive node swapping and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective values and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for each objective\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment rotation\n    if n > 3:\n        # Adaptive node swapping\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation\n        segment_length = min(4, n // 3)\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9244995356397611,
            0.238328754901886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective values and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for each objective\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node swapping and segment rotation\n    if n > 3:\n        # Adaptive node swapping\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment rotation\n        segment_length = min(4, n // 3)\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid of objective dominance and solution diversity, then applies a combination of partial tour reversal and adaptive edge insertion to generate a neighbor while ensuring feasibility through node validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial tour reversal and adaptive edge insertion\n    if n > 3:\n        # Partial tour reversal\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive edge insertion\n        insert_prob = min(0.3, 0.2 * (1 - objectives[selected_idx][0] / (objectives[:,0].max() + 1e-8)))\n        if random.random() < insert_prob and n > 4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8833017515733818,
            5.09101676940918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: partial tour reversal and adaptive edge insertion\n    if n > 3:\n        # Partial tour reversal\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive edge insertion\n        insert_prob = min(0.3, 0.2 * (1 - objectives[selected_idx][0] / (objectives[:,0].max() + 1e-8)))\n        if random.random() < insert_prob and n > 4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a novel multi-segment crossover and dynamic edge insertion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n    objectives_sorted1 = sorted(objectives, key=lambda x: x[0])\n    objectives_sorted2 = sorted(objectives, key=lambda x: x[1])\n\n    for i, (obj1, obj2) in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = objectives_sorted1[i+1][0] - objectives_sorted1[i-1][0]\n            dist2 = objectives_sorted2[i+1][1] - objectives_sorted2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solution with minimum crowding distance (most isolated)\n    min_crowding_idx = np.argmin(crowding_distances)\n    base_solution = archive[min_crowding_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment crossover: select 2-3 random segments and rearrange them\n        num_segments = random.randint(2, 3)\n        segments = []\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        # Sort segments by start index\n        segments.sort()\n\n        # Create new solution by concatenating segments in order\n        temp_solution = []\n        prev_end = 0\n        for start, end in segments:\n            temp_solution.extend(new_solution[start:end])\n            prev_end = end\n\n        # Add remaining nodes\n        remaining_nodes = [node for node in new_solution if node not in temp_solution]\n        temp_solution.extend(remaining_nodes)\n\n        new_solution = np.array(temp_solution)\n\n        # Dynamic edge insertion: randomly select a node and insert it in a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_move]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7341443863727273,
            0.14887773990631104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n    objectives_sorted1 = sorted(objectives, key=lambda x: x[0])\n    objectives_sorted2 = sorted(objectives, key=lambda x: x[1])\n\n    for i, (obj1, obj2) in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = objectives_sorted1[i+1][0] - objectives_sorted1[i-1][0]\n            dist2 = objectives_sorted2[i+1][1] - objectives_sorted2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solution with minimum crowding distance (most isolated)\n    min_crowding_idx = np.argmin(crowding_distances)\n    base_solution = archive[min_crowding_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment crossover: select 2-3 random segments and rearrange them\n        num_segments = random.randint(2, 3)\n        segments = []\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        # Sort segments by start index\n        segments.sort()\n\n        # Create new solution by concatenating segments in order\n        temp_solution = []\n        prev_end = 0\n        for start, end in segments:\n            temp_solution.extend(new_solution[start:end])\n            prev_end = end\n\n        # Add remaining nodes\n        remaining_nodes = [node for node in new_solution if node not in temp_solution]\n        temp_solution.extend(remaining_nodes)\n\n        new_solution = np.array(temp_solution)\n\n        # Dynamic edge insertion: randomly select a node and insert it in a new position\n        node_to_move = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_move]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance measure to identify non-dominated solutions, then applies a novel local search combining segment reversal with a probabilistic edge exchange to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for i in range(len(archive)):\n        sol_i, obj_i = archive[i]\n        distance = 0\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            sol_j, obj_j = archive[j]\n            distance += abs(obj_i[0] - obj_j[0]) + abs(obj_i[1] - obj_j[1])\n        crowding_distances.append(distance)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with probabilistic edge exchange\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Reverse segment\n        else:\n            # Exchange edges between segment and rest of the tour\n            if len(segment) > 1:\n                exchange_pos = random.randint(0, len(segment)-1)\n                new_solution[a+exchange_pos], new_solution[b] = new_solution[b], new_solution[a+exchange_pos]\n\n        # Insert segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9646556085505865,
            4.047571539878845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for i in range(len(archive)):\n        sol_i, obj_i = archive[i]\n        distance = 0\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            sol_j, obj_j = archive[j]\n            distance += abs(obj_i[0] - obj_j[0]) + abs(obj_i[1] - obj_j[1])\n        crowding_distances.append(distance)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with probabilistic edge exchange\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Reverse segment\n        else:\n            # Exchange edges between segment and rest of the tour\n            if len(segment) > 1:\n                exchange_pos = random.randint(0, len(segment)-1)\n                new_solution[a+exchange_pos], new_solution[b] = new_solution[b], new_solution[a+exchange_pos]\n\n        # Insert segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance, tour structure diversity, and a novel hybrid local search that combines multi-segment rotation with adaptive edge flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance, diversity, and adaptive weighting\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Adaptive selection: prefer solutions with better balance between objectives\n        weights = 1 / (objectives[pareto_front, 0] + objectives[pareto_front, 1])\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(pareto_front, p=weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation with adaptive edge flipping\n    if n > 6:\n        # Multi-segment rotation with dynamic segment selection\n        segments = sorted(random.sample(range(1, n-1), 2))\n        a, b = segments[0], segments[1]\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n\n        # Adaptive edge flipping based on distance improvement\n        flip_pos = random.randint(1, n-2)\n        current_cost = distance_matrix_1[new_solution[flip_pos-1], new_solution[flip_pos]] + distance_matrix_1[new_solution[flip_pos], new_solution[flip_pos+1]] + \\\n                       distance_matrix_2[new_solution[flip_pos-1], new_solution[flip_pos]] + distance_matrix_2[new_solution[flip_pos], new_solution[flip_pos+1]]\n        flipped_cost = distance_matrix_1[new_solution[flip_pos-1], new_solution[flip_pos+1]] + distance_matrix_1[new_solution[flip_pos+1], new_solution[flip_pos]] + \\\n                       distance_matrix_2[new_solution[flip_pos-1], new_solution[flip_pos+1]] + distance_matrix_2[new_solution[flip_pos+1], new_solution[flip_pos]]\n\n        if flipped_cost < current_cost:\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8454733976992332,
            0.5602530241012573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance, diversity, and adaptive weighting\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Adaptive selection: prefer solutions with better balance between objectives\n        weights = 1 / (objectives[pareto_front, 0] + objectives[pareto_front, 1])\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(pareto_front, p=weights)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation with adaptive edge flipping\n    if n > 6:\n        # Multi-segment rotation with dynamic segment selection\n        segments = sorted(random.sample(range(1, n-1), 2))\n        a, b = segments[0], segments[1]\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n\n        # Adaptive edge flipping based on distance improvement\n        flip_pos = random.randint(1, n-2)\n        current_cost = distance_matrix_1[new_solution[flip_pos-1], new_solution[flip_pos]] + distance_matrix_1[new_solution[flip_pos], new_solution[flip_pos+1]] + \\\n                       distance_matrix_2[new_solution[flip_pos-1], new_solution[flip_pos]] + distance_matrix_2[new_solution[flip_pos], new_solution[flip_pos+1]]\n        flipped_cost = distance_matrix_1[new_solution[flip_pos-1], new_solution[flip_pos+1]] + distance_matrix_1[new_solution[flip_pos+1], new_solution[flip_pos]] + \\\n                       distance_matrix_2[new_solution[flip_pos-1], new_solution[flip_pos+1]] + distance_matrix_2[new_solution[flip_pos+1], new_solution[flip_pos]]\n\n        if flipped_cost < current_cost:\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure metrics, then applies a hybrid local search combining node sequence reversal and adaptive segment transposition to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and tour entropy, then applies a hybrid local search combining adaptive k-opt moves and dynamic segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective values and tour entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    weights = np.array([0.6, 0.4])  # Weight for objective 1 and 2\n    weighted_scores = np.dot(normalized_objectives, weights)\n\n    # Calculate tour entropy\n    entropy_scores = []\n    for sol, _ in archive:\n        transitions = np.diff(sol)\n        _, counts = np.unique(transitions, return_counts=True)\n        probs = counts / len(transitions)\n        entropy = -np.sum(probs * np.log(probs + 1e-10))\n        entropy_scores.append(entropy)\n    entropy_scores = np.array(entropy_scores)\n\n    # Combine scores\n    combined_scores = 0.7 * weighted_scores + 0.3 * entropy_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive k-opt and dynamic segment insertion\n    if n > 4:\n        k = min(4, n // 3)\n        indices = sorted(random.sample(range(n), k))\n        segment = new_solution[indices[0]:indices[-1]+1]\n        segment_reversed = segment[::-1]\n        new_solution[indices[0]:indices[-1]+1] = segment_reversed\n\n        segment_length = min(5, n // 5)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9498168670640508,
            2.5929448008537292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective values and tour entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    weights = np.array([0.6, 0.4])  # Weight for objective 1 and 2\n    weighted_scores = np.dot(normalized_objectives, weights)\n\n    # Calculate tour entropy\n    entropy_scores = []\n    for sol, _ in archive:\n        transitions = np.diff(sol)\n        _, counts = np.unique(transitions, return_counts=True)\n        probs = counts / len(transitions)\n        entropy = -np.sum(probs * np.log(probs + 1e-10))\n        entropy_scores.append(entropy)\n    entropy_scores = np.array(entropy_scores)\n\n    # Combine scores\n    combined_scores = 0.7 * weighted_scores + 0.3 * entropy_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive k-opt and dynamic segment insertion\n    if n > 4:\n        k = min(4, n // 3)\n        indices = sorted(random.sample(range(n), k))\n        segment = new_solution[indices[0]:indices[-1]+1]\n        segment_reversed = segment[::-1]\n        new_solution[indices[0]:indices[-1]+1] = segment_reversed\n\n        segment_length = min(5, n // 5)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9568732412501941,
            0.10789024829864502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure entropy, then applies a hybrid local search combining adaptive segment permutation and probabilistic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and entropy\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    entropy_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate entropy of the solution's structure\n        pairs = set(zip(sol[:-1], sol[1:]))\n        entropy = len(pairs) / len(sol)\n        # Combine with objective improvement potential\n        score = entropy * (1 - (obj[0] / mean_obj[0] + obj[1] / mean_obj[1]) / 2)\n        entropy_scores.append((score, i))\n\n    entropy_scores.sort(key=lambda x: -x[0])\n    selected_idx = entropy_scores[0][1] if entropy_scores else np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment permutation and probabilistic edge reversal\n    if n > 4:\n        # Adaptive segment permutation\n        k = min(3, n // 4)\n        segments = []\n        for _ in range(k):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append(new_solution[a:b])\n\n        random.shuffle(segments)\n        new_segments = []\n        for seg in segments:\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_segments.append(seg[::-1])\n            else:\n                new_segments.append(seg)\n\n        # Reconstruct solution\n        remaining = [x for x in new_solution if x not in np.concatenate(segments)]\n        new_solution = np.concatenate([np.concatenate(new_segments), remaining])\n\n        # Probabilistic edge reversal\n        for i in range(1, n-1):\n            if random.random() < 0.1:  # 10% chance to reverse\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.814196674536298,
            0.21560847759246826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and entropy\n    objectives = np.array([obj for _, obj in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    entropy_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate entropy of the solution's structure\n        pairs = set(zip(sol[:-1], sol[1:]))\n        entropy = len(pairs) / len(sol)\n        # Combine with objective improvement potential\n        score = entropy * (1 - (obj[0] / mean_obj[0] + obj[1] / mean_obj[1]) / 2)\n        entropy_scores.append((score, i))\n\n    entropy_scores.sort(key=lambda x: -x[0])\n    selected_idx = entropy_scores[0][1] if entropy_scores else np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment permutation and probabilistic edge reversal\n    if n > 4:\n        # Adaptive segment permutation\n        k = min(3, n // 4)\n        segments = []\n        for _ in range(k):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append(new_solution[a:b])\n\n        random.shuffle(segments)\n        new_segments = []\n        for seg in segments:\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_segments.append(seg[::-1])\n            else:\n                new_segments.append(seg)\n\n        # Reconstruct solution\n        remaining = [x for x in new_solution if x not in np.concatenate(segments)]\n        new_solution = np.concatenate([np.concatenate(new_segments), remaining])\n\n        # Probabilistic edge reversal\n        for i in range(1, n-1):\n            if random.random() < 0.1:  # 10% chance to reverse\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure complexity, then applies a hybrid local search combining adaptive segment reversal and node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and complexity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized_obj[:,0]  # Higher for worse solutions (more room for improvement)\n\n    # Calculate tour complexity\n    complexities = []\n    for sol, _ in archive:\n        complexity = 0\n        for i in range(-1, len(sol)-1):\n            complexity += distance_matrix_1[sol[i]][sol[i+1]] + distance_matrix_2[sol[i]][sol[i+1]]\n        complexities.append(complexity)\n    complexities = np.array(complexities)\n    normalized_complexity = (complexities - complexities.min()) / (complexities.max() - complexities.min() + 1e-8)\n\n    combined_scores = 0.6 * improvement_potential + 0.4 * normalized_complexity\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and node insertion\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = max(2, min(5, int(n * 0.2)))\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7814047733237377,
            1.257519245147705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and complexity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized_obj[:,0]  # Higher for worse solutions (more room for improvement)\n\n    # Calculate tour complexity\n    complexities = []\n    for sol, _ in archive:\n        complexity = 0\n        for i in range(-1, len(sol)-1):\n            complexity += distance_matrix_1[sol[i]][sol[i+1]] + distance_matrix_2[sol[i]][sol[i+1]]\n        complexities.append(complexity)\n    complexities = np.array(complexities)\n    normalized_complexity = (complexities - complexities.min()) / (complexities.max() - complexities.min() + 1e-8)\n\n    combined_scores = 0.6 * improvement_potential + 0.4 * normalized_complexity\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and node insertion\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = max(2, min(5, int(n * 0.2)))\n        a = random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values, then applies a novel cross-over mutation operator that combines segments from two randomly selected solutions in the archive while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, _ = random.choice(archive)\n    sol2, _ = random.choice(archive)\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Randomly select a crossover point\n    crossover_point = random.randint(1, n-1)\n\n    # Copy first segment from sol1\n    new_solution[:crossover_point] = sol1[:crossover_point]\n\n    # Fill remaining positions with nodes from sol2 that are not already in the solution\n    remaining_nodes = [node for node in sol2 if node not in new_solution[:crossover_point]]\n    new_solution[crossover_point:] = remaining_nodes[:n-crossover_point]\n\n    # Repair any missing nodes by filling with remaining nodes in order\n    missing_nodes = [node for node in sol1 if node not in new_solution]\n    if missing_nodes:\n        for i in range(n):\n            if new_solution[i] == 0:  # Placeholder for missing nodes\n                new_solution[i] = missing_nodes.pop(0)\n\n    # Ensure all nodes are unique and cover all nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(sol1, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7898280636119661,
            1.790394902229309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sol1, _ = random.choice(archive)\n    sol2, _ = random.choice(archive)\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Randomly select a crossover point\n    crossover_point = random.randint(1, n-1)\n\n    # Copy first segment from sol1\n    new_solution[:crossover_point] = sol1[:crossover_point]\n\n    # Fill remaining positions with nodes from sol2 that are not already in the solution\n    remaining_nodes = [node for node in sol2 if node not in new_solution[:crossover_point]]\n    new_solution[crossover_point:] = remaining_nodes[:n-crossover_point]\n\n    # Repair any missing nodes by filling with remaining nodes in order\n    missing_nodes = [node for node in sol1 if node not in new_solution]\n    if missing_nodes:\n        for i in range(n):\n            if new_solution[i] == 0:  # Placeholder for missing nodes\n                new_solution[i] = missing_nodes.pop(0)\n\n    # Ensure all nodes are unique and cover all nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(sol1, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure innovation, then applies a hybrid local search combining segment inversion and adaptive node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=0) - objectives\n    diversity_scores = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(diversity_scores) if diversity_scores else 0\n\n    if diversity_score > 0:\n        selected_idx = np.argmax(improvement_potential[:, 0] + improvement_potential[:, 1])\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node relocation\n    if n > 4:\n        # Segment inversion with adaptive length\n        inv_length = min(3, n-1)\n        inv_start = random.randint(0, n-inv_length)\n        new_solution[inv_start:inv_start+inv_length] = np.flip(new_solution[inv_start:inv_start+inv_length])\n\n        # Adaptive node relocation based on distance matrices\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8213092955882603,
            2.227929949760437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=0) - objectives\n    diversity_scores = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(diversity_scores) if diversity_scores else 0\n\n    if diversity_score > 0:\n        selected_idx = np.argmax(improvement_potential[:, 0] + improvement_potential[:, 1])\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node relocation\n    if n > 4:\n        # Segment inversion with adaptive length\n        inv_length = min(3, n-1)\n        inv_start = random.randint(0, n-inv_length)\n        new_solution[inv_start:inv_start+inv_length] = np.flip(new_solution[inv_start:inv_start+inv_length])\n\n        # Adaptive node relocation based on distance matrices\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[i]][new_solution[(i+1)%n]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and spatial diversity, then applies a hybrid local search combining directional segment rearrangement and probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select solution with highest potential for improvement\n        improvement_potential = []\n        for idx in pareto_front:\n            sol = archive[idx][0]\n            obj1, obj2 = archive[idx][1]\n            total_dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total_dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n            potential = (obj1 / total_dist1 + obj2 / total_dist2) * (1 - len(np.unique(sol)) / len(sol))\n            improvement_potential.append(potential)\n        selected_idx = pareto_front[np.argmax(improvement_potential)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: directional segment rearrangement and probabilistic edge insertion\n    if n > 5:\n        # Directional segment rearrangement\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Reverse with 50% probability\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n        # Probabilistic edge insertion\n        for _ in range(2):  # Try 2 insertions\n            if random.random() < 0.4:  # 40% chance per insertion\n                i, j = sorted(random.sample(range(n), 2))\n                if j - i > 1:\n                    node = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8343053784003216,
            4.634541749954224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select solution with highest potential for improvement\n        improvement_potential = []\n        for idx in pareto_front:\n            sol = archive[idx][0]\n            obj1, obj2 = archive[idx][1]\n            total_dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total_dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n            potential = (obj1 / total_dist1 + obj2 / total_dist2) * (1 - len(np.unique(sol)) / len(sol))\n            improvement_potential.append(potential)\n        selected_idx = pareto_front[np.argmax(improvement_potential)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: directional segment rearrangement and probabilistic edge insertion\n    if n > 5:\n        # Directional segment rearrangement\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        if random.random() < 0.5:\n            segment = segment[::-1]  # Reverse with 50% probability\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n        # Probabilistic edge insertion\n        for _ in range(2):  # Try 2 insertions\n            if random.random() < 0.4:  # 40% chance per insertion\n                i, j = sorted(random.sample(range(n), 2))\n                if j - i > 1:\n                    node = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion (combining objective diversity and solution quality) and applies a novel local search combining segment reversals, node relocations, and guided edge exchanges to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with high combined objective values or low dominance\n    objectives = [obj for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)),\n                                weights=[(o1 + o2) * (1 + random.random()) for (o1, o2) in objectives],\n                                k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = random.randint(2, min(5, n//3))\n    start_pos = random.randint(0, n - segment_length)\n    end_pos = start_pos + segment_length\n\n    # Evaluate segment reversal impact on both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    temp_solution = new_solution.copy()\n    temp_solution[start_pos:end_pos] = np.flip(temp_solution[start_pos:end_pos])\n    new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n    if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n        new_solution = temp_solution\n\n    # Node relocation with distance-based selection\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find best insertion point considering both distances\n    best_pos = 0\n    min_total_dist = float('inf')\n    for pos in range(n-1):\n        dist1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n        dist2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if dist1 + dist2 < min_total_dist:\n            min_total_dist = dist1 + dist2\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Guided edge exchange based on objective improvement\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7599235138295567,
            0.6874650716781616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: prioritize solutions with high combined objective values or low dominance\n    objectives = [obj for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)),\n                                weights=[(o1 + o2) * (1 + random.random()) for (o1, o2) in objectives],\n                                k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    segment_length = random.randint(2, min(5, n//3))\n    start_pos = random.randint(0, n - segment_length)\n    end_pos = start_pos + segment_length\n\n    # Evaluate segment reversal impact on both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    temp_solution = new_solution.copy()\n    temp_solution[start_pos:end_pos] = np.flip(temp_solution[start_pos:end_pos])\n    new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n    if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n        new_solution = temp_solution\n\n    # Node relocation with distance-based selection\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find best insertion point considering both distances\n    best_pos = 0\n    min_total_dist = float('inf')\n    for pos in range(n-1):\n        dist1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n        dist2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if dist1 + dist2 < min_total_dist:\n            min_total_dist = dist1 + dist2\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Guided edge exchange based on objective improvement\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear score combining objectives with adaptive weights, then applies a hybrid local search combining segment reversal, random swaps, and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score with adaptive weights\n    objectives = np.array([obj for _, obj in archive])\n    max_vals = np.max(objectives, axis=0)\n    normalized = objectives / max_vals\n    weights = np.array([0.6, 0.4])  # Different weight distribution\n    weighted_scores = normalized * weights\n    combined_scores = np.exp(weighted_scores[:, 0] + weighted_scores[:, 1])  # Exponential combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with more operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select positions for different operations\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n\n    # Option 1: Reverse and insert\n    if np.random.rand() < 0.4:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution = np.insert(new_solution, c, new_solution[b])\n        new_solution = np.delete(new_solution, b+1 if b < c else b)\n    # Option 2: Swap segments and insert\n    elif np.random.rand() < 0.7:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        new_solution = np.insert(new_solution, d, new_solution[a])\n        new_solution = np.delete(new_solution, a+1 if a < d else a)\n    # Option 3: Random swap\n    else:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9026246627699077,
            0.15830355882644653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score with adaptive weights\n    objectives = np.array([obj for _, obj in archive])\n    max_vals = np.max(objectives, axis=0)\n    normalized = objectives / max_vals\n    weights = np.array([0.6, 0.4])  # Different weight distribution\n    weighted_scores = normalized * weights\n    combined_scores = np.exp(weighted_scores[:, 0] + weighted_scores[:, 1])  # Exponential combination\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with more operations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select positions for different operations\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    d = np.random.randint(0, n)\n\n    # Option 1: Reverse and insert\n    if np.random.rand() < 0.4:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution = np.insert(new_solution, c, new_solution[b])\n        new_solution = np.delete(new_solution, b+1 if b < c else b)\n    # Option 2: Swap segments and insert\n    elif np.random.rand() < 0.7:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n        new_solution = np.insert(new_solution, d, new_solution[a])\n        new_solution = np.delete(new_solution, a+1 if a < d else a)\n    # Option 3: Random swap\n    else:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective diversity and tour structure metrics, then applies a hybrid local search combining node sequence reversal and adaptive segment transposition to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour structure\n    objectives = np.array([obj for _, obj in archive])\n    objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = np.sum(objectives * objective_ranges, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: sequence reversal and adaptive segment transposition\n    if n > 4:\n        # Node sequence reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive segment transposition\n        segment_length = min(3, n // 4)\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:],\n            segment\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure entropy, then applies a hybrid local search combining adaptive node clustering and segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum((objectives <= objectives.min(axis=0)), axis=1)\n    entropy_scores = np.array([np.unique(archive[i][0]).size / len(archive[i][0]) for i in range(len(archive))])\n    combined_scores = dominance_scores * entropy_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and segment inversion\n    if n > 5:\n        # Adaptive node clustering\n        cluster_size = max(2, n // 5)\n        for i in range(0, n, cluster_size):\n            segment = new_solution[i:i+cluster_size]\n            if len(segment) > 1:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))\n                new_solution[i:i+cluster_size] = segment\n\n        # Segment inversion with adaptive range\n        inversion_length = min(4, n // 3)\n        start = random.randint(0, n - inversion_length)\n        new_solution[start:start+inversion_length] = new_solution[start:start+inversion_length][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8309316115774436,
            0.4593138098716736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.sum((objectives <= objectives.min(axis=0)), axis=1)\n    entropy_scores = np.array([np.unique(archive[i][0]).size / len(archive[i][0]) for i in range(len(archive))])\n    combined_scores = dominance_scores * entropy_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive node clustering and segment inversion\n    if n > 5:\n        # Adaptive node clustering\n        cluster_size = max(2, n // 5)\n        for i in range(0, n, cluster_size):\n            segment = new_solution[i:i+cluster_size]\n            if len(segment) > 1:\n                segment = np.roll(segment, random.randint(1, len(segment)-1))\n                new_solution[i:i+cluster_size] = segment\n\n        # Segment inversion with adaptive range\n        inversion_length = min(4, n // 3)\n        start = random.randint(0, n - inversion_length)\n        new_solution[start:start+inversion_length] = new_solution[start:start+inversion_length][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of crowding distance and objective dominance, then applies a hybrid local search combining path relinking with a randomized segment exchange and inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_dist[sorted_indices[0]] = crowding_dist[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-6)\n\n    # Combine dominance and crowding distance for selection\n    scores = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominance = 0\n        for other_obj in objectives:\n            if all(obj[i] <= other_obj[i] for i in range(2)) and any(obj[i] < other_obj[i] for i in range(2)):\n                dominance += 1\n        score = dominance + crowding_dist[idx]\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0], reverse=True)\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking with segment exchange\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Exchange segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n        # Randomized segment inversion\n        e, f = sorted(random.sample(range(n), 2))\n        new_solution[e:f] = new_solution[e:f][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7806397608144288,
            10.4730024933815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_dist[sorted_indices[0]] = crowding_dist[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i] + 1e-6)\n\n    # Combine dominance and crowding distance for selection\n    scores = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominance = 0\n        for other_obj in objectives:\n            if all(obj[i] <= other_obj[i] for i in range(2)) and any(obj[i] < other_obj[i] for i in range(2)):\n                dominance += 1\n        score = dominance + crowding_dist[idx]\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0], reverse=True)\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking with segment exchange\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Exchange segments\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n        # Randomized segment inversion\n        e, f = sorted(random.sample(range(n), 2))\n        new_solution[e:f] = new_solution[e:f][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective weighting that adapts to the current distribution of solutions, then applies a hybrid local search combining segment insertion with probabilistic edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective weighting based on current distribution\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.ptp(objectives, axis=0)\n    weights = obj_range / np.sum(obj_range) if np.sum(obj_range) > 0 else np.array([0.5, 0.5])\n    weighted_scores = objectives * weights\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment insertion with probabilistic edge swaps\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Insert segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n    new_solution = np.delete(new_solution, np.s_[new_pos + len(segment):new_pos + len(segment) + (b - a)])\n\n    # Probabilistic edge swaps\n    for i in range(1, n-1):\n        if random.random() < 0.2:  # 20% chance to swap\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        extra_nodes = np.setdiff1d(new_solution, np.arange(n))\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7047828918957945,
            0.24228453636169434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective weighting based on current distribution\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.ptp(objectives, axis=0)\n    weights = obj_range / np.sum(obj_range) if np.sum(obj_range) > 0 else np.array([0.5, 0.5])\n    weighted_scores = objectives * weights\n    combined_scores = np.sum(weighted_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment insertion with probabilistic edge swaps\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Insert segment at a new position\n    new_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n    new_solution = np.delete(new_solution, np.s_[new_pos + len(segment):new_pos + len(segment) + (b - a)])\n\n    # Probabilistic edge swaps\n    for i in range(1, n-1):\n        if random.random() < 0.2:  # 20% chance to swap\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        extra_nodes = np.setdiff1d(new_solution, np.arange(n))\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance and applies a novel local search combining segment reversals, node relocations, and objective-aware edge replacements to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1] and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                dominated[i] = True\n                break\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with objective-aware selection\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n    if random.random() < 0.5:\n        segment = np.flip(segment)\n    new_solution[start_pos:start_pos+segment_length] = segment\n\n    # Step 2: Node relocation based on distance improvement\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        temp_sol = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Objective-aware edge replacement\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        a, b = new_solution[i], new_solution[j]\n        cost1_old = distance_matrix_1[new_solution[i-1], a] + distance_matrix_1[a, new_solution[(i+1)%n]]\n        cost2_old = distance_matrix_2[new_solution[i-1], a] + distance_matrix_2[a, new_solution[(i+1)%n]]\n        cost1_new = distance_matrix_1[new_solution[i-1], b] + distance_matrix_1[b, new_solution[(i+1)%n]]\n        cost2_new = distance_matrix_2[new_solution[i-1], b] + distance_matrix_2[b, new_solution[(i+1)%n]]\n        if (cost1_new < cost1_old and cost2_new <= cost2_old) or (cost2_new < cost2_old and cost1_new <= cost1_old):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8613300554116472,
            13.906635701656342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1] and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                dominated[i] = True\n                break\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with objective-aware selection\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n    if random.random() < 0.5:\n        segment = np.flip(segment)\n    new_solution[start_pos:start_pos+segment_length] = segment\n\n    # Step 2: Node relocation based on distance improvement\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(n-1):\n        temp_sol = np.insert(new_solution, pos, node)\n        cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Objective-aware edge replacement\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        a, b = new_solution[i], new_solution[j]\n        cost1_old = distance_matrix_1[new_solution[i-1], a] + distance_matrix_1[a, new_solution[(i+1)%n]]\n        cost2_old = distance_matrix_2[new_solution[i-1], a] + distance_matrix_2[a, new_solution[(i+1)%n]]\n        cost1_new = distance_matrix_1[new_solution[i-1], b] + distance_matrix_1[b, new_solution[(i+1)%n]]\n        cost2_new = distance_matrix_2[new_solution[i-1], b] + distance_matrix_2[b, new_solution[(i+1)%n]]\n        if (cost1_new < cost1_old and cost2_new <= cost2_old) or (cost2_new < cost2_old and cost1_new <= cost1_old):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and spatial diversity, then applies a hybrid local search combining adaptive segment reversal and intelligent node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                non_dominated[i] = False\n                break\n\n    if np.any(non_dominated):\n        candidates = np.where(non_dominated)[0]\n    else:\n        candidates = np.arange(len(archive))\n\n    # Spatial diversity metric\n    diversity_scores = []\n    for i in candidates:\n        sol = archive[i][0]\n        coords = instance[sol]\n        centroid = np.mean(coords, axis=0)\n        distances = np.linalg.norm(coords - centroid, axis=1)\n        diversity_scores.append(np.std(distances))\n\n    selected_idx = candidates[np.argmax(diversity_scores)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and intelligent insertion\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = max(2, min(5, int(n * 0.2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Intelligent node insertion\n        if random.random() < 0.3:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = min(j, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.810630337143647,
            1.0878232717514038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial diversity\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                non_dominated[i] = False\n                break\n\n    if np.any(non_dominated):\n        candidates = np.where(non_dominated)[0]\n    else:\n        candidates = np.arange(len(archive))\n\n    # Spatial diversity metric\n    diversity_scores = []\n    for i in candidates:\n        sol = archive[i][0]\n        coords = instance[sol]\n        centroid = np.mean(coords, axis=0)\n        distances = np.linalg.norm(coords - centroid, axis=1)\n        diversity_scores.append(np.std(distances))\n\n    selected_idx = candidates[np.argmax(diversity_scores)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and intelligent insertion\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = max(2, min(5, int(n * 0.2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Intelligent node insertion\n        if random.random() < 0.3:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = min(j, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9366088005416936,
            0.09744668006896973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted sum for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8637806975752467,
            0.26755625009536743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted sum for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic weighted combination of objectives, incorporating both linear and non-linear components, then applies a hybrid local search combining segment reversal, random swaps, and dynamic segment length adjustments to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    dynamic_weights = weights * (1 + 0.1 * np.random.rand(2))  # Add small random variation\n    weighted_scores = objectives * dynamic_weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2) + 0.3 * (weighted_scores[:, 0] + weighted_scores[:, 1])  # Mixed linear and non-linear\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with dynamic segment lengths\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments with dynamic lengths\n    segment_length = max(2, int(np.random.rand() * np.sqrt(n) + 1))\n    a = np.random.randint(0, n - segment_length)\n    b = a + segment_length\n    c = np.random.randint(b, n)\n\n    # Option 1: Reverse segments and swap with dynamic probability\n    if np.random.rand() < 0.6:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a], new_solution[c-1] = new_solution[c-1], new_solution[a]\n    # Option 2: Random swap of segments with dynamic order\n    else:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        if np.random.rand() < 0.5:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8201012421405836,
            0.4510487914085388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dynamic weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    dynamic_weights = weights * (1 + 0.1 * np.random.rand(2))  # Add small random variation\n    weighted_scores = objectives * dynamic_weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2) + 0.3 * (weighted_scores[:, 0] + weighted_scores[:, 1])  # Mixed linear and non-linear\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with dynamic segment lengths\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments with dynamic lengths\n    segment_length = max(2, int(np.random.rand() * np.sqrt(n) + 1))\n    a = np.random.randint(0, n - segment_length)\n    b = a + segment_length\n    c = np.random.randint(b, n)\n\n    # Option 1: Reverse segments and swap with dynamic probability\n    if np.random.rand() < 0.6:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a], new_solution[c-1] = new_solution[c-1], new_solution[a]\n    # Option 2: Random swap of segments with dynamic order\n    else:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        if np.random.rand() < 0.5:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n        else:\n            new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour segment diversity, then applies a hybrid local search combining adaptive segment reversal and targeted node repositioning to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = objectives.max(axis=0) - objectives\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = improvement_potential[:, 0] * 0.7 + improvement_potential[:, 1] * 0.3 + diversity_scores * 0.2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and targeted node repositioning\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = min(5, n // 3)\n        start_pos = random.randint(0, n - segment_length)\n        end_pos = start_pos + segment_length\n        new_solution[start_pos:end_pos] = np.flip(new_solution[start_pos:end_pos])\n\n        # Targeted node repositioning\n        for _ in range(2):\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7818721708829628,
            0.4252192974090576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = objectives.max(axis=0) - objectives\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = improvement_potential[:, 0] * 0.7 + improvement_potential[:, 1] * 0.3 + diversity_scores * 0.2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversal and targeted node repositioning\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = min(5, n // 3)\n        start_pos = random.randint(0, n - segment_length)\n        end_pos = start_pos + segment_length\n        new_solution[start_pos:end_pos] = np.flip(new_solution[start_pos:end_pos])\n\n        # Targeted node repositioning\n        for _ in range(2):\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and spatial locality, then applies a hybrid local search combining k-opt swaps with adaptive segment reversal and distance-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial locality\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Prefer solutions with better spatial locality in either objective space\n        spatial_scores = []\n        for idx in pareto_front:\n            sol = archive[idx][0]\n            total_dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total_dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n            spatial_score = - (total_dist1 + total_dist2)  # Negative because we want to maximize (minimize distance)\n            spatial_scores.append(spatial_score)\n\n        selected_idx = pareto_front[np.argmax(spatial_scores)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: k-opt swaps with adaptive segment reversal\n    if n > 4:\n        # Adaptive k-opt (k=3 or 4)\n        k = random.choice([3, 4])\n        if n >= k:\n            points = sorted(random.sample(range(n), k))\n            segments = []\n            for i in range(k):\n                start = points[i]\n                end = points[(i+1)%k]\n                if start < end:\n                    segments.append(new_solution[start:end])\n                else:\n                    segments.append(np.concatenate([new_solution[start:], new_solution[:end]]))\n\n            # Recombine segments in a different order\n            random.shuffle(segments)\n            new_segments = []\n            for seg in segments:\n                if random.random() < 0.4:  # 40% chance to reverse segment\n                    new_segments.append(seg[::-1])\n                else:\n                    new_segments.append(seg)\n\n            # Reconstruct the tour\n            new_solution = np.concatenate(new_segments)\n\n            # Distance-aware edge swaps\n            for _ in range(2):  # Perform 2 swaps\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                   distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                   distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                   distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    new_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    if new_dist >= current_dist:  # If worse, revert\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8687535242516463,
            0.9445378184318542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial locality\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Prefer solutions with better spatial locality in either objective space\n        spatial_scores = []\n        for idx in pareto_front:\n            sol = archive[idx][0]\n            total_dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n            total_dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n            spatial_score = - (total_dist1 + total_dist2)  # Negative because we want to maximize (minimize distance)\n            spatial_scores.append(spatial_score)\n\n        selected_idx = pareto_front[np.argmax(spatial_scores)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: k-opt swaps with adaptive segment reversal\n    if n > 4:\n        # Adaptive k-opt (k=3 or 4)\n        k = random.choice([3, 4])\n        if n >= k:\n            points = sorted(random.sample(range(n), k))\n            segments = []\n            for i in range(k):\n                start = points[i]\n                end = points[(i+1)%k]\n                if start < end:\n                    segments.append(new_solution[start:end])\n                else:\n                    segments.append(np.concatenate([new_solution[start:], new_solution[:end]]))\n\n            # Recombine segments in a different order\n            random.shuffle(segments)\n            new_segments = []\n            for seg in segments:\n                if random.random() < 0.4:  # 40% chance to reverse segment\n                    new_segments.append(seg[::-1])\n                else:\n                    new_segments.append(seg)\n\n            # Reconstruct the tour\n            new_solution = np.concatenate(new_segments)\n\n            # Distance-aware edge swaps\n            for _ in range(2):  # Perform 2 swaps\n                i = random.randint(0, n-1)\n                j = random.randint(0, n-1)\n                if i != j:\n                    current_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                   distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                   distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                   distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    new_dist = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                                distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                    if new_dist >= current_dist:  # If worse, revert\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized Pareto-dominance score and local improvement potential, then applies a hybrid local search combining edge insertion and adaptive segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto-dominance and local improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated += 1\n        pareto_scores[i] = 1 / (dominated + 1)\n\n    # Calculate local improvement potential\n    improvement_potentials = np.zeros(len(archive))\n    for i in range(len(archive)):\n        sol = archive[i][0]\n        total_improvement = 0\n        for j in range(len(sol)-1):\n            u, v = sol[j], sol[j+1]\n            total_improvement += (distance_matrix_1[u, v] + distance_matrix_2[u, v]) - (distance_matrix_1[u, sol[(j+2)%len(sol)]] + distance_matrix_2[u, sol[(j+2)%len(sol)]])\n        improvement_potentials[i] = max(0, total_improvement)\n\n    normalized_pareto = (pareto_scores - pareto_scores.min()) / (pareto_scores.max() - pareto_scores.min() + 1e-8)\n    normalized_improvement = (improvement_potentials - improvement_potentials.min()) / (improvement_potentials.max() - improvement_potentials.min() + 1e-8)\n\n    combined_scores = 0.6 * normalized_pareto + 0.4 * normalized_improvement\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and adaptive segment rotation\n    if n > 4:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = np.roll(new_solution[i:j], 1)\n\n        # Adaptive segment rotation\n        rotation_prob = min(0.7, 0.2 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < rotation_prob:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = np.rot90(new_solution[a:b].reshape(-1, 1), k=1).flatten()\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9509320664942018,
            3.874182343482971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto-dominance and local improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    pareto_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated += 1\n        pareto_scores[i] = 1 / (dominated + 1)\n\n    # Calculate local improvement potential\n    improvement_potentials = np.zeros(len(archive))\n    for i in range(len(archive)):\n        sol = archive[i][0]\n        total_improvement = 0\n        for j in range(len(sol)-1):\n            u, v = sol[j], sol[j+1]\n            total_improvement += (distance_matrix_1[u, v] + distance_matrix_2[u, v]) - (distance_matrix_1[u, sol[(j+2)%len(sol)]] + distance_matrix_2[u, sol[(j+2)%len(sol)]])\n        improvement_potentials[i] = max(0, total_improvement)\n\n    normalized_pareto = (pareto_scores - pareto_scores.min()) / (pareto_scores.max() - pareto_scores.min() + 1e-8)\n    normalized_improvement = (improvement_potentials - improvement_potentials.min()) / (improvement_potentials.max() - improvement_potentials.min() + 1e-8)\n\n    combined_scores = 0.6 * normalized_pareto + 0.4 * normalized_improvement\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion and adaptive segment rotation\n    if n > 4:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = np.roll(new_solution[i:j], 1)\n\n        # Adaptive segment rotation\n        rotation_prob = min(0.7, 0.2 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < rotation_prob:\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = np.rot90(new_solution[a:b].reshape(-1, 1), k=1).flatten()\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment inversion and selective node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment inversion and selective node swapping\n    if n > 6:\n        # Multi-segment inversion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Selective node swapping\n        swap_pos = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8736917938286757,
            1.7659533619880676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment inversion and selective node swapping\n    if n > 6:\n        # Multi-segment inversion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Selective node swapping\n        swap_pos = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[swap_pos[0]], new_solution[swap_pos[1]] = new_solution[swap_pos[1]], new_solution[swap_pos[0]]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment inversion and selective node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 6:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        swap_pos = random.randint(0, n-1)\n        if random.random() < 0.4:\n            swap_target = random.randint(0, n-1)\n            new_solution[swap_pos], new_solution[swap_target] = new_solution[swap_target], new_solution[swap_pos]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8200373125051887,
            1.4503222107887268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 6:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        swap_pos = random.randint(0, n-1)\n        if random.random() < 0.4:\n            swap_target = random.randint(0, n-1)\n            new_solution[swap_pos], new_solution[swap_target] = new_solution[swap_target], new_solution[swap_pos]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify well-distributed solutions, then applies a hybrid local search combining node insertion with a limited-depth segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    objectives.sort(key=lambda x: (x[0], x[1]))\n\n    crowding = np.zeros(len(objectives))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m] > 0:\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n    # Select solution with highest crowding distance (well-distributed)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion with limited-depth segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with limited depth\n        depth = min(3, len(segment))\n        reversed_segment = np.concatenate([segment[:depth][::-1], segment[depth:]])\n\n        # Insert the modified segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9114528856925033,
            0.44586068391799927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    objectives.sort(key=lambda x: (x[0], x[1]))\n\n    crowding = np.zeros(len(objectives))\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m] > 0:\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m])\n\n    # Select solution with highest crowding distance (well-distributed)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion with limited-depth segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with limited depth\n        depth = min(3, len(segment))\n        reversed_segment = np.concatenate([segment[:depth][::-1], segment[depth:]])\n\n        # Insert the modified segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility, using different parameter settings for the score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score with different weights\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    weighted_scores = objectives * weights\n    combined_scores = np.sum(weighted_scores**2, axis=1)  # Sum of squared weighted scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with modified parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three points with different distribution\n    a = np.random.randint(0, n//2)\n    b = np.random.randint(n//2, n)\n    c = np.random.randint(0, n)\n\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap with probability 0.7\n    if np.random.rand() < 0.7:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments with probability 0.3\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.7952128445274298,
            0.22866928577423096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score with different weights\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    weighted_scores = objectives * weights\n    combined_scores = np.sum(weighted_scores**2, axis=1)  # Sum of squared weighted scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search with modified parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three points with different distribution\n    a = np.random.randint(0, n//2)\n    b = np.random.randint(n//2, n)\n    c = np.random.randint(0, n)\n\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap with probability 0.7\n    if np.random.rand() < 0.7:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments with probability 0.3\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion that combines Pareto dominance and solution crowding distance, then applies a hybrid local search combining adaptive edge relinking and a novel segment-based crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not is_dominated[i]]\n\n    if len(non_dominated) > 1:\n        # Calculate crowding distance for non-dominated solutions\n        crowding_dist = np.zeros(len(non_dominated))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[non_dominated, m])\n            crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[non_dominated[sorted_idx[i+1]], m] -\n                                                objectives[non_dominated[sorted_idx[i-1]], m])\n\n        selected_idx = non_dominated[np.argmax(crowding_dist)]\n    else:\n        selected_idx = non_dominated[0] if non_dominated else 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge relinking and segment-based crossover\n    if n > 4:\n        # Adaptive edge relinking\n        relink_length = min(3, max(1, int(0.2 * n)))\n        start_pos = random.randint(0, n - relink_length - 1)\n        end_pos = start_pos + relink_length\n\n        # Find the best relinking position\n        best_pos = start_pos\n        best_improvement = 0\n        for pos in range(start_pos + 1, end_pos):\n            # Calculate improvement for relinking\n            improvement = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]]) - \\\n                         (distance_matrix_1[new_solution[pos-1], new_solution[start_pos]] +\n                          distance_matrix_2[new_solution[pos-1], new_solution[start_pos]])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_improvement > 0:\n            # Perform relinking\n            segment = new_solution[start_pos:best_pos].copy()\n            new_solution[start_pos:best_pos] = segment[::-1]\n\n        # Segment-based crossover\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b].copy()\n        crossover_point = random.randint(0, n - (b - a))\n        new_solution[crossover_point:crossover_point+(b-a)] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8724345004406453,
            0.8249510526657104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] >= objectives[j]):\n                is_dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not is_dominated[i]]\n\n    if len(non_dominated) > 1:\n        # Calculate crowding distance for non-dominated solutions\n        crowding_dist = np.zeros(len(non_dominated))\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[non_dominated, m])\n            crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[non_dominated[sorted_idx[i+1]], m] -\n                                                objectives[non_dominated[sorted_idx[i-1]], m])\n\n        selected_idx = non_dominated[np.argmax(crowding_dist)]\n    else:\n        selected_idx = non_dominated[0] if non_dominated else 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive edge relinking and segment-based crossover\n    if n > 4:\n        # Adaptive edge relinking\n        relink_length = min(3, max(1, int(0.2 * n)))\n        start_pos = random.randint(0, n - relink_length - 1)\n        end_pos = start_pos + relink_length\n\n        # Find the best relinking position\n        best_pos = start_pos\n        best_improvement = 0\n        for pos in range(start_pos + 1, end_pos):\n            # Calculate improvement for relinking\n            improvement = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos]]) - \\\n                         (distance_matrix_1[new_solution[pos-1], new_solution[start_pos]] +\n                          distance_matrix_2[new_solution[pos-1], new_solution[start_pos]])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_improvement > 0:\n            # Perform relinking\n            segment = new_solution[start_pos:best_pos].copy()\n            new_solution[start_pos:best_pos] = segment[::-1]\n\n        # Segment-based crossover\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b].copy()\n        crossover_point = random.randint(0, n - (b - a))\n        new_solution[crossover_point:crossover_point+(b-a)] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel score combining objective values and diversity, then applies a hybrid local search with adaptive edge swaps, advanced insertions, and guided path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate scores for selection (combination of objective values and diversity)\n    scores = []\n    for sol, obj in archive:\n        diversity = sum(1 for i in range(len(sol)) if sol[i] != base_solution[i])\n        score = (obj[0] + obj[1]) * 0.7 + diversity * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive parameters\n    n = len(new_solution)\n    k = random.randint(2, min(5, n//3))\n\n    # Step 1: Advanced edge swap with multiple segments\n    segments = sorted(random.sample(range(1, n), k-1))\n    segments = [0] + segments + [n]\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.4:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Step 2: Guided insertion based on distance matrices\n    for _ in range(2):\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            candidates = []\n            for pos in range(n-1):\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                candidates.append((cost1 + cost2, pos))\n            pos = min(candidates, key=lambda x: x[0])[1]\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Guided path relinking with objective-aware selection\n    relink_length = random.randint(2, min(7, n//2))\n    relink_pos = random.randint(0, n - relink_length)\n    for p in range(relink_pos, relink_pos + relink_length):\n        if random.random() < 0.4:\n            candidate = base_solution[p]\n            if candidate not in new_solution[:relink_pos]:\n                new_solution[p] = candidate\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.choice([i for i in range(n) if new_solution[i] not in new_solution[:i]])\n            new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9179358332206304,
            0.8875760436058044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate scores for selection (combination of objective values and diversity)\n    scores = []\n    for sol, obj in archive:\n        diversity = sum(1 for i in range(len(sol)) if sol[i] != base_solution[i])\n        score = (obj[0] + obj[1]) * 0.7 + diversity * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search with adaptive parameters\n    n = len(new_solution)\n    k = random.randint(2, min(5, n//3))\n\n    # Step 1: Advanced edge swap with multiple segments\n    segments = sorted(random.sample(range(1, n), k-1))\n    segments = [0] + segments + [n]\n    for i in range(len(segments)-1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.4:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Step 2: Guided insertion based on distance matrices\n    for _ in range(2):\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            candidates = []\n            for pos in range(n-1):\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                candidates.append((cost1 + cost2, pos))\n            pos = min(candidates, key=lambda x: x[0])[1]\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Guided path relinking with objective-aware selection\n    relink_length = random.randint(2, min(7, n//2))\n    relink_pos = random.randint(0, n - relink_length)\n    for p in range(relink_pos, relink_pos + relink_length):\n        if random.random() < 0.4:\n            candidate = base_solution[p]\n            if candidate not in new_solution[:relink_pos]:\n                new_solution[p] = candidate\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.choice([i for i in range(n) if new_solution[i] not in new_solution[:i]])\n            new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic exploration-exploitation trade-off, then applies a hybrid local search combining adaptive segment rotation and objective-aware node relocations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: balance between exploration and exploitation\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.sqrt(np.sum(normalized**2, axis=1))\n    selected_idx = np.argmax(diversity_scores) if np.random.rand() < 0.3 else np.argmin(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and objective-aware relocation\n    segment_size = max(2, min(5, n//4))\n    start = np.random.randint(0, n-segment_size)\n    end = start + segment_size\n\n    # Adaptive segment rotation\n    rotation = np.random.randint(1, segment_size)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Objective-aware node relocation\n    for i in range(start, end):\n        current_node = new_solution[i]\n        neighbors = [j for j in range(n) if j != i and distance_matrix_1[current_node][j] < np.mean(distance_matrix_1[current_node])]\n        if neighbors and np.random.rand() < 0.4:\n            new_pos = np.random.choice(neighbors)\n            new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9371047905041461,
            0.7594385743141174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection: balance between exploration and exploitation\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.sqrt(np.sum(normalized**2, axis=1))\n    selected_idx = np.argmax(diversity_scores) if np.random.rand() < 0.3 else np.argmin(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and objective-aware relocation\n    segment_size = max(2, min(5, n//4))\n    start = np.random.randint(0, n-segment_size)\n    end = start + segment_size\n\n    # Adaptive segment rotation\n    rotation = np.random.randint(1, segment_size)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Objective-aware node relocation\n    for i in range(start, end):\n        current_node = new_solution[i]\n        neighbors = [j for j in range(n) if j != i and distance_matrix_1[current_node][j] < np.mean(distance_matrix_1[current_node])]\n        if neighbors and np.random.rand() < 0.4:\n            new_pos = np.random.choice(neighbors)\n            new_solution[i], new_solution[new_pos] = new_solution[new_pos], new_solution[i]\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8429253453822327,
            0.08897978067398071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8841303196547681,
            0.10369479656219482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour segment diversity, then applies a hybrid local search combining adaptive segment relocation and dynamic edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and segment diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized_obj[:, 0]  # Higher potential for solutions with lower first objective\n\n    # Calculate segment diversity\n    segment_diversity = []\n    for sol, _ in archive:\n        segments = [sol[i:i+3] for i in range(len(sol)-2)]\n        diversity = len(set(tuple(seg) for seg in segments)) / len(segments)\n        segment_diversity.append(diversity)\n    segment_diversity = np.array(segment_diversity)\n\n    combined_scores = 0.6 * improvement_potential + 0.4 * segment_diversity\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation and dynamic edge inversion\n    if n > 5:\n        # Adaptive segment relocation\n        segment_length = max(2, int(n * 0.2))\n        a = random.randint(0, n - segment_length)\n        segment = new_solution[a:a+segment_length]\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos > a:\n            new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_length:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:a], new_solution[a+segment_length:]])\n\n        # Dynamic edge inversion\n        inversion_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < inversion_prob:\n            k = random.randint(2, min(5, n-1))\n            i = random.randint(0, n - k)\n            new_solution[i:i+k] = new_solution[i:i+k][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9676778955675233,
            1.1492462158203125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and segment diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized_obj[:, 0]  # Higher potential for solutions with lower first objective\n\n    # Calculate segment diversity\n    segment_diversity = []\n    for sol, _ in archive:\n        segments = [sol[i:i+3] for i in range(len(sol)-2)]\n        diversity = len(set(tuple(seg) for seg in segments)) / len(segments)\n        segment_diversity.append(diversity)\n    segment_diversity = np.array(segment_diversity)\n\n    combined_scores = 0.6 * improvement_potential + 0.4 * segment_diversity\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation and dynamic edge inversion\n    if n > 5:\n        # Adaptive segment relocation\n        segment_length = max(2, int(n * 0.2))\n        a = random.randint(0, n - segment_length)\n        segment = new_solution[a:a+segment_length]\n        new_pos = random.randint(0, n - segment_length)\n        if new_pos > a:\n            new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_length:new_pos], segment, new_solution[new_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:a], new_solution[a+segment_length:]])\n\n        # Dynamic edge inversion\n        inversion_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < inversion_prob:\n            k = random.randint(2, min(5, n-1))\n            i = random.randint(0, n - k)\n            new_solution[i:i+k] = new_solution[i:i+k][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9158823179575685,
            0.45977044105529785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal, node relocation, and guided edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives and diversity\n    solutions = [sol for (sol, obj) in archive]\n    objectives = [obj for (sol, obj) in archive]\n    selected_idx = np.argmin([obj[0] + obj[1] - 0.5 * (obj[0] * obj[1]) for obj in objectives])\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, node relocation, and guided edge swaps\n    # Step 1: Segment reversal with potential for cost reduction\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if i > 0 and j < n-1:\n            segment = new_solution[i:j+1]\n            cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] + \\\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n            cost_after = distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j+1]] + \\\n                         distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j+1]]\n            if cost_after < cost_before:\n                new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Node relocation based on distance improvement\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    current_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] + \\\n                   distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n    best_pos = k\n    best_cost = current_cost\n\n    for pos in range(n):\n        if pos == k or pos == (k-1)%n or pos == (k+1)%n:\n            continue\n        new_cost = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] + \\\n                  distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swaps based on distance matrices\n    a, b = sorted(random.sample(range(n), 2))\n    if a > 0 and b < n-1:\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] + \\\n                     distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7401333390160805,
            0.2834472060203552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a good balance between objectives and diversity\n    solutions = [sol for (sol, obj) in archive]\n    objectives = [obj for (sol, obj) in archive]\n    selected_idx = np.argmin([obj[0] + obj[1] - 0.5 * (obj[0] * obj[1]) for obj in objectives])\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, node relocation, and guided edge swaps\n    # Step 1: Segment reversal with potential for cost reduction\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if i > 0 and j < n-1:\n            segment = new_solution[i:j+1]\n            cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] + \\\n                          distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n            cost_after = distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j+1]] + \\\n                         distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j+1]]\n            if cost_after < cost_before:\n                new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Node relocation based on distance improvement\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    current_cost = distance_matrix_1[new_solution[k-1], node] + distance_matrix_1[node, new_solution[(k+1)%n]] + \\\n                   distance_matrix_2[new_solution[k-1], node] + distance_matrix_2[node, new_solution[(k+1)%n]]\n    best_pos = k\n    best_cost = current_cost\n\n    for pos in range(n):\n        if pos == k or pos == (k-1)%n or pos == (k+1)%n:\n            continue\n        new_cost = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] + \\\n                  distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_pos = pos\n\n    if best_pos != k:\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Guided edge swaps based on distance matrices\n    a, b = sorted(random.sample(range(n), 2))\n    if a > 0 and b < n-1:\n        cost_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        cost_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] + \\\n                     distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        if cost_after < cost_before:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and spatial distribution characteristics, then applies a hybrid local search combining adaptive segment permutation and distance-aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective values and spatial distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate spatial distribution metric\n    spatial_metrics = []\n    for sol, _ in archive:\n        coords = instance[sol]\n        x1_std = np.std(coords[:, 0])\n        y1_std = np.std(coords[:, 1])\n        x2_std = np.std(coords[:, 2])\n        y2_std = np.std(coords[:, 3])\n        spatial_metrics.append(x1_std + y1_std + x2_std + y2_std)\n    spatial_metrics = np.array(spatial_metrics)\n    normalized_spatial = (spatial_metrics - spatial_metrics.min()) / (spatial_metrics.max() - spatial_metrics.min() + 1e-8)\n\n    combined_scores = 0.6 * scores + 0.4 * normalized_spatial\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment permutation and distance-aware node insertion\n    if n > 5:\n        # Adaptive segment permutation\n        segment_length = max(2, min(5, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Distance-aware node insertion\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = (i + random.randint(2, min(5, n-1))) % n\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9191967333259405,
            7.368675470352173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective values and spatial distribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate spatial distribution metric\n    spatial_metrics = []\n    for sol, _ in archive:\n        coords = instance[sol]\n        x1_std = np.std(coords[:, 0])\n        y1_std = np.std(coords[:, 1])\n        x2_std = np.std(coords[:, 2])\n        y2_std = np.std(coords[:, 3])\n        spatial_metrics.append(x1_std + y1_std + x2_std + y2_std)\n    spatial_metrics = np.array(spatial_metrics)\n    normalized_spatial = (spatial_metrics - spatial_metrics.min()) / (spatial_metrics.max() - spatial_metrics.min() + 1e-8)\n\n    combined_scores = 0.6 * scores + 0.4 * normalized_spatial\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment permutation and distance-aware node insertion\n    if n > 5:\n        # Adaptive segment permutation\n        segment_length = max(2, min(5, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Distance-aware node insertion\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = (i + random.randint(2, min(5, n-1))) % n\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.993150798200477,
            0.11833864450454712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This algorithm selects a solution from the archive based on the most crowded region in the objective space, applies a novel hybrid local search combining segment reversal, node relocation, and adaptive path relinking to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution from the most crowded region\n    objectives = [obj for (sol, obj) in archive]\n    crowding = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                dist = np.sqrt((objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2)\n                crowding[i] += dist\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    seg_length = min(5, n//3)\n    i = random.randint(0, n - seg_length)\n    new_solution[i:i+seg_length] = np.flip(new_solution[i:i+seg_length])\n\n    # Node relocation with distance-based probability\n    for _ in range(2):\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        # Find position with minimal total distance increase\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            temp_sol = np.insert(new_solution, pos, node)\n            cost1 = distance_matrix_1[temp_sol[pos-1], node] + distance_matrix_1[node, temp_sol[(pos+1)%n]] - distance_matrix_1[temp_sol[pos-1], temp_sol[(pos+1)%n]]\n            cost2 = distance_matrix_2[temp_sol[pos-1], node] + distance_matrix_2[node, temp_sol[(pos+1)%n]] - distance_matrix_2[temp_sol[pos-1], temp_sol[(pos+1)%n]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Adaptive path relinking\n    relink_length = min(5, n//2)\n    relink_pos = random.randint(0, n - relink_length)\n    for p in range(relink_pos, relink_pos + relink_length):\n        if random.random() < 0.4:\n            # Swap with node from base solution that improves both objectives\n            base_node = base_solution[p]\n            current_node = new_solution[p]\n            if base_node != current_node:\n                # Calculate cost difference for both objectives\n                cost_diff1 = (distance_matrix_1[new_solution[p-1], base_node] + distance_matrix_1[base_node, new_solution[(p+1)%n]] -\n                             distance_matrix_1[new_solution[p-1], current_node] - distance_matrix_1[current_node, new_solution[(p+1)%n]])\n                cost_diff2 = (distance_matrix_2[new_solution[p-1], base_node] + distance_matrix_2[base_node, new_solution[(p+1)%n]] -\n                             distance_matrix_2[new_solution[p-1], current_node] - distance_matrix_2[current_node, new_solution[(p+1)%n]])\n                if cost_diff1 < 0 and cost_diff2 < 0:\n                    new_solution[p] = base_node\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8861757358264182,
            2.1606857776641846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution from the most crowded region\n    objectives = [obj for (sol, obj) in archive]\n    crowding = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                dist = np.sqrt((objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2)\n                crowding[i] += dist\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    seg_length = min(5, n//3)\n    i = random.randint(0, n - seg_length)\n    new_solution[i:i+seg_length] = np.flip(new_solution[i:i+seg_length])\n\n    # Node relocation with distance-based probability\n    for _ in range(2):\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        # Find position with minimal total distance increase\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(n-1):\n            temp_sol = np.insert(new_solution, pos, node)\n            cost1 = distance_matrix_1[temp_sol[pos-1], node] + distance_matrix_1[node, temp_sol[(pos+1)%n]] - distance_matrix_1[temp_sol[pos-1], temp_sol[(pos+1)%n]]\n            cost2 = distance_matrix_2[temp_sol[pos-1], node] + distance_matrix_2[node, temp_sol[(pos+1)%n]] - distance_matrix_2[temp_sol[pos-1], temp_sol[(pos+1)%n]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Adaptive path relinking\n    relink_length = min(5, n//2)\n    relink_pos = random.randint(0, n - relink_length)\n    for p in range(relink_pos, relink_pos + relink_length):\n        if random.random() < 0.4:\n            # Swap with node from base solution that improves both objectives\n            base_node = base_solution[p]\n            current_node = new_solution[p]\n            if base_node != current_node:\n                # Calculate cost difference for both objectives\n                cost_diff1 = (distance_matrix_1[new_solution[p-1], base_node] + distance_matrix_1[base_node, new_solution[(p+1)%n]] -\n                             distance_matrix_1[new_solution[p-1], current_node] - distance_matrix_1[current_node, new_solution[(p+1)%n]])\n                cost_diff2 = (distance_matrix_2[new_solution[p-1], base_node] + distance_matrix_2[base_node, new_solution[(p+1)%n]] -\n                             distance_matrix_2[new_solution[p-1], current_node] - distance_matrix_2[current_node, new_solution[(p+1)%n]])\n                if cost_diff1 < 0 and cost_diff2 < 0:\n                    new_solution[p] = base_node\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a novel hybrid local search combining edge swapping with a randomized segment inversion and a probabilistic node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping with randomized segment inversion and probabilistic node relocation\n    if n > 3:\n        # Step 1: Random edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Randomized segment inversion\n        if n > 4:\n            start, end = sorted(random.sample(range(n), 2))\n            segment = new_solution[start:end]\n            if len(segment) > 1:\n                new_solution[start:end] = segment[::-1]\n\n        # Step 3: Probabilistic node relocation\n        if random.random() < 0.3:\n            node_idx = random.randint(0, n-1)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8787953715244237,
            0.21423089504241943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: edge swapping with randomized segment inversion and probabilistic node relocation\n    if n > 3:\n        # Step 1: Random edge swapping\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 2: Randomized segment inversion\n        if n > 4:\n            start, end = sorted(random.sample(range(n), 2))\n            segment = new_solution[start:end]\n            if len(segment) > 1:\n                new_solution[start:end] = segment[::-1]\n\n        # Step 3: Probabilistic node relocation\n        if random.random() < 0.3:\n            node_idx = random.randint(0, n-1)\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining a restricted 2-opt with a probabilistic segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] / obj[1] if obj[1] != 0 else float('inf') for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: restricted 2-opt with probabilistic segment relocation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Probabilistic insertion: insert with 70% probability\n        if random.random() < 0.7:\n            insert_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n            # Remove duplicates\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n        else:\n            # Restricted 2-opt: only if segment size is small\n            if len(segment) <= 3:\n                new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8727363878789196,
            0.14639794826507568
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [obj[0] / obj[1] if obj[1] != 0 else float('inf') for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: restricted 2-opt with probabilistic segment relocation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Probabilistic insertion: insert with 70% probability\n        if random.random() < 0.7:\n            insert_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n            # Remove duplicates\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n        else:\n            # Restricted 2-opt: only if segment size is small\n            if len(segment) <= 3:\n                new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure diversity, then applies a hybrid local search combining segment inversion, node relocation, and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    avg_obj = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.sum((objectives - avg_obj) ** 2, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion, node relocation, and adaptive edge swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node relocation\n        node = new_solution[random.randint(0, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Adaptive edge swapping\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8225888729658353,
            0.2865251898765564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    avg_obj = np.mean(objectives, axis=0)\n    selected_idx = np.argmax(np.sum((objectives - avg_obj) ** 2, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion, node relocation, and adaptive edge swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node relocation\n        node = new_solution[random.randint(0, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Adaptive edge swapping\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest combined objective values, then applies a hybrid local search combining segment reversal, edge exchange, and a novel 'cross-segment' insertion from a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        k, l = sorted(random.sample(range(n), 2))\n        segment = other_solution[k:l]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9123198979017069,
            0.0977470874786377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    a, b = sorted(random.sample(range(n), 2))\n    if a != b:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        k, l = sorted(random.sample(range(n), 2))\n        segment = other_solution[k:l]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment rotation, node relocation, and a novel path inversion technique to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Node relocation\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    # Find a segment where average distance is below average\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg < avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9853124664208053,
            0.3707008957862854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Node relocation\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    # Find a segment where average distance is below average\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg < avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion that balances objective improvement and solution diversity, then applies a hybrid local search combining segment insertion and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity-aware selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Compute pairwise Hamming distances between solutions\n    hamming_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                hamming_distances[i] += np.sum(solutions[i] != solutions[j])\n\n    # Combine objective improvement and diversity\n    objective_scores = np.sqrt(objectives[:, 0]**2 + objectives[:, 1]**2)\n    selection_scores = objective_scores + 0.5 * hamming_distances\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct positions\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Option 1: Insert segment between two points\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    # Option 2: Relocate node to a new position\n    else:\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.6880876502383917,
            1.8543134331703186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity-aware selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    # Compute pairwise Hamming distances between solutions\n    hamming_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                hamming_distances[i] += np.sum(solutions[i] != solutions[j])\n\n    # Combine objective improvement and diversity\n    objective_scores = np.sqrt(objectives[:, 0]**2 + objectives[:, 1]**2)\n    selection_scores = objective_scores + 0.5 * hamming_distances\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct positions\n    a, b, c = np.random.choice(n, size=3, replace=False)\n    a, b, c = sorted([a, b, c])\n\n    # Option 1: Insert segment between two points\n    if np.random.rand() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    # Option 2: Relocate node to a new position\n    else:\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n    # Ensure feasibility\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined hypervolume contribution and angle-based selection metric, then applies a novel local search operator combining a variable-length segment swap with a biased edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ref_point = (max(obj[0] for _, obj in archive) + 1, max(obj[1] for _, obj in archive) + 1)\n    contributions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, p_obj in archive:\n            if p_obj[0] < obj[0] and p_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            contributions.append((sol, obj, (ref_point[0] - obj[0]) * (ref_point[1] - obj[1])))\n\n    if contributions:\n        # Select solution with maximum hypervolume contribution\n        max_contrib_idx = np.argmax([c[2] for c in contributions])\n        base_solution = contributions[max_contrib_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Variable-length segment swap\n        seg_length = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - seg_length)\n        b = random.randint(0, n - seg_length)\n        segment_a = new_solution[a:a+seg_length]\n        segment_b = new_solution[b:b+seg_length]\n        new_solution[a:a+seg_length] = segment_b\n        new_solution[b:b+seg_length] = segment_a\n\n        # Biased edge insertion\n        edges = [(new_solution[i], new_solution[(i+1)%n]) for i in range(n)]\n        edge_scores = []\n        for i, (u, v) in enumerate(edges):\n            score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            edge_scores.append((i, score))\n        edge_scores.sort(key=lambda x: x[1])\n        selected_edge = edge_scores[0][0]\n        insert_pos = random.randint(0, n-1)\n        if insert_pos != selected_edge:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [new_solution[selected_edge]],\n                new_solution[insert_pos:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8773167683687839,
            0.35801780223846436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ref_point = (max(obj[0] for _, obj in archive) + 1, max(obj[1] for _, obj in archive) + 1)\n    contributions = []\n    for sol, obj in archive:\n        dominated = False\n        for _, p_obj in archive:\n            if p_obj[0] < obj[0] and p_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            contributions.append((sol, obj, (ref_point[0] - obj[0]) * (ref_point[1] - obj[1])))\n\n    if contributions:\n        # Select solution with maximum hypervolume contribution\n        max_contrib_idx = np.argmax([c[2] for c in contributions])\n        base_solution = contributions[max_contrib_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Variable-length segment swap\n        seg_length = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - seg_length)\n        b = random.randint(0, n - seg_length)\n        segment_a = new_solution[a:a+seg_length]\n        segment_b = new_solution[b:b+seg_length]\n        new_solution[a:a+seg_length] = segment_b\n        new_solution[b:b+seg_length] = segment_a\n\n        # Biased edge insertion\n        edges = [(new_solution[i], new_solution[(i+1)%n]) for i in range(n)]\n        edge_scores = []\n        for i, (u, v) in enumerate(edges):\n            score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            edge_scores.append((i, score))\n        edge_scores.sort(key=lambda x: x[1])\n        selected_edge = edge_scores[0][0]\n        insert_pos = random.randint(0, n-1)\n        if insert_pos != selected_edge:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [new_solution[selected_edge]],\n                new_solution[insert_pos:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objective values, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Higher weight for first objective\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8632164188911933,
            0.2661644220352173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Higher weight for first objective\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and tour entropy, then applies a hybrid local search combining segment inversion and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on weighted objective and entropy\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.dot(normalized_obj, weights)\n\n    # Calculate tour entropy\n    entropies = []\n    for sol, _ in archive:\n        _, counts = np.unique(sol, return_counts=True)\n        entropy = -np.sum(counts * np.log(counts + 1e-8))\n        entropies.append(entropy)\n    entropies = np.array(entropies)\n    normalized_ent = (entropies - entropies.min()) / (entropies.max() - entropies.min() + 1e-8)\n\n    combined_scores = 0.7 * scores + 0.3 * normalized_ent\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive node swapping\n    if n > 4:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        swap_prob = min(0.5, 0.1 * (objectives[selected_idx][0] / (objectives[:,0].mean() + 1e-8)))\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined metric of objective diversity and spatial concentration, then applies a hybrid local search combining adaptive segment rotation and multi-objective edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and spatial concentration\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.std(objectives, axis=0)\n    spatial_concentration = np.array([np.mean(np.linalg.norm(instance[sol[:-1], :2] - instance[sol[1:], :2], axis=1)) for sol, _ in archive])\n    combined_scores = 0.6 * obj_diversity[0] + 0.4 * obj_diversity[1] + 0.2 * spatial_concentration\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n//2))\n        p = random.randint(0, n - k)\n        segment = new_solution[p:p+k]\n        rotated = np.roll(segment, random.randint(1, k-1))\n        new_solution[p:p+k] = rotated\n\n        # Multi-objective edge swapping\n        swap_prob = 0.3 + 0.7 * (objectives[selected_idx][0] / (objectives[:,0].max() + 1e-8))\n        if random.random() < swap_prob:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-2)\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n            )\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.770218409641874,
            1.6702340245246887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and spatial concentration\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.std(objectives, axis=0)\n    spatial_concentration = np.array([np.mean(np.linalg.norm(instance[sol[:-1], :2] - instance[sol[1:], :2], axis=1)) for sol, _ in archive])\n    combined_scores = 0.6 * obj_diversity[0] + 0.4 * obj_diversity[1] + 0.2 * spatial_concentration\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n//2))\n        p = random.randint(0, n - k)\n        segment = new_solution[p:p+k]\n        rotated = np.roll(segment, random.randint(1, k-1))\n        new_solution[p:p+k] = rotated\n\n        # Multi-objective edge swapping\n        swap_prob = 0.3 + 0.7 * (objectives[selected_idx][0] / (objectives[:,0].max() + 1e-8))\n        if random.random() < swap_prob:\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-2)\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n            )\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search combining edge flipping, segment rotation, and probabilistic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j] = rotated_segment\n\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        if random.random() < 0.3:\n            other_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n            other_solution = archive[other_idx][0]\n            a, b = sorted(random.sample(range(n), 2))\n            for node in other_solution[a:b]:\n                if node not in new_solution:\n                    pos = random.randint(0, n-1)\n                    new_solution = np.insert(new_solution, pos, node)\n                    break\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6811877037762744,
            0.23768842220306396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:j] = rotated_segment\n\n        k, l = sorted(random.sample(range(n), 2))\n        if k != l:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        if random.random() < 0.3:\n            other_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n            other_solution = archive[other_idx][0]\n            a, b = sorted(random.sample(range(n), 2))\n            for node in other_solution[a:b]:\n                if node not in new_solution:\n                    pos = random.randint(0, n-1)\n                    new_solution = np.insert(new_solution, pos, node)\n                    break\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search operator combining segment reversal, node insertion, and a guided segment exchange with a randomly selected segment from another solution to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.5, 0.5]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with guided selection\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion with guided selection\n    if n > 2:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Guided segment exchange with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c + len(segment):]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8370999596649463,
            0.3806726336479187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.5, 0.5]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal with guided selection\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion with guided selection\n    if n > 2:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Guided segment exchange with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c + len(segment):]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution from the archive using a combined objective score, then applies a hybrid local search combining edge swaps, node relocations, and a partial solution exchange with another archive solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swaps, node relocations, and partial exchange\n    # Step 1: Edge swaps\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[d], new_solution[a] = new_solution[a], new_solution[d]\n\n    # Step 2: Node relocations\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Partial solution exchange\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        split_point = random.randint(1, n-1)\n        new_solution[split_point:] = other_solution[split_point:]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9320404195117866,
            0.12828481197357178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge swaps, node relocations, and partial exchange\n    # Step 1: Edge swaps\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[d], new_solution[a] = new_solution[a], new_solution[d]\n\n    # Step 2: Node relocations\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Partial solution exchange\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        split_point = random.randint(1, n-1)\n        new_solution[split_point:] = other_solution[split_point:]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid dominance score that combines Pareto efficiency and objective normalization, then applies a novel segment exchange and crossover operator with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid dominance scores\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != scored_solutions[0][1].tolist() == archive[i][0].tolist()])\n        other_solution = archive[other_idx][0]\n\n        # Segment exchange and crossover\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b]\n        segment2 = other_solution[c:d]\n\n        # Create new segments by combining parts of both segments\n        new_segment = np.concatenate([segment1[:len(segment1)//2], segment2[len(segment2)//2:]])\n\n        # Insert the new segment at a random position\n        insert_pos = random.randint(0, n - len(new_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_segment,\n            new_solution[insert_pos + len(new_segment):]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing = set(range(n)) - set(unique_nodes)\n            for node in missing:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7553888397745848,
            0.1497136950492859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid dominance scores\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != scored_solutions[0][1].tolist() == archive[i][0].tolist()])\n        other_solution = archive[other_idx][0]\n\n        # Segment exchange and crossover\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b]\n        segment2 = other_solution[c:d]\n\n        # Create new segments by combining parts of both segments\n        new_segment = np.concatenate([segment1[:len(segment1)//2], segment2[len(segment2)//2:]])\n\n        # Insert the new segment at a random position\n        insert_pos = random.randint(0, n - len(new_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_segment,\n            new_solution[insert_pos + len(new_segment):]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing = set(range(n)) - set(unique_nodes)\n            for node in missing:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection metric combining normalized objective values and solution diversity, then applies a novel local search operator combining a partial tour reversal with a segment-based edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        # Calculate solution diversity based on node order differences\n        diversity = sum(1 for i in range(len(sol)) if sol[i] != archive[0][0][i]) / len(sol)\n        score = 0.4 * norm_obj1 + 0.4 * norm_obj2 + 0.2 * diversity\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Partial tour reversal with segment-based edge exchange\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Select another random segment and exchange edges between them\n        c, d = sorted(random.sample(range(n), 2))\n        while c == a and d == b:  # Ensure different segments\n            c, d = sorted(random.sample(range(n), 2))\n\n        # Exchange edges between segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        if len(segment1) > 0 and len(segment2) > 0:\n            # Swap first and last nodes of segments\n            new_solution[a], new_solution[b-1] = new_solution[b-1], new_solution[a]\n            new_solution[c], new_solution[d-1] = new_solution[d-1], new_solution[c]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8085300335180451,
            0.39509838819503784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        # Calculate solution diversity based on node order differences\n        diversity = sum(1 for i in range(len(sol)) if sol[i] != archive[0][0][i]) / len(sol)\n        score = 0.4 * norm_obj1 + 0.4 * norm_obj2 + 0.2 * diversity\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Partial tour reversal with segment-based edge exchange\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Select another random segment and exchange edges between them\n        c, d = sorted(random.sample(range(n), 2))\n        while c == a and d == b:  # Ensure different segments\n            c, d = sorted(random.sample(range(n), 2))\n\n        # Exchange edges between segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        if len(segment1) > 0 and len(segment2) > 0:\n            # Swap first and last nodes of segments\n            new_solution[a], new_solution[b-1] = new_solution[b-1], new_solution[a]\n            new_solution[c], new_solution[d-1] = new_solution[d-1], new_solution[c]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.5:  # 50% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8265056462936955,
            0.4405598044395447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.5:  # 50% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator combining segment inversion with a probabilistic node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    objectives = [obj for (sol, obj) in archive]\n    normalized_costs = np.array(objectives) / np.max(objectives, axis=0)\n    diversity_weights = np.linspace(1.0, 0.5, len(archive))\n    combined_scores = (normalized_costs[:, 0] * 0.4 + normalized_costs[:, 1] * 0.6) * diversity_weights\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment inversion with probabilistic node swapping\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        inverted_segment = segment[::-1]\n\n        # Probabilistically swap nodes between original and inverted segments\n        for i in range(len(segment)):\n            if random.random() < 0.2:\n                inverted_segment[i], segment[i] = segment[i], inverted_segment[i]\n\n        new_solution[a:b] = inverted_segment\n\n        # Additional probabilistic node swaps\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7879427257770086,
            0.41909176111221313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    objectives = [obj for (sol, obj) in archive]\n    normalized_costs = np.array(objectives) / np.max(objectives, axis=0)\n    diversity_weights = np.linspace(1.0, 0.5, len(archive))\n    combined_scores = (normalized_costs[:, 0] * 0.4 + normalized_costs[:, 1] * 0.6) * diversity_weights\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment inversion with probabilistic node swapping\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        inverted_segment = segment[::-1]\n\n        # Probabilistically swap nodes between original and inverted segments\n        for i in range(len(segment)):\n            if random.random() < 0.2:\n                inverted_segment[i], segment[i] = segment[i], inverted_segment[i]\n\n        new_solution[a:b] = inverted_segment\n\n        # Additional probabilistic node swaps\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a novel hybrid local search combining edge swaps, segment rotations, and partial path replacements to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Edge swap with probability\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Step 3: Partial path replacement\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = other_solution[start:end]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9512208592695832,
            0.11869055032730103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Edge swap with probability\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Step 3: Partial path replacement\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = other_solution[start:end]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{The new algorithm selects a solution from the archive based on a novel hybrid selection metric combining objective diversity and solution quality, then applies a combination of a multi-edge swap with a dynamic segment relocation operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    hybrid_scores = []\n    for sol, obj in archive:\n        # Calculate objective diversity (spread in objective space)\n        diversity = (obj[0] - obj[1])**2\n        # Calculate solution quality (inverse of weighted sum)\n        quality = 1 / (0.5 * obj[0] + 0.5 * obj[1] + 1e-6)\n        hybrid_scores.append(diversity * quality)\n\n    # Select solution with highest hybrid score\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-edge swap operation: select 3 edges and perform a cyclic swap\n        indices = sorted(random.sample(range(n), 3))\n        i, j, k = indices[0], indices[1], indices[2]\n\n        # Perform cyclic swap\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Dynamic segment relocation: move a segment to a position that improves both objectives\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        best_pos = -1\n        best_improvement = 0\n\n        # Evaluate potential insertion positions\n        for pos in range(n - len(segment) + 1):\n            if pos >= a and pos <= b:  # Skip current position\n                continue\n\n            # Create temporary solution\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos + len(segment):]\n            ])\n\n            # Calculate improvement in both objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos + len(segment):]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.6859009616658497,
            0.801781415939331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    hybrid_scores = []\n    for sol, obj in archive:\n        # Calculate objective diversity (spread in objective space)\n        diversity = (obj[0] - obj[1])**2\n        # Calculate solution quality (inverse of weighted sum)\n        quality = 1 / (0.5 * obj[0] + 0.5 * obj[1] + 1e-6)\n        hybrid_scores.append(diversity * quality)\n\n    # Select solution with highest hybrid score\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-edge swap operation: select 3 edges and perform a cyclic swap\n        indices = sorted(random.sample(range(n), 3))\n        i, j, k = indices[0], indices[1], indices[2]\n\n        # Perform cyclic swap\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Dynamic segment relocation: move a segment to a position that improves both objectives\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        best_pos = -1\n        best_improvement = 0\n\n        # Evaluate potential insertion positions\n        for pos in range(n - len(segment) + 1):\n            if pos >= a and pos <= b:  # Skip current position\n                continue\n\n            # Create temporary solution\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos + len(segment):]\n            ])\n\n            # Calculate improvement in both objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos + len(segment):]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm prioritizes solutions with high potential for improvement by combining a novel scoring mechanism with a hybrid local search that adaptively selects between edge swaps, insertions, and path relinking based on the solution's current objective values, ensuring feasibility through dynamic repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Custom scoring function: prioritize solutions with high potential for improvement\n    def score(obj):\n        return (obj[0] * 0.7 + obj[1] * 0.3) / (1 + np.sqrt(obj[0] + obj[1]))\n\n    objectives = [obj for (sol, obj) in archive]\n    scores = [score(obj) for obj in objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive hybrid local search\n    if random.random() < 0.4:\n        # Edge swap with high potential improvement\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n    elif random.random() < 0.7:\n        # Insertion with dynamic position selection\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n    else:\n        # Path relinking with adaptive length\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(7, n//2))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if random.random() < 0.4:\n                new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Dynamic feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8335911972025143,
            0.4046284556388855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Custom scoring function: prioritize solutions with high potential for improvement\n    def score(obj):\n        return (obj[0] * 0.7 + obj[1] * 0.3) / (1 + np.sqrt(obj[0] + obj[1]))\n\n    objectives = [obj for (sol, obj) in archive]\n    scores = [score(obj) for obj in objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive hybrid local search\n    if random.random() < 0.4:\n        # Edge swap with high potential improvement\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n    elif random.random() < 0.7:\n        # Insertion with dynamic position selection\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n    else:\n        # Path relinking with adaptive length\n        relink_pos = random.randint(0, n-1)\n        relink_length = random.randint(1, min(7, n//2))\n        for p in range(relink_pos, min(relink_pos + relink_length, n)):\n            if random.random() < 0.4:\n                new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Dynamic feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining segment inversion, node relinking, and adaptive path relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for (sol, obj) in archive]\n    objectives = [obj for (sol, obj) in archive]\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for sol in solutions:\n        total_diversity = 0\n        for i in range(len(sol)):\n            total_diversity += abs(i - np.where(sol == sol[i])[0][0])\n        diversity_scores.append(total_diversity)\n\n    # Combine objective and diversity scores\n    combined_scores = [obj[0] + obj[1] + diversity_scores[i] for i, obj in enumerate(objectives)]\n    selected_idx = combined_scores.index(max(combined_scores))\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    segment_length = min(5, n // 3)\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Node relinking with probability\n    for i in range(n):\n        if random.random() < 0.2:\n            j = random.randint(0, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path relinking\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        relink_length = random.randint(1, min(5, n // 2))\n        relink_pos = random.randint(0, n - relink_length)\n        for i in range(relink_pos, relink_pos + relink_length):\n            if random.random() < 0.4:\n                new_solution[i] = other_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.75744320216777,
            2.5506100058555603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for (sol, obj) in archive]\n    objectives = [obj for (sol, obj) in archive]\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for sol in solutions:\n        total_diversity = 0\n        for i in range(len(sol)):\n            total_diversity += abs(i - np.where(sol == sol[i])[0][0])\n        diversity_scores.append(total_diversity)\n\n    # Combine objective and diversity scores\n    combined_scores = [obj[0] + obj[1] + diversity_scores[i] for i, obj in enumerate(objectives)]\n    selected_idx = combined_scores.index(max(combined_scores))\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    segment_length = min(5, n // 3)\n    start = random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Node relinking with probability\n    for i in range(n):\n        if random.random() < 0.2:\n            j = random.randint(0, n-1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path relinking\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        relink_length = random.randint(1, min(5, n // 2))\n        relink_pos = random.randint(0, n - relink_length)\n        for i in range(relink_pos, relink_pos + relink_length):\n            if random.random() < 0.4:\n                new_solution[i] = other_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based selection, then applies a novel local search operator that combines a multi-segment inversion with a guided edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        num_segments = random.randint(1, min(3, n//2))\n        segments = []\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        # Sort segments by start index\n        segments.sort()\n\n        # Apply inversions in order\n        for a, b in segments:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Guided edge insertion\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n:\n                j = random.randint(0, n-1)\n\n            # Find the best insertion point for node at j\n            best_pos = i\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos != i and pos != (i+1)%n:\n                    temp_sol = new_solution.copy()\n                    node = temp_sol[j]\n                    temp_sol = np.delete(temp_sol, j)\n                    temp_sol = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    total_cost = cost1 + cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n            # Perform the best insertion\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.86145975202005,
            0.6408313512802124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        num_segments = random.randint(1, min(3, n//2))\n        segments = []\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        # Sort segments by start index\n        segments.sort()\n\n        # Apply inversions in order\n        for a, b in segments:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Guided edge insertion\n        if random.random() < 0.5:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            while j == i or j == (i+1)%n:\n                j = random.randint(0, n-1)\n\n            # Find the best insertion point for node at j\n            best_pos = i\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos != i and pos != (i+1)%n:\n                    temp_sol = new_solution.copy()\n                    node = temp_sol[j]\n                    temp_sol = np.delete(temp_sol, j)\n                    temp_sol = np.insert(temp_sol, pos, node)\n                    cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n                    total_cost = cost1 + cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n            # Perform the best insertion\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining segment reversal with a randomized node swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]  # Equal weighting for both objectives\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal: select a segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Randomized node swap: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            for i in range(n):\n                if new_solution[i] not in unique_nodes:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8112755326776173,
            0.18953824043273926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.5 * obj[0] + 0.5 * obj[1]  # Equal weighting for both objectives\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment reversal: select a segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Randomized node swap: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            for i in range(n):\n                if new_solution[i] not in unique_nodes:\n                    new_solution[i] = missing_nodes[0]\n                    missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective ratio and diversity metric, then applies a hybrid local search operator combining a random segment reversal with a conditional edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        obj_ratio = obj[0] / (obj[1] + 1e-6)\n        diversity = np.mean([np.abs(distance_matrix_1[sol[i], sol[i+1]] - distance_matrix_2[sol[i], sol[i+1]]) for i in range(len(sol)-1)])\n        score = obj_ratio + diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Conditional edge swap\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if (j - i) > 1 and random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(base_solution, unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing])\n\n    return new_solution\n\n",
        "score": [
            -0.9603084580960146,
            1.773334264755249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        obj_ratio = obj[0] / (obj[1] + 1e-6)\n        diversity = np.mean([np.abs(distance_matrix_1[sol[i], sol[i+1]] - distance_matrix_2[sol[i], sol[i+1]]) for i in range(len(sol)-1)])\n        score = obj_ratio + diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Random segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Conditional edge swap\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        if (j - i) > 1 and random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = np.setdiff1d(base_solution, unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted normalized objective score with different weights (0.7 for the first objective and 0.3 for the second), then applies a hybrid local search combining edge relocation with a randomized segment reversal and a partial swap operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        operation = random.choice(['reverse', 'swap'])\n\n        if operation == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            insert_pos = random.randint(0, n - len(reversed_segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                reversed_segment,\n                new_solution[insert_pos:]\n            ])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6930974259032149,
            0.19337469339370728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        operation = random.choice(['reverse', 'swap'])\n\n        if operation == 'reverse':\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            insert_pos = random.randint(0, n - len(reversed_segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                reversed_segment,\n                new_solution[insert_pos:]\n            ])\n        else:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined hypervolume contribution and adaptive neighborhood size metric, then applies a novel local search operator combining a variable-length segment relocation with a biased edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n\n    hypervolume = []\n    for i, (_, obj) in enumerate(archive):\n        volume = (max_obj[0] - obj[0]) * (max_obj[1] - obj[1])\n        # Subtract volumes of dominated solutions\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and not np.array_equal(other_obj, obj):\n                volume -= (max_obj[0] - other_obj[0]) * (max_obj[1] - other_obj[1])\n        hypervolume.append(volume)\n\n    # Normalize hypervolume\n    max_hv = max(hypervolume) if hypervolume else 1\n    norm_hv = [hv/max_hv for hv in hypervolume]\n\n    # Adaptive selection based on hypervolume and neighborhood size\n    if norm_hv:\n        prob = [hv * (1 + random.random()) for hv in norm_hv]\n        selected_idx = np.argmax(prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Variable-length segment relocation\n        segment_length = random.randint(2, max(2, n//4))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Biased edge swap based on distance matrices\n        for _ in range(random.randint(1, 3)):\n            i, j = random.sample(range(n), 2)\n            swap_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            swap_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            if (swap_cost1 < original_cost1 and swap_cost2 < original_cost2) or random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8180364886755029,
            0.6268227100372314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n\n    hypervolume = []\n    for i, (_, obj) in enumerate(archive):\n        volume = (max_obj[0] - obj[0]) * (max_obj[1] - obj[1])\n        # Subtract volumes of dominated solutions\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and not np.array_equal(other_obj, obj):\n                volume -= (max_obj[0] - other_obj[0]) * (max_obj[1] - other_obj[1])\n        hypervolume.append(volume)\n\n    # Normalize hypervolume\n    max_hv = max(hypervolume) if hypervolume else 1\n    norm_hv = [hv/max_hv for hv in hypervolume]\n\n    # Adaptive selection based on hypervolume and neighborhood size\n    if norm_hv:\n        prob = [hv * (1 + random.random()) for hv in norm_hv]\n        selected_idx = np.argmax(prob)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Variable-length segment relocation\n        segment_length = random.randint(2, max(2, n//4))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Biased edge swap based on distance matrices\n        for _ in range(random.randint(1, 3)):\n            i, j = random.sample(range(n), 2)\n            swap_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            swap_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            if (swap_cost1 < original_cost1 and swap_cost2 < original_cost2) or random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined objective improvement potential and diversity metric, then applies a hybrid local search operator combining a multi-segment relocation with a probabilistic edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential and diversity\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        improvement_score = 1 - (0.5 * norm_obj1 + 0.5 * norm_obj2)\n        diversity_score = np.sum(np.abs(np.diff(np.argsort(sol))))\n        combined_score = improvement_score * 0.7 + diversity_score * 0.3\n        scores.append((combined_score, sol))\n\n    scores.sort(key=lambda x: x[0], reverse=True)\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment relocation\n        k = random.randint(2, min(5, n//2))\n        segments = []\n        for _ in range(k):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        segments.sort()\n        relocated = []\n        remaining = list(range(n))\n        for a, b in segments:\n            segment = new_solution[a:b]\n            relocated.append(segment)\n            remaining = [x for x in remaining if x not in range(a, b)]\n\n        random.shuffle(relocated)\n        new_solution = np.concatenate([np.concatenate(relocated), new_solution[remaining]])\n\n        # Probabilistic edge exchange\n        for i in range(n):\n            if random.random() < 0.3:\n                j = random.randint(0, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8226585556296799,
            0.25579118728637695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement potential and diversity\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        improvement_score = 1 - (0.5 * norm_obj1 + 0.5 * norm_obj2)\n        diversity_score = np.sum(np.abs(np.diff(np.argsort(sol))))\n        combined_score = improvement_score * 0.7 + diversity_score * 0.3\n        scores.append((combined_score, sol))\n\n    scores.sort(key=lambda x: x[0], reverse=True)\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment relocation\n        k = random.randint(2, min(5, n//2))\n        segments = []\n        for _ in range(k):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append((a, b))\n\n        segments.sort()\n        relocated = []\n        remaining = list(range(n))\n        for a, b in segments:\n            segment = new_solution[a:b]\n            relocated.append(segment)\n            remaining = [x for x in remaining if x not in range(a, b)]\n\n        random.shuffle(relocated)\n        new_solution = np.concatenate([np.concatenate(relocated), new_solution[remaining]])\n\n        # Probabilistic edge exchange\n        for i in range(n):\n            if random.random() < 0.3:\n                j = random.randint(0, n-1)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest combined objective values, then applies a hybrid local search combining edge reversal, node relocation, and path inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge reversal, node relocation, and path inversion\n    n = len(new_solution)\n\n    # Step 1: Edge reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node relocation\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9657345227151419,
            0.2582154870033264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge reversal, node relocation, and path inversion\n    n = len(new_solution)\n\n    # Step 1: Edge reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node relocation\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion\n    if n > 3:\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines segment reversal with cross-solution segment exchange, followed by a probabilistic node insertion to maintain feasibility, ensuring high-quality neighbors while preserving diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [np.sum(np.abs(sol - np.mean([s[0] for s in archive], axis=0))) for (sol, obj) in archive]\n    combined_scores = [0.7 * (obj[0] + obj[1]) + 0.3 * div for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            if random.random() < 0.5:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node)\n            else:\n                new_solution = np.append(new_solution, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8884584282262814,
            1.8016992211341858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [np.sum(np.abs(sol - np.mean([s[0] for s in archive], axis=0))) for (sol, obj) in archive]\n    combined_scores = [0.7 * (obj[0] + obj[1]) + 0.3 * div for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + len(segment):]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            if random.random() < 0.5:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node)\n            else:\n                new_solution = np.append(new_solution, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized objective score combining both objectives with equal weighting, then applies a hybrid local search combining a randomized edge swap with a segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    min_obj1, max_obj1 = min(obj1), max(obj1)\n    min_obj2, max_obj2 = min(obj2), max(obj2)\n\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-10)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-10)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2\n        scores.append((score, i))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = archive[scores[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomized edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8145940577183739,
            0.19849896430969238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1 = [obj[0] for _, obj in archive]\n    obj2 = [obj[1] for _, obj in archive]\n    min_obj1, max_obj1 = min(obj1), max(obj1)\n    min_obj2, max_obj2 = min(obj2), max(obj2)\n\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-10)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-10)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2\n        scores.append((score, i))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = archive[scores[0][1]][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Randomized edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted sum for different objective importance\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7670345244598653,
            0.19748347997665405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted sum for different objective importance\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a hybrid local search combining segment relocation, node swapping with distance-based probability, and objective-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    if n == 1:\n        selected_idx = 0\n    else:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(n)\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_indices, m]\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, n-1):\n                crowding[sorted_indices[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select solution with highest crowding distance (most isolated in objective space)\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation, distance-based swapping, and objective-aware insertion\n    if n > 4:\n        # Segment relocation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # Distance-based node swapping\n        for i in range(n):\n            j = random.randint(0, n-1)\n            if i != j and random.random() < 0.5:\n                # Swap probability based on distance in both objectives\n                d1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]]\n                d1_new = distance_matrix_1[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                d2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]]\n                d2_new = distance_matrix_2[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n                if (d1_new < d1 and d2_new < d2) or random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware edge insertion\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Insert node j before node i if it improves both objectives\n                d1_old = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                d1_new = distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                d2_old = distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                d2_new = distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                if (d1_new < d1_old and d2_new < d2_old) or random.random() < 0.3:\n                    # Perform insertion\n                    if j > i:\n                        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n                    else:\n                        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i], [new_solution[j]], new_solution[i:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8958605766469212,
            0.2701535224914551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on crowding distance and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    n = len(archive)\n\n    if n == 1:\n        selected_idx = 0\n    else:\n        # Calculate crowding distance for each solution\n        crowding = np.zeros(n)\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_indices, m]\n            crowding[sorted_indices[0]] = np.inf\n            crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, n-1):\n                crowding[sorted_indices[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0] + 1e-10)\n\n        # Select solution with highest crowding distance (most isolated in objective space)\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation, distance-based swapping, and objective-aware insertion\n    if n > 4:\n        # Segment relocation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # Distance-based node swapping\n        for i in range(n):\n            j = random.randint(0, n-1)\n            if i != j and random.random() < 0.5:\n                # Swap probability based on distance in both objectives\n                d1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]]\n                d1_new = distance_matrix_1[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                d2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]]\n                d2_new = distance_matrix_2[new_solution[j], new_solution[(i-1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n                if (d1_new < d1 and d2_new < d2) or random.random() < 0.2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware edge insertion\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Insert node j before node i if it improves both objectives\n                d1_old = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                d1_new = distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                d2_old = distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                d2_new = distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                if (d1_new < d1_old and d2_new < d2_old) or random.random() < 0.3:\n                    # Perform insertion\n                    if j > i:\n                        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n                    else:\n                        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i], [new_solution[j]], new_solution[i:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a partial path reversal and a randomized edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n\n    crowding = {}\n    for sol, _ in archive:\n        sol_str = str(sol)\n        crowding[sol_str] = 0.0\n\n    # Calculate crowding distance for first objective\n    for i in range(1, len(sorted_obj1) - 1):\n        sol = sorted_obj1[i][0]\n        prev = sorted_obj1[i-1][1][0]\n        next = sorted_obj1[i+1][1][0]\n        crowding[str(sol)] += (next - prev) / (sorted_obj1[-1][1][0] - sorted_obj1[0][1][0] + 1e-6)\n\n    # Calculate crowding distance for second objective\n    for i in range(1, len(sorted_obj2) - 1):\n        sol = sorted_obj2[i][0]\n        prev = sorted_obj2[i-1][1][1]\n        next = sorted_obj2[i+1][1][1]\n        crowding[str(sol)] += (next - prev) / (sorted_obj2[-1][1][1] - sorted_obj2[0][1][1] + 1e-6)\n\n    # Select solution with highest crowding distance\n    selected_sol = max(archive, key=lambda x: crowding[str(x[0])])[0].copy()\n\n    # Hybrid local search: partial path reversal and randomized edge insertion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Partial path reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Randomized edge insertion: move a random edge to a new position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Extract the edge (i, i+1) and insert it after j\n        edge = new_solution[i:i+2]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+2:]])\n        new_solution = np.concatenate([new_solution[:j+1], edge, new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(selected_sol, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8106033134890618,
            7.89097797870636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n\n    crowding = {}\n    for sol, _ in archive:\n        sol_str = str(sol)\n        crowding[sol_str] = 0.0\n\n    # Calculate crowding distance for first objective\n    for i in range(1, len(sorted_obj1) - 1):\n        sol = sorted_obj1[i][0]\n        prev = sorted_obj1[i-1][1][0]\n        next = sorted_obj1[i+1][1][0]\n        crowding[str(sol)] += (next - prev) / (sorted_obj1[-1][1][0] - sorted_obj1[0][1][0] + 1e-6)\n\n    # Calculate crowding distance for second objective\n    for i in range(1, len(sorted_obj2) - 1):\n        sol = sorted_obj2[i][0]\n        prev = sorted_obj2[i-1][1][1]\n        next = sorted_obj2[i+1][1][1]\n        crowding[str(sol)] += (next - prev) / (sorted_obj2[-1][1][1] - sorted_obj2[0][1][1] + 1e-6)\n\n    # Select solution with highest crowding distance\n    selected_sol = max(archive, key=lambda x: crowding[str(x[0])])[0].copy()\n\n    # Hybrid local search: partial path reversal and randomized edge insertion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Partial path reversal: reverse a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Randomized edge insertion: move a random edge to a new position\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Extract the edge (i, i+1) and insert it after j\n        edge = new_solution[i:i+2]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+2:]])\n        new_solution = np.concatenate([new_solution[:j+1], edge, new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(selected_sol, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined hypervolume contribution and adaptive neighborhood selection metric, then applies a novel local search operator combining a k-swap operation with a partial reversal and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    reference_point = (max(obj[0] for _, obj in archive), max(obj[1] for _, obj in archive))\n    hypervolumes = []\n    for sol, obj in archive:\n        dominated = False\n        volume = (reference_point[0] - obj[0]) * (reference_point[1] - obj[1])\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            hypervolumes.append(volume)\n        else:\n            hypervolumes.append(0)\n\n    # Select solution with highest hypervolume contribution\n    max_hv_idx = np.argmax(hypervolumes)\n    base_solution = archive[max_hv_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # k-swap operation: randomly select k non-adjacent edges and perform a cyclic permutation\n        k = random.randint(2, min(5, n//2))\n        indices = random.sample(range(n), k)\n        indices.sort()\n\n        # Perform cyclic permutation\n        for i in range(k):\n            new_solution[indices[i]] = base_solution[indices[(i+1)%k]]\n\n        # Partial reversal and segment relocation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9478346309286598,
            0.2039692997932434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    reference_point = (max(obj[0] for _, obj in archive), max(obj[1] for _, obj in archive))\n    hypervolumes = []\n    for sol, obj in archive:\n        dominated = False\n        volume = (reference_point[0] - obj[0]) * (reference_point[1] - obj[1])\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            hypervolumes.append(volume)\n        else:\n            hypervolumes.append(0)\n\n    # Select solution with highest hypervolume contribution\n    max_hv_idx = np.argmax(hypervolumes)\n    base_solution = archive[max_hv_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # k-swap operation: randomly select k non-adjacent edges and perform a cyclic permutation\n        k = random.randint(2, min(5, n//2))\n        indices = random.sample(range(n), k)\n        indices.sort()\n\n        # Perform cyclic permutation\n        for i in range(k):\n            new_solution[indices[i]] = base_solution[indices[(i+1)%k]]\n\n        # Partial reversal and segment relocation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and tour structure complexity, then applies a hybrid local search combining segment crossover, node swapping with objective-aware selection, and selective segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour complexity\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = obj_ranges[0] * obj_ranges[1] / (np.sum(obj_ranges) + 1e-10)\n\n    tour_lengths = []\n    for sol, _ in archive:\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        tour_lengths.append(cost1 + cost2)\n\n    complexity_scores = np.array(tour_lengths) * diversity_scores\n    selected_idx = np.argmax(complexity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment crossover, objective-aware node swapping, and selective segment reversal\n    if n > 4:\n        # Segment crossover\n        crossover_point = random.randint(1, n-2)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Objective-aware node swapping\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            new_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            if (new_obj1 > obj1 and new_obj2 > obj2) or (new_obj1 < obj1 and new_obj2 < obj2):\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n        # Selective segment reversal\n        if random.random() < 0.4:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            new_obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            new_obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if new_obj1 > obj1 or new_obj2 > obj2:\n                new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8976971711342268,
            2.131782591342926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective diversity and tour complexity\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    diversity_scores = obj_ranges[0] * obj_ranges[1] / (np.sum(obj_ranges) + 1e-10)\n\n    tour_lengths = []\n    for sol, _ in archive:\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]\n        tour_lengths.append(cost1 + cost2)\n\n    complexity_scores = np.array(tour_lengths) * diversity_scores\n    selected_idx = np.argmax(complexity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment crossover, objective-aware node swapping, and selective segment reversal\n    if n > 4:\n        # Segment crossover\n        crossover_point = random.randint(1, n-2)\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Objective-aware node swapping\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            new_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            if (new_obj1 > obj1 and new_obj2 > obj2) or (new_obj1 < obj1 and new_obj2 < obj2):\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n        # Selective segment reversal\n        if random.random() < 0.4:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            new_obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            new_obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if new_obj1 > obj1 or new_obj2 > obj2:\n                new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment rotation, node relocation, and a novel path inversion technique to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Node relocation\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    # Find a segment where average distance is below average\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg < avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal with distance-based selection, node swapping with objective-aware selection, and a novel segment insertion technique to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg > avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Step 2: Node swapping with objective-aware selection\n    if found:\n        i, j = sorted(random.sample(range(n), 2))\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement for each objective\n        delta1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        if delta1 + delta2 < 0:  # If swap improves at least one objective\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Segment insertion with distance-based selection\n    if random.random() < 0.5:  # 50% chance to perform this operation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8653882446468124,
            0.29120147228240967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment reversal with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg > avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Step 2: Node swapping with objective-aware selection\n    if found:\n        i, j = sorted(random.sample(range(n), 2))\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate potential improvement for each objective\n        delta1 = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], node_i] + distance_matrix_1[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[j-1], node_j] + distance_matrix_1[node_j, new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], node_i] + distance_matrix_2[node_i, new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[j-1], node_j] + distance_matrix_2[node_j, new_solution[(j+1)%n]])\n\n        if delta1 + delta2 < 0:  # If swap improves at least one objective\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Segment insertion with distance-based selection\n    if random.random() < 0.5:  # 50% chance to perform this operation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining adaptive segment shuffling and probabilistic edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n    np.fill_diagonal(distances, np.inf)\n    selected_idx = np.argmax(np.min(distances, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic edge insertion\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            if random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        new_solution[:len(missing_nodes)] = missing_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.9230038145199833,
            0.3547779321670532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    distances = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n    np.fill_diagonal(distances, np.inf)\n    selected_idx = np.argmax(np.min(distances, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    if n > 3:\n        k = random.randint(2, min(5, n//2))\n        segments = np.array_split(new_solution, k)\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic edge insertion\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            if random.random() < 0.7:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        new_solution[:len(missing_nodes)] = missing_nodes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.034260056950912,
            0.3394010066986084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.034260056950912,
            0.3394010066986084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to promote diversity, then applies a hybrid local search combining segment reversal with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = [obj for (_, obj) in archive]\n    n = len(solutions[0])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left = float('inf')\n        right = float('inf')\n        for j in range(len(objectives)):\n            if objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]:\n                left = min(left, objectives[i][0] - objectives[j][0] + objectives[i][1] - objectives[j][1])\n            if objectives[j][0] >= objectives[i][0] and objectives[j][1] > objectives[i][1]:\n                right = min(right, objectives[j][0] - objectives[i][0] + objectives[j][1] - objectives[i][1])\n        crowding_distances.append(left + right)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = solutions[other_idx]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7592068507470764,
            2.868886351585388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = [obj for (_, obj) in archive]\n    n = len(solutions[0])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left = float('inf')\n        right = float('inf')\n        for j in range(len(objectives)):\n            if objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]:\n                left = min(left, objectives[i][0] - objectives[j][0] + objectives[i][1] - objectives[j][1])\n            if objectives[j][0] >= objectives[i][0] and objectives[j][1] > objectives[i][1]:\n                right = min(right, objectives[j][0] - objectives[i][0] + objectives[j][1] - objectives[i][1])\n        crowding_distances.append(left + right)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = solutions[other_idx]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance, tour structure diversity, and crowding distance, then applies a hybrid local search combining segment reversal, edge insertion, and selective 2-opt to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance, diversity, and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select based on crowding distance for better exploration\n        if len(pareto_front) > 1:\n            sorted_front = sorted(pareto_front, key=lambda x: (objectives[x][0], objectives[x][1]))\n            crowding_distances = np.zeros(len(sorted_front))\n            for m in range(2):\n                sorted_indices = np.argsort(objectives[sorted_front, m])\n                crowding_distances[sorted_indices[0]] = np.inf\n                crowding_distances[sorted_indices[-1]] = np.inf\n                for i in range(1, len(sorted_front)-1):\n                    crowding_distances[sorted_indices[i]] += (objectives[sorted_front[sorted_indices[i+1]], m] - objectives[sorted_front[sorted_indices[i-1]], m]) / (objectives[sorted_front[-1], m] - objectives[sorted_front[0], m] + 1e-10)\n            selected_idx = sorted_front[np.argmax(crowding_distances)]\n        else:\n            selected_idx = pareto_front[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, edge insertion, and selective 2-opt\n    if n > 6:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Edge insertion\n        c, d = sorted(random.sample(range(n), 2))\n        if c != d:\n            node = new_solution[d]\n            new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n        # Selective 2-opt\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9898685773186614,
            0.35607004165649414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance, diversity, and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        # Select based on crowding distance for better exploration\n        if len(pareto_front) > 1:\n            sorted_front = sorted(pareto_front, key=lambda x: (objectives[x][0], objectives[x][1]))\n            crowding_distances = np.zeros(len(sorted_front))\n            for m in range(2):\n                sorted_indices = np.argsort(objectives[sorted_front, m])\n                crowding_distances[sorted_indices[0]] = np.inf\n                crowding_distances[sorted_indices[-1]] = np.inf\n                for i in range(1, len(sorted_front)-1):\n                    crowding_distances[sorted_indices[i]] += (objectives[sorted_front[sorted_indices[i+1]], m] - objectives[sorted_front[sorted_indices[i-1]], m]) / (objectives[sorted_front[-1], m] - objectives[sorted_front[0], m] + 1e-10)\n            selected_idx = sorted_front[np.argmax(crowding_distances)]\n        else:\n            selected_idx = pareto_front[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, edge insertion, and selective 2-opt\n    if n > 6:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Edge insertion\n        c, d = sorted(random.sample(range(n), 2))\n        if c != d:\n            node = new_solution[d]\n            new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n        # Selective 2-opt\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances exploitation and exploration, then applies a hybrid local search combining randomized segment transposition with a probabilistic edge swap operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity-aware scores\n    objectives = [obj for (sol, obj) in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n\n    scored_solutions = []\n    for idx, (sol, obj) in enumerate(archive):\n        diversity_score = (obj[0] - mean_obj1)**2 + (obj[1] - mean_obj2)**2\n        quality_score = 0.3 * obj[0] + 0.7 * obj[1]\n        combined_score = diversity_score * quality_score\n        scored_solutions.append((combined_score, idx))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    selected_idx = scored_solutions[0][1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment transposition with probabilistic edge swap\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Transpose the segment\n        new_solution = np.concatenate([\n            new_solution[:k],\n            segment,\n            new_solution[k:l],\n            new_solution[l:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                swap_pos = random.randint(a + 1, b - 1)\n                new_solution[a], new_solution[swap_pos] = new_solution[swap_pos], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8724735947611839,
            0.1887667179107666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate diversity-aware scores\n    objectives = [obj for (sol, obj) in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n\n    scored_solutions = []\n    for idx, (sol, obj) in enumerate(archive):\n        diversity_score = (obj[0] - mean_obj1)**2 + (obj[1] - mean_obj2)**2\n        quality_score = 0.3 * obj[0] + 0.7 * obj[1]\n        combined_score = diversity_score * quality_score\n        scored_solutions.append((combined_score, idx))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    selected_idx = scored_solutions[0][1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment transposition with probabilistic edge swap\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Transpose the segment\n        new_solution = np.concatenate([\n            new_solution[:k],\n            segment,\n            new_solution[k:l],\n            new_solution[l:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:\n            a, b = sorted(random.sample(range(n), 2))\n            if b - a > 1:\n                swap_pos = random.randint(a + 1, b - 1)\n                new_solution[a], new_solution[swap_pos] = new_solution[swap_pos], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and diversity metrics, then applies a hybrid local search operator combining a random k-swap with a segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized, weights)\n\n    # Calculate diversity contribution\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            diversity[i] += np.sum(archive[i][0] != archive[j][0]) / len(archive[i][0])\n\n    # Combine scores and diversity\n    combined_scores = 0.7 * scores + 0.3 * diversity\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Random k-swap (k=3)\n        k = min(3, n // 2)\n        indices = random.sample(range(n), k)\n        for i in range(k):\n            j = random.randint(0, n-1)\n            new_solution[indices[i]], new_solution[j] = new_solution[j], new_solution[indices[i]]\n\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8985010136363523,
            7.327829539775848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized, weights)\n\n    # Calculate diversity contribution\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            diversity[i] += np.sum(archive[i][0] != archive[j][0]) / len(archive[i][0])\n\n    # Combine scores and diversity\n    combined_scores = 0.7 * scores + 0.3 * diversity\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Random k-swap (k=3)\n        k = min(3, n // 2)\n        indices = random.sample(range(n), k)\n        for i in range(k):\n            j = random.randint(0, n-1)\n            new_solution[indices[i]], new_solution[j] = new_solution[j], new_solution[indices[i]]\n\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive, then applies a novel segment-based local search that combines partial reversals, node relocations, and objective-aware edge swaps to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the best in Pareto front\n    objectives = [obj for (sol, obj) in archive]\n    pareto_front = []\n    for i, obj1 in enumerate(objectives):\n        dominated = False\n        for j, obj2 in enumerate(objectives):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin([sum(obj) for obj in objectives])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Partial reversal with probability based on objective improvement potential\n    obj1_diff = abs(distance_matrix_1[segment[-1], segment[0]] - distance_matrix_1[base_solution[start-1], segment[0]])\n    obj2_diff = abs(distance_matrix_2[segment[-1], segment[0]] - distance_matrix_2[base_solution[start-1], segment[0]])\n    if (obj1_diff + obj2_diff) > 0 and random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Relocate segment to a new position\n    new_pos = random.randint(0, n - segment_size)\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_size:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                              (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                              (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            if (obj1_improvement < 0 or obj2_improvement < 0) and random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8533457951939284,
            0.11149489879608154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available, otherwise select the best in Pareto front\n    objectives = [obj for (sol, obj) in archive]\n    pareto_front = []\n    for i, obj1 in enumerate(objectives):\n        dominated = False\n        for j, obj2 in enumerate(objectives):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin([sum(obj) for obj in objectives])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    segment_size = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Partial reversal with probability based on objective improvement potential\n    obj1_diff = abs(distance_matrix_1[segment[-1], segment[0]] - distance_matrix_1[base_solution[start-1], segment[0]])\n    obj2_diff = abs(distance_matrix_2[segment[-1], segment[0]] - distance_matrix_2[base_solution[start-1], segment[0]])\n    if (obj1_diff + obj2_diff) > 0 and random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Relocate segment to a new position\n    new_pos = random.randint(0, n - segment_size)\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_size:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    # Objective-aware edge swaps\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                              (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n            obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                               distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                              (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                               distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            if (obj1_improvement < 0 or obj2_improvement < 0) and random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment rotation, node relocation, and a novel path inversion technique to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Node relocation\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    # Find a segment where average distance is below average\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg < avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest dominance count (number of solutions it dominates), then applies a hybrid local search combining segment reversal, node swap, and a novel segment shift operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance count\n    objectives = [obj for (sol, obj) in archive]\n    dominance_counts = []\n    for i, obj1 in enumerate(objectives):\n        count = 0\n        for obj2 in objectives:\n            if (obj1[0] <= obj2[0] and obj1[1] < obj2[1]) or (obj1[0] < obj2[0] and obj1[1] <= obj2[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Node swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Segment shift with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg > avg_dist:\n            shift = random.randint(1, min(5, n-(b-a)))\n            segment = new_solution[a:b+1]\n            new_solution = np.delete(new_solution, np.s_[a:b+1])\n            new_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, new_pos, segment)\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.920129506592801,
            0.2577320337295532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance count\n    objectives = [obj for (sol, obj) in archive]\n    dominance_counts = []\n    for i, obj1 in enumerate(objectives):\n        count = 0\n        for obj2 in objectives:\n            if (obj1[0] <= obj2[0] and obj1[1] < obj2[1]) or (obj1[0] < obj2[0] and obj1[1] <= obj2[1]):\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Node swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Segment shift with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg > avg_dist:\n            shift = random.randint(1, min(5, n-(b-a)))\n            segment = new_solution[a:b+1]\n            new_solution = np.delete(new_solution, np.s_[a:b+1])\n            new_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, new_pos, segment)\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment rotation, node relocation, and a novel path inversion technique to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Node relocation\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    # Find a segment where average distance is below average\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg < avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest diversity (measured by the number of unique node sequences in segments) and applies a novel hybrid local search combining segment swapping, intra-segment reversal, and a distance-aware segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (measured by unique segments)\n    diversity_scores = []\n    for sol, _ in archive:\n        segments = [tuple(sol[i:i+3]) for i in range(len(sol)-2)]\n        diversity = len(set(segments))\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment swapping\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[a:a+2]\n        segment2 = new_solution[b:b+2]\n        new_solution[a:a+2] = segment2\n        new_solution[b:b+2] = segment1\n\n    # Step 2: Intra-segment reversal\n    if n > 3:\n        i = random.randint(1, n-3)\n        segment_length = random.randint(2, min(4, n-i-1))\n        new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Step 3: Distance-aware segment insertion\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    for _ in range(5):\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j+1]\n        segment_dist1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        segment_dist2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (len(segment)-1))\n\n        if segment_avg < avg_dist:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            insert_pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9761817650901832,
            2.1677595376968384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (measured by unique segments)\n    diversity_scores = []\n    for sol, _ in archive:\n        segments = [tuple(sol[i:i+3]) for i in range(len(sol)-2)]\n        diversity = len(set(segments))\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment swapping\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[a:a+2]\n        segment2 = new_solution[b:b+2]\n        new_solution[a:a+2] = segment2\n        new_solution[b:b+2] = segment1\n\n    # Step 2: Intra-segment reversal\n    if n > 3:\n        i = random.randint(1, n-3)\n        segment_length = random.randint(2, min(4, n-i-1))\n        new_solution[i:i+segment_length] = new_solution[i:i+segment_length][::-1]\n\n    # Step 3: Distance-aware segment insertion\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    for _ in range(5):\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j+1]\n        segment_dist1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        segment_dist2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (len(segment)-1))\n\n        if segment_avg < avg_dist:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            insert_pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hypervolume-based selection criterion, then applies a hybrid local search combining adaptive segment crossover and randomized edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1\n    contributions = []\n    for i in range(len(archive)):\n        mask = np.ones(len(archive), dtype=bool)\n        mask[i] = False\n        dominated = np.all(objectives[mask] <= objectives[i], axis=1)\n        if not np.any(dominated):\n            contributions.append(0)\n        else:\n            dominated_indices = np.where(mask)[0][dominated]\n            hypervolume = np.prod(ref_point - objectives[i])\n            contributions.append(hypervolume)\n\n    selected_idx = np.argmax(contributions)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover\n    if n > 4:\n        # Select a random segment from base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find a compatible insertion point in the instance space\n        for i in range(n):\n            if i not in segment:\n                # Check if inserting the segment here improves both objectives\n                temp_sol = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n                temp_obj1 = sum(distance_matrix_1[temp_sol[j], temp_sol[j+1]] for j in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                temp_obj2 = sum(distance_matrix_2[temp_sol[j], temp_sol[j+1]] for j in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n                if temp_obj1 < sum(distance_matrix_1[base_solution[j], base_solution[j+1]] for j in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]:\n                    new_solution = temp_sol\n                    break\n\n    # Randomized edge insertion\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [new_solution[i]],\n            new_solution[insert_pos:insert_pos + (j-i)],\n            new_solution[insert_pos + (j-i):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.0037646458423093,
            2.6282068490982056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1\n    contributions = []\n    for i in range(len(archive)):\n        mask = np.ones(len(archive), dtype=bool)\n        mask[i] = False\n        dominated = np.all(objectives[mask] <= objectives[i], axis=1)\n        if not np.any(dominated):\n            contributions.append(0)\n        else:\n            dominated_indices = np.where(mask)[0][dominated]\n            hypervolume = np.prod(ref_point - objectives[i])\n            contributions.append(hypervolume)\n\n    selected_idx = np.argmax(contributions)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover\n    if n > 4:\n        # Select a random segment from base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find a compatible insertion point in the instance space\n        for i in range(n):\n            if i not in segment:\n                # Check if inserting the segment here improves both objectives\n                temp_sol = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n                temp_obj1 = sum(distance_matrix_1[temp_sol[j], temp_sol[j+1]] for j in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                temp_obj2 = sum(distance_matrix_2[temp_sol[j], temp_sol[j+1]] for j in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n                if temp_obj1 < sum(distance_matrix_1[base_solution[j], base_solution[j+1]] for j in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]:\n                    new_solution = temp_sol\n                    break\n\n    # Randomized edge insertion\n    if n > 3:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Insert edge (i,j) at a random position\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            [new_solution[i]],\n            new_solution[insert_pos:insert_pos + (j-i)],\n            new_solution[insert_pos + (j-i):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9042631834964714,
            0.10196608304977417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining segment crossover with a solution from another objective space and a randomized node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            cd1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            cd2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(cd1 + cd2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n        k = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:n//2], new_solution[n//2:][::-1]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9271998603079425,
            0.16437244415283203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            cd1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            cd2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(cd1 + cd2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n        k = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, k)\n        new_solution = np.concatenate([new_solution[:n//2], new_solution[n//2:][::-1]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective values and applies a novel local search combining segment reversals, node relocations, and adaptive edge exchanges to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    seg_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = np.flip(new_solution[start:start+seg_length])\n\n    # Node relocation with distance-based probability\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (dist1_after < dist1_before and dist2_after < dist2_before) or random.random() < 0.2:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7182352486427422,
            0.266255259513855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    seg_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = np.flip(new_solution[start:start+seg_length])\n\n    # Node relocation with distance-based probability\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Adaptive edge exchange based on distance matrices\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (dist1_after < dist1_before and dist2_after < dist2_before) or random.random() < 0.2:\n            new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive based on the least explored region in the objective space, then applies a novel local search combining segment inversion with adaptive node swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the least explored objective combination\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    new_solution[start_pos:start_pos + segment_length] = np.flip(new_solution[start_pos:start_pos + segment_length])\n\n    # Step 2: Adaptive node swapping based on distance matrices\n    for i in range(n):\n        if random.random() < 0.2:\n            j = random.randint(0, n-1)\n            if i != j:\n                # Swap if it improves both objectives\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (random.random() < 0.1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9501963300464237,
            0.21036654710769653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the least explored objective combination\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment inversion with adaptive length\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    new_solution[start_pos:start_pos + segment_length] = np.flip(new_solution[start_pos:start_pos + segment_length])\n\n    # Step 2: Adaptive node swapping based on distance matrices\n    for i in range(n):\n        if random.random() < 0.2:\n            j = random.randint(0, n-1)\n            if i != j:\n                # Swap if it improves both objectives\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (random.random() < 0.1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated regions, then applies a hybrid local search combining a randomized 3-opt move with a segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives) - 1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance (most in non-dominated region)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: 3-opt move with randomized segment inversion\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Perform 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n        # Randomly invert a segment\n        if random.random() < 0.5:\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6841911371576491,
            0.3911115527153015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives) - 1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance (most in non-dominated region)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: 3-opt move with randomized segment inversion\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Perform 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n        # Randomly invert a segment\n        if random.random() < 0.5:\n            start, end = sorted(random.sample(range(n), 2))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment crossover and adaptive edge perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and dominance\n    objectives = [obj for (sol, obj) in archive]\n    obj1_vals = [obj[0] for obj in objectives]\n    obj2_vals = [obj[1] for obj in objectives]\n\n    # Calculate dominance score\n    dominance_scores = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and obj1_vals[i] >= obj1_vals[j] and obj2_vals[i] >= obj2_vals[j]:\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment crossover with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    # Adaptive edge perturbation\n    if n > 3:\n        if random.random() < 0.3:  # 30% chance for edge swap\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-2)\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n            )\n        else:  # Otherwise perform segment inversion\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6727849132609112,
            0.33263128995895386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and dominance\n    objectives = [obj for (sol, obj) in archive]\n    obj1_vals = [obj[0] for obj in objectives]\n    obj2_vals = [obj[1] for obj in objectives]\n\n    # Calculate dominance score\n    dominance_scores = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and obj1_vals[i] >= obj1_vals[j] and obj2_vals[i] >= obj2_vals[j]:\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment crossover with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    # Adaptive edge perturbation\n    if n > 3:\n        if random.random() < 0.3:  # 30% chance for edge swap\n            i = random.randint(0, n-2)\n            j = random.randint(0, n-2)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n-2)\n            new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n            )\n        else:  # Otherwise perform segment inversion\n            a, b = sorted(random.sample(range(n), 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and objective-space diversity metric, then applies a novel local search operator combining a segment exchange with a node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate objective space diversity\n        diversity_scores = []\n        for sol, obj in pareto_front:\n            diversity = 0\n            for i in range(len(obj)):\n                sorted_objs = sorted([o[i] for _, o in pareto_front])\n                if len(sorted_objs) > 2:\n                    pos = sorted_objs.index(obj[i])\n                    if pos > 0 and pos < len(sorted_objs) - 1:\n                        diversity += (obj[i] - sorted_objs[pos-1]) / (sorted_objs[pos+1] - sorted_objs[pos-1] + 1e-6)\n            diversity_scores.append(diversity)\n\n        max_diversity_idx = np.argmax(diversity_scores)\n        base_solution = pareto_front[max_diversity_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment exchange: select two non-overlapping segments and exchange them\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(1, n-2), 2))\n        if a < c:\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n            new_solution = np.concatenate([\n                new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n            ])\n        else:\n            segment1 = new_solution[c:d]\n            segment2 = new_solution[a:b]\n            new_solution = np.concatenate([\n                new_solution[:c], segment2, new_solution[d:a], segment1, new_solution[b:]\n            ])\n\n        # Node reinsertion: remove a random node and insert it at a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8498946447312106,
            0.20893603563308716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate objective space diversity\n        diversity_scores = []\n        for sol, obj in pareto_front:\n            diversity = 0\n            for i in range(len(obj)):\n                sorted_objs = sorted([o[i] for _, o in pareto_front])\n                if len(sorted_objs) > 2:\n                    pos = sorted_objs.index(obj[i])\n                    if pos > 0 and pos < len(sorted_objs) - 1:\n                        diversity += (obj[i] - sorted_objs[pos-1]) / (sorted_objs[pos+1] - sorted_objs[pos-1] + 1e-6)\n            diversity_scores.append(diversity)\n\n        max_diversity_idx = np.argmax(diversity_scores)\n        base_solution = pareto_front[max_diversity_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment exchange: select two non-overlapping segments and exchange them\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(1, n-2), 2))\n        if a < c:\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n            new_solution = np.concatenate([\n                new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n            ])\n        else:\n            segment1 = new_solution[c:d]\n            segment2 = new_solution[a:b]\n            new_solution = np.concatenate([\n                new_solution[:c], segment2, new_solution[d:a], segment1, new_solution[b:]\n            ])\n\n        # Node reinsertion: remove a random node and insert it at a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based selection metric to prioritize non-dominated solutions, then applies a hybrid local search combining segment reversal with a probabilistic node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance-based scores\n    dominance_scores = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j:\n                if obj1[0] <= obj2[0] and obj1[1] <= obj2[1] and (obj1[0] < obj2[0] or obj1[1] < obj2[1]):\n                    dominance_scores[i] += 1\n\n    # Select solution with highest dominance score (most dominating)\n    selected_index = np.argmax(dominance_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.6\n        if random.random() < 0.6:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic node insertion\n        if random.random() < 0.4 and n > 3:\n            node_pos = random.randint(1, n-2)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9757170071593282,
            2.0509917736053467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance-based scores\n    dominance_scores = np.zeros(len(archive))\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j:\n                if obj1[0] <= obj2[0] and obj1[1] <= obj2[1] and (obj1[0] < obj2[0] or obj1[1] < obj2[1]):\n                    dominance_scores[i] += 1\n\n    # Select solution with highest dominance score (most dominating)\n    selected_index = np.argmax(dominance_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.6\n        if random.random() < 0.6:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic node insertion\n        if random.random() < 0.4 and n > 3:\n            node_pos = random.randint(1, n-2)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"multi-objective path insertion\" local search that adaptively selects insertion points based on both distance matrices and objective trade-offs, while ensuring feasibility through careful edge swapping and segment relocation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective value and diversity\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives)\n    normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_index = np.argmax(scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-objective path insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Adaptive insertion point selection\n        candidate_positions = [0, n - len(segment)]\n        if n > 6:\n            candidate_positions.append(random.randint(1, n-2))\n\n        best_insert_pos = None\n        best_score = float('inf')\n\n        for pos in candidate_positions:\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Combine costs with trade-off factor\n            tradeoff = 0.5 if random.random() < 0.5 else 0.3\n            score = tradeoff * cost1 + (1 - tradeoff) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_insert_pos = pos\n\n        if best_insert_pos is not None:\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:]\n            ])\n\n        # Adaptive edge swapping\n        if random.random() < 0.4 and n > 4:\n            swap_indices = sorted(random.sample(range(1, n-1), 2))\n            a, b = swap_indices[0], swap_indices[1]\n\n            # Evaluate both possible swaps\n            original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n            swapped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n            # Accept swap if it improves at least one objective\n            if (swapped_cost1 < original_cost1 or swapped_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8690082996166378,
            0.17835140228271484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective value and diversity\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives)\n    normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized_objectives, axis=1) + np.std(normalized_objectives, axis=1)\n    selected_index = np.argmax(scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-objective path insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Adaptive insertion point selection\n        candidate_positions = [0, n - len(segment)]\n        if n > 6:\n            candidate_positions.append(random.randint(1, n-2))\n\n        best_insert_pos = None\n        best_score = float('inf')\n\n        for pos in candidate_positions:\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Combine costs with trade-off factor\n            tradeoff = 0.5 if random.random() < 0.5 else 0.3\n            score = tradeoff * cost1 + (1 - tradeoff) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_insert_pos = pos\n\n        if best_insert_pos is not None:\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:]\n            ])\n\n        # Adaptive edge swapping\n        if random.random() < 0.4 and n > 4:\n            swap_indices = sorted(random.sample(range(1, n-1), 2))\n            a, b = swap_indices[0], swap_indices[1]\n\n            # Evaluate both possible swaps\n            original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n            swapped_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n            # Accept swap if it improves at least one objective\n            if (swapped_cost1 < original_cost1 or swapped_cost2 < original_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives and distance metrics, then applies a novel hybrid local search combining a multi-segment shuffle with a guided edge insertion from another solution's segment, while ensuring feasibility through a node repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.7, 0.3]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: randomly select 3 segments and shuffle their order\n        segments = []\n        points = sorted(random.sample(range(1, n), 2))\n        segments.append(new_solution[:points[0]])\n        segments.append(new_solution[points[0]:points[1]])\n        segments.append(new_solution[points[1]:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion: select a segment from another solution and insert it at a position that minimizes the combined distance increase\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            a, b = sorted(random.sample(range(n), 2))\n            segment = other_solution[a:b]\n\n            best_pos = 0\n            min_increase = float('inf')\n            for i in range(n - len(segment) + 1):\n                temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n                cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                increase = cost1 + cost2\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = i\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Node repair mechanism to ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        for node in missing:\n            dup_pos = random.choice([i for i, x in enumerate(new_solution) if x in duplicates])\n            new_solution[dup_pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9103969808325134,
            0.37049418687820435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.7, 0.3]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: randomly select 3 segments and shuffle their order\n        segments = []\n        points = sorted(random.sample(range(1, n), 2))\n        segments.append(new_solution[:points[0]])\n        segments.append(new_solution[points[0]:points[1]])\n        segments.append(new_solution[points[1]:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion: select a segment from another solution and insert it at a position that minimizes the combined distance increase\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            a, b = sorted(random.sample(range(n), 2))\n            segment = other_solution[a:b]\n\n            best_pos = 0\n            min_increase = float('inf')\n            for i in range(n - len(segment) + 1):\n                temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n                cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n))\n                increase = cost1 + cost2\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = i\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Node repair mechanism to ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        for node in missing:\n            dup_pos = random.choice([i for i, x in enumerate(new_solution) if x in duplicates])\n            new_solution[dup_pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9909114504991756,
            0.12070465087890625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based selection to prioritize non-dominated solutions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap, followed by a local optimization step to further improve the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify non-dominated solutions\n    non_dominated_indices = []\n    objectives = [obj for _, obj in archive]\n\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]:\n                if objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]:\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated_indices.append(i)\n\n    # Select from non-dominated solutions if available, otherwise select randomly\n    if non_dominated_indices:\n        selected_index = random.choice(non_dominated_indices)\n    else:\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.5\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.5 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Local optimization step: 2-opt for the first objective\n        improved = True\n        while improved:\n            improved = False\n            for i in range(n - 2):\n                for j in range(i + 2, n):\n                    if j == n - 1 and i == 0:\n                        continue\n                    current_cost = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                    new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n                    if new_cost < current_cost:\n                        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.895953577632707,
            3.7118144631385803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify non-dominated solutions\n    non_dominated_indices = []\n    objectives = [obj for _, obj in archive]\n\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i == j:\n                continue\n            if objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]:\n                if objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]:\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated_indices.append(i)\n\n    # Select from non-dominated solutions if available, otherwise select randomly\n    if non_dominated_indices:\n        selected_index = random.choice(non_dominated_indices)\n    else:\n        selected_index = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.5\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.5 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Local optimization step: 2-opt for the first objective\n        improved = True\n        while improved:\n            improved = False\n            for i in range(n - 2):\n                for j in range(i + 2, n):\n                    if j == n - 1 and i == 0:\n                        continue\n                    current_cost = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                    new_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n                    if new_cost < current_cost:\n                        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{The algorithm selects a solution from the archive based on a dominance-based score, then applies a hybrid local search combining 3-opt with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance scores and select promising solutions\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i, obj_j = archive[i][1], archive[j][1]\n                if obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1] and (obj_i[0] > obj_j[0] or obj_i[1] > obj_j[1]):\n                    dominated[i] = True\n                    break\n\n    non_dominated = [sol for i, (sol, _) in enumerate(archive) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Hybrid local search: 3-opt with probabilistic edge swap\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9026636872559228,
            0.31964486837387085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance scores and select promising solutions\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                obj_i, obj_j = archive[i][1], archive[j][1]\n                if obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1] and (obj_i[0] > obj_j[0] or obj_i[1] > obj_j[1]):\n                    dominated[i] = True\n                    break\n\n    non_dominated = [sol for i, (sol, _) in enumerate(archive) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Hybrid local search: 3-opt with probabilistic edge swap\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour segment diversity, then applies a hybrid local search combining adaptive segment insertion and probabilistic node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and segment diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.zeros(len(archive))\n\n    for i, (obj1, obj2) in enumerate(objectives):\n        # Calculate potential improvement (simplified)\n        improvement_potential[i] = (1/obj1 + 1/obj2) * (len(archive) - i)\n\n    # Select solution with highest improvement potential\n    selected_index = np.argmax(improvement_potential)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment insertion\n        segment_length = max(2, min(5, n // 4))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic node reinsertion\n        if random.random() < 0.4 and n > 3:\n            node_pos = random.randint(1, n-2)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n            insert_pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [node],\n                new_solution[insert_pos:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7328949872662932,
            0.3011239767074585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and segment diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.zeros(len(archive))\n\n    for i, (obj1, obj2) in enumerate(objectives):\n        # Calculate potential improvement (simplified)\n        improvement_potential[i] = (1/obj1 + 1/obj2) * (len(archive) - i)\n\n    # Select solution with highest improvement potential\n    selected_index = np.argmax(improvement_potential)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment insertion\n        segment_length = max(2, min(5, n // 4))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic node reinsertion\n        if random.random() < 0.4 and n > 3:\n            node_pos = random.randint(1, n-2)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n            insert_pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [node],\n                new_solution[insert_pos:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure diversity, then applies a hybrid local search combining adaptive segment transposition, probabilistic edge reversal, and cross-solution segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        potential = 0\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j:\n                if other_obj1 < obj1 or other_obj2 < obj2:\n                    potential += 1\n        improvement_potential.append(potential)\n\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment transposition, probabilistic edge reversal, and cross-solution segment insertion\n    if n > 4:\n        # Adaptive segment transposition\n        segment_length = max(2, int(np.sqrt(n)))\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Probabilistic edge reversal\n        for i in range(1, n-1):\n            if random.random() < 0.2:  # 20% chance to reverse edge\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Cross-solution segment insertion\n        if len(archive) > 1 and random.random() < 0.5:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            segment_length = max(2, min(5, n//4))\n            start = random.randint(0, n - segment_length - 1)\n            end = start + segment_length\n            new_solution[start:end] = other_solution[start:end]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8157365048348304,
            5.431106686592102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        potential = 0\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j:\n                if other_obj1 < obj1 or other_obj2 < obj2:\n                    potential += 1\n        improvement_potential.append(potential)\n\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment transposition, probabilistic edge reversal, and cross-solution segment insertion\n    if n > 4:\n        # Adaptive segment transposition\n        segment_length = max(2, int(np.sqrt(n)))\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Probabilistic edge reversal\n        for i in range(1, n-1):\n            if random.random() < 0.2:  # 20% chance to reverse edge\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Cross-solution segment insertion\n        if len(archive) > 1 and random.random() < 0.5:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            segment_length = max(2, min(5, n//4))\n            start = random.randint(0, n - segment_length - 1)\n            end = start + segment_length\n            new_solution[start:end] = other_solution[start:end]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based score that prioritizes solutions with better objective values, then applies a hybrid local search combining segment inversion with a probabilistic node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance scores for each solution\n    dominance_scores = np.zeros(len(archive))\n    objectives = [obj for _, obj in archive]\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] > objectives[j][0] and objectives[i][1] > objectives[j][1]:\n                    dominated_count += 1\n        dominance_scores[i] = dominated_count\n\n    # Select solution with minimum dominance score (most non-dominated)\n    selected_index = np.argmin(dominance_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment inversion with probabilistic node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Invert the segment with probability 0.6\n        if random.random() < 0.6:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic node insertion\n        if random.random() < 0.4 and n > 3:\n            insert_pos = random.randint(0, n-1)\n            node_to_insert = random.choice(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9425041110788603,
            1.4934337735176086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance scores for each solution\n    dominance_scores = np.zeros(len(archive))\n    objectives = [obj for _, obj in archive]\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] > objectives[j][0] and objectives[i][1] > objectives[j][1]:\n                    dominated_count += 1\n        dominance_scores[i] = dominated_count\n\n    # Select solution with minimum dominance score (most non-dominated)\n    selected_index = np.argmin(dominance_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment inversion with probabilistic node insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Invert the segment with probability 0.6\n        if random.random() < 0.6:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic node insertion\n        if random.random() < 0.4 and n > 3:\n            insert_pos = random.randint(0, n-1)\n            node_to_insert = random.choice(new_solution)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8790160444338765,
            0.41590917110443115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of normalized objective scores and local improvement potential, then applies a novel local search operator combining a multi-segment inversion with a dynamic edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid scores combining normalized objectives and local improvement potential\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        # Calculate local improvement potential based on edge diversity\n        edge_diversity = len(set(zip(sol, np.roll(sol, -1))))\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2 + 0.2 * (edge_diversity / len(sol))\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion with dynamic edge exchange\n        k = random.randint(2, min(4, n//2))\n        segments = sorted(random.sample(range(1, n), k-1))\n        segments = [0] + segments + [n]\n\n        # Invert segments in random order\n        for i in range(len(segments)-1):\n            start, end = segments[i], segments[i+1]\n            if random.random() > 0.5:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Dynamic edge exchange: swap edges between segments\n        for i in range(len(segments)-2):\n            a = random.randint(segments[i], segments[i+1]-1)\n            b = random.randint(segments[i+1], segments[i+2]-1)\n            if random.random() > 0.5:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8973963279861918,
            0.6785939335823059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate hybrid scores combining normalized objectives and local improvement potential\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        # Calculate local improvement potential based on edge diversity\n        edge_diversity = len(set(zip(sol, np.roll(sol, -1))))\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2 + 0.2 * (edge_diversity / len(sol))\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion with dynamic edge exchange\n        k = random.randint(2, min(4, n//2))\n        segments = sorted(random.sample(range(1, n), k-1))\n        segments = [0] + segments + [n]\n\n        # Invert segments in random order\n        for i in range(len(segments)-1):\n            start, end = segments[i], segments[i+1]\n            if random.random() > 0.5:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Dynamic edge exchange: swap edges between segments\n        for i in range(len(segments)-2):\n            a = random.randint(segments[i], segments[i+1]-1)\n            b = random.randint(segments[i+1], segments[i+2]-1)\n            if random.random() > 0.5:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining segment reversal, node swapping, and crossover with a segment from a non-dominated solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    objectives = [obj for (sol, obj) in archive]\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominated_indices = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(i + 1, len(archive)):\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n               (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                dominated_indices[i].append(j)\n                dominated_counts[j] += 1\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n                 (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                dominated_indices[j].append(i)\n                dominated_counts[i] += 1\n\n    current_front = [i for i in range(len(archive)) if dominated_counts[i] == 0]\n    fronts.append(current_front)\n\n    while current_front:\n        next_front = []\n        for i in current_front:\n            for j in dominated_indices[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        fronts.append(next_front)\n        current_front = next_front\n\n    # Select from the first front if possible, otherwise from subsequent fronts\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.choice(fronts[1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Crossover with a non-dominated solution\n    if len(fronts[0]) > 1:\n        other_idx = random.choice([i for i in fronts[0] if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6704783579623965,
            0.4973587393760681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    objectives = [obj for (sol, obj) in archive]\n    fronts = []\n    dominated_counts = [0] * len(archive)\n    dominated_indices = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(i + 1, len(archive)):\n            if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n               (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                dominated_indices[i].append(j)\n                dominated_counts[j] += 1\n            elif (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n                 (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                dominated_indices[j].append(i)\n                dominated_counts[i] += 1\n\n    current_front = [i for i in range(len(archive)) if dominated_counts[i] == 0]\n    fronts.append(current_front)\n\n    while current_front:\n        next_front = []\n        for i in current_front:\n            for j in dominated_indices[i]:\n                dominated_counts[j] -= 1\n                if dominated_counts[j] == 0:\n                    next_front.append(j)\n        fronts.append(next_front)\n        current_front = next_front\n\n    # Select from the first front if possible, otherwise from subsequent fronts\n    selected_idx = random.choice(fronts[0]) if fronts[0] else random.choice(fronts[1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node swapping\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Crossover with a non-dominated solution\n    if len(fronts[0]) > 1:\n        other_idx = random.choice([i for i in fronts[0] if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding distance-based approach to prioritize solutions in less explored regions of the Pareto front, then applies a hybrid local search combining segment reversal, node insertion, and edge crossover with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n\n    # Calculate crowding distance to select diverse solutions\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node insertion\n    if n > 2:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Apply edge crossover with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find common edges between solutions\n        edges = set()\n        for s in [new_solution, other_solution]:\n            for a, b in zip(s, np.roll(s, -1)):\n                edges.add((min(a, b), max(a, b)))\n\n        # Select a random edge to insert\n        if edges:\n            edge = random.choice(list(edges))\n            a, b = edge\n            pos_a = np.where(new_solution == a)[0][0]\n            pos_b = np.where(new_solution == b)[0][0]\n            if abs(pos_a - pos_b) > 1:\n                segment = new_solution[min(pos_a, pos_b):max(pos_a, pos_b)+1]\n                new_solution = np.concatenate([new_solution[:min(pos_a, pos_b)], segment[::-1], new_solution[max(pos_a, pos_b)+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.79010633064567,
            0.9955772757530212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n\n    # Calculate crowding distance to select diverse solutions\n    crowding_distances = np.zeros(len(objectives))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply node insertion\n    if n > 2:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Apply edge crossover with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find common edges between solutions\n        edges = set()\n        for s in [new_solution, other_solution]:\n            for a, b in zip(s, np.roll(s, -1)):\n                edges.add((min(a, b), max(a, b)))\n\n        # Select a random edge to insert\n        if edges:\n            edge = random.choice(list(edges))\n            a, b = edge\n            pos_a = np.where(new_solution == a)[0][0]\n            pos_b = np.where(new_solution == b)[0][0]\n            if abs(pos_a - pos_b) > 1:\n                segment = new_solution[min(pos_a, pos_b):max(pos_a, pos_b)+1]\n                new_solution = np.concatenate([new_solution[:min(pos_a, pos_b)], segment[::-1], new_solution[max(pos_a, pos_b)+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment inversion and selective node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment inversion and selective node swapping\n    if n > 6:\n        # Multi-segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Selective node swapping\n        swap_pos1, swap_pos2 = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9773652777189399,
            1.1352853775024414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment inversion and selective node swapping\n    if n > 6:\n        # Multi-segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Selective node swapping\n        swap_pos1, swap_pos2 = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic objective weighting scheme that balances the two objectives, then applies a hybrid local search operator combining a node insertion with a segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        obj1_mean = sum(obj[0] for _, obj in archive) / len(archive)\n        obj2_mean = sum(obj[1] for _, obj in archive) / len(archive)\n        weight1 = 1.0 / (obj1_mean + 1e-6)\n        weight2 = 1.0 / (obj2_mean + 1e-6)\n        total_weight = weight1 + weight2\n        weight1 /= total_weight\n        weight2 /= total_weight\n\n        # Select solution with highest weighted score\n        best_score = -float('inf')\n        best_sol = None\n        for sol, obj in archive:\n            score = weight1 * obj[0] + weight2 * obj[1]\n            if score > best_score:\n                best_score = score\n                best_sol = sol\n        base_solution = best_sol.copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion followed by segment reversal\n        # Select a random node and insert it at another position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8699493578756847,
            0.27624523639678955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        obj1_mean = sum(obj[0] for _, obj in archive) / len(archive)\n        obj2_mean = sum(obj[1] for _, obj in archive) / len(archive)\n        weight1 = 1.0 / (obj1_mean + 1e-6)\n        weight2 = 1.0 / (obj2_mean + 1e-6)\n        total_weight = weight1 + weight2\n        weight1 /= total_weight\n        weight2 /= total_weight\n\n        # Select solution with highest weighted score\n        best_score = -float('inf')\n        best_sol = None\n        for sol, obj in archive:\n            score = weight1 * obj[0] + weight2 * obj[1]\n            if score > best_score:\n                best_score = score\n                best_sol = sol\n        base_solution = best_sol.copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion followed by segment reversal\n        # Select a random node and insert it at another position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Select a random segment and reverse it\n        a, b = sorted(random.sample(range(n-1), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel local search combining adaptive segment rotation with a probabilistic multi-edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on hybrid of objective diversity and quality\n    objectives = [obj for _, obj in archive]\n    scores = np.zeros(len(objectives))\n\n    # Calculate diversity score (Euclidean distance in objective space)\n    for i in range(len(objectives)):\n        for j in range(i+1, len(objectives)):\n            dist = np.sqrt((objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2)\n            scores[i] += dist\n            scores[j] += dist\n\n    # Combine with quality score (inverse of objective sum)\n    quality_scores = 1 / (np.array([obj[0] + obj[1] for obj in objectives]) + 1e-6)\n    hybrid_scores = scores * quality_scores\n    selected_index = np.argmax(hybrid_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n\n        # Rotate segment left or right with probability 0.6\n        if random.random() < 0.6:\n            rotation = random.choice([1, -1])\n            segment = np.roll(segment, rotation)\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos+k],\n            new_solution[insert_pos+k:]\n        ])\n\n        # Probabilistic multi-edge insertion\n        if random.random() < 0.4 and n > 5:\n            edges = random.sample(range(1, n-1), 3)\n            for pos in sorted(edges, reverse=True):\n                new_solution = np.insert(new_solution, pos, new_solution[pos-1])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8577299667039417,
            9.646185040473938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on hybrid of objective diversity and quality\n    objectives = [obj for _, obj in archive]\n    scores = np.zeros(len(objectives))\n\n    # Calculate diversity score (Euclidean distance in objective space)\n    for i in range(len(objectives)):\n        for j in range(i+1, len(objectives)):\n            dist = np.sqrt((objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2)\n            scores[i] += dist\n            scores[j] += dist\n\n    # Combine with quality score (inverse of objective sum)\n    quality_scores = 1 / (np.array([obj[0] + obj[1] for obj in objectives]) + 1e-6)\n    hybrid_scores = scores * quality_scores\n    selected_index = np.argmax(hybrid_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(4, n//2))\n        start = random.randint(0, n - k)\n        segment = new_solution[start:start+k]\n\n        # Rotate segment left or right with probability 0.6\n        if random.random() < 0.6:\n            rotation = random.choice([1, -1])\n            segment = np.roll(segment, rotation)\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos+k],\n            new_solution[insert_pos+k:]\n        ])\n\n        # Probabilistic multi-edge insertion\n        if random.random() < 0.4 and n > 5:\n            edges = random.sample(range(1, n-1), 3)\n            for pos in sorted(edges, reverse=True):\n                new_solution = np.insert(new_solution, pos, new_solution[pos-1])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined hypervolume contribution and dominance rank metric, then applies a novel local search operator combining a multi-segment crossover with a probabilistic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks and hypervolume contributions\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n = len(solutions)\n\n    # Calculate dominance ranks\n    dominance_counts = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]:\n                    if objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]:\n                        dominance_counts[j] += 1\n\n    # Calculate hypervolume contributions\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    hypervolume_contributions = [0] * n\n\n    for i in range(n):\n        dominated = []\n        for j in range(n):\n            if j != i and objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1]:\n                dominated.append(j)\n\n        if not dominated:\n            hypervolume_contributions[i] = max_obj1 * max_obj2\n        else:\n            min_dominated_obj1 = min(objectives[j][0] for j in dominated)\n            min_dominated_obj2 = min(objectives[j][1] for j in dominated)\n            hypervolume_contributions[i] = (min_dominated_obj1 - objectives[i][0]) * (min_dominated_obj2 - objectives[i][1])\n\n    # Combine metrics and select solution\n    combined_metrics = [(dominance_counts[i] + 1) / (hypervolume_contributions[i] + 1e-6) for i in range(n)]\n    selected_index = np.argmin(combined_metrics)\n    base_solution = solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment crossover\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points\n\n        segments = [\n            new_solution[:a],\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:]\n        ]\n\n        # Recombine segments in a different order\n        new_order = random.sample(range(4), 4)\n        new_solution = np.concatenate([segments[i] for i in new_order])\n\n        # Probabilistic node insertion\n        if random.random() < 0.5 and n > 3:\n            node_to_insert = random.choice(new_solution)\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [node_to_insert],\n                new_solution[insert_pos:]\n            ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7144233408933872,
            3.1121621131896973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks and hypervolume contributions\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n = len(solutions)\n\n    # Calculate dominance ranks\n    dominance_counts = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]:\n                    if objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]:\n                        dominance_counts[j] += 1\n\n    # Calculate hypervolume contributions\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    hypervolume_contributions = [0] * n\n\n    for i in range(n):\n        dominated = []\n        for j in range(n):\n            if j != i and objectives[j][0] >= objectives[i][0] and objectives[j][1] >= objectives[i][1]:\n                dominated.append(j)\n\n        if not dominated:\n            hypervolume_contributions[i] = max_obj1 * max_obj2\n        else:\n            min_dominated_obj1 = min(objectives[j][0] for j in dominated)\n            min_dominated_obj2 = min(objectives[j][1] for j in dominated)\n            hypervolume_contributions[i] = (min_dominated_obj1 - objectives[i][0]) * (min_dominated_obj2 - objectives[i][1])\n\n    # Combine metrics and select solution\n    combined_metrics = [(dominance_counts[i] + 1) / (hypervolume_contributions[i] + 1e-6) for i in range(n)]\n    selected_index = np.argmin(combined_metrics)\n    base_solution = solutions[selected_index].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment crossover\n        points = sorted(random.sample(range(1, n-1), 3))\n        a, b, c = points\n\n        segments = [\n            new_solution[:a],\n            new_solution[a:b],\n            new_solution[b:c],\n            new_solution[c:]\n        ]\n\n        # Recombine segments in a different order\n        new_order = random.sample(range(4), 4)\n        new_solution = np.concatenate([segments[i] for i in new_order])\n\n        # Probabilistic node insertion\n        if random.random() < 0.5 and n > 3:\n            node_to_insert = random.choice(new_solution)\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                [node_to_insert],\n                new_solution[insert_pos:]\n            ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to promote diversity, then applies a hybrid local search combining segment inversion and adaptive 3-opt moves to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_objs = len(objectives)\n    crowding_distances = np.zeros(n_objs)\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_objs-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive 3-opt\n    if n > 5:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]]) + \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Try different configurations\n        configs = [\n            (new_solution[i:j+1][::-1], new_solution[j:k+1][::-1], new_solution[k:i+1][::-1]),\n            (new_solution[i:j+1], new_solution[j:k+1][::-1], new_solution[k:i+1][::-1]),\n            (new_solution[i:j+1][::-1], new_solution[j:k+1], new_solution[k:i+1][::-1])\n        ]\n\n        best_config = None\n        best_cost = current_cost\n\n        for config in configs:\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = config[0]\n            temp_solution[j:k+1] = config[1]\n            temp_solution[k:i+1] = config[2]\n\n            new_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                        distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                        distance_matrix_1[temp_solution[k-1], temp_solution[k]]) + \\\n                       (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                        distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                        distance_matrix_2[temp_solution[k-1], temp_solution[k]])\n\n            if new_cost < best_cost:\n                best_cost = new_cost\n                best_config = config\n\n        if best_config:\n            new_solution[i:j+1] = best_config[0]\n            new_solution[j:k+1] = best_config[1]\n            new_solution[k:i+1] = best_config[2]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.5212782653348416,
            0.38931596279144287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n_objs = len(objectives)\n    crowding_distances = np.zeros(n_objs)\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, n_objs-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and adaptive 3-opt\n    if n > 5:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]]) + \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Try different configurations\n        configs = [\n            (new_solution[i:j+1][::-1], new_solution[j:k+1][::-1], new_solution[k:i+1][::-1]),\n            (new_solution[i:j+1], new_solution[j:k+1][::-1], new_solution[k:i+1][::-1]),\n            (new_solution[i:j+1][::-1], new_solution[j:k+1], new_solution[k:i+1][::-1])\n        ]\n\n        best_config = None\n        best_cost = current_cost\n\n        for config in configs:\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = config[0]\n            temp_solution[j:k+1] = config[1]\n            temp_solution[k:i+1] = config[2]\n\n            new_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                        distance_matrix_1[temp_solution[j-1], temp_solution[j]] +\n                        distance_matrix_1[temp_solution[k-1], temp_solution[k]]) + \\\n                       (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                        distance_matrix_2[temp_solution[j-1], temp_solution[j]] +\n                        distance_matrix_2[temp_solution[k-1], temp_solution[k]])\n\n            if new_cost < best_cost:\n                best_cost = new_cost\n                best_config = config\n\n        if best_config:\n            new_solution[i:j+1] = best_config[0]\n            new_solution[j:k+1] = best_config[1]\n            new_solution[k:i+1] = best_config[2]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objective values relative to the archive, then applies a hybrid local search combining adaptive segment rotation, weighted node exchange, and a novel \"objective-balanced edge insertion\" to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for (sol, obj) in archive]\n    mean_obj = (sum(o[0] for o in objectives)/len(objectives), sum(o[1] for o in objectives)/len(objectives))\n    diversity_scores = [abs(obj[0]-mean_obj[0]) + abs(obj[1]-mean_obj[1]) for obj in objectives]\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, weighted node exchange, and objective-balanced edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Step 2: Weighted node exchange\n        obj_weights = np.array(archive[selected_idx][1])\n        obj_weights = obj_weights / np.sum(obj_weights)\n        for _ in range(2):\n            if random.random() < obj_weights[0]:\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-balanced edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            obj_balance = np.array(archive[selected_idx][1]) / (np.array(archive[other_idx][1]) + 1e-6)\n            for _ in range(3):\n                if random.random() < obj_balance[0]:\n                    node = random.choice(other_solution)\n                    pos = random.randint(0, n-1)\n                    new_solution = np.insert(new_solution, pos, node)\n                    new_solution = np.unique(new_solution, return_index=True)[1]\n                    new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7845559193469042,
            0.12328875064849854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for (sol, obj) in archive]\n    mean_obj = (sum(o[0] for o in objectives)/len(objectives), sum(o[1] for o in objectives)/len(objectives))\n    diversity_scores = [abs(obj[0]-mean_obj[0]) + abs(obj[1]-mean_obj[1]) for obj in objectives]\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation, weighted node exchange, and objective-balanced edge insertion\n    if n > 3:\n        # Step 1: Adaptive segment rotation\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = random.randint(1, segment_length-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Step 2: Weighted node exchange\n        obj_weights = np.array(archive[selected_idx][1])\n        obj_weights = obj_weights / np.sum(obj_weights)\n        for _ in range(2):\n            if random.random() < obj_weights[0]:\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Step 3: Objective-balanced edge insertion\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            obj_balance = np.array(archive[selected_idx][1]) / (np.array(archive[other_idx][1]) + 1e-6)\n            for _ in range(3):\n                if random.random() < obj_balance[0]:\n                    node = random.choice(other_solution)\n                    pos = random.randint(0, n-1)\n                    new_solution = np.insert(new_solution, pos, node)\n                    new_solution = np.unique(new_solution, return_index=True)[1]\n                    new_solution = new_solution[:n]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and spatial proximity of nodes, then applies a novel local search operator combining adaptive segment reordering and targeted node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering with spatial consideration\n    if n > 4:\n        # Select a segment based on spatial proximity\n        segment_length = random.randint(2, min(4, n-2))\n        start_pos = random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n\n        # Find the most spatially distant segment to swap with\n        max_distance = -1\n        best_pos = start_pos\n        for i in range(0, n - segment_length):\n            if i != start_pos:\n                current_segment = new_solution[i:i+segment_length]\n                # Calculate average distance between segments in both spaces\n                dist1 = np.mean([distance_matrix_1[segment[j]][current_segment[j]] for j in range(segment_length)])\n                dist2 = np.mean([distance_matrix_2[segment[j]][current_segment[j]] for j in range(segment_length)])\n                total_dist = dist1 + dist2\n                if total_dist > max_distance:\n                    max_distance = total_dist\n                    best_pos = i\n\n        # Perform the swap\n        new_solution[start_pos:start_pos+segment_length] = new_solution[best_pos:best_pos+segment_length]\n        new_solution[best_pos:best_pos+segment_length] = segment\n\n        # Targeted node insertion based on spatial context\n        if random.random() < 0.4:\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            # Find the best insertion position based on spatial proximity\n            min_dist = float('inf')\n            best_insert_pos = node_pos\n            for i in range(n):\n                if i != node_pos and i != (node_pos + 1) % n:\n                    dist1 = distance_matrix_1[new_solution[(node_pos-1)%n]][new_solution[i]] + distance_matrix_1[new_solution[i]][node]\n                    dist2 = distance_matrix_2[new_solution[(node_pos-1)%n]][new_solution[i]] + distance_matrix_2[new_solution[i]][node]\n                    total_dist = dist1 + dist2\n                    if total_dist < min_dist:\n                        min_dist = total_dist\n                        best_insert_pos = i\n\n            # Perform the insertion\n            if best_insert_pos > node_pos:\n                new_solution = np.concatenate([\n                    new_solution[:node_pos],\n                    new_solution[node_pos+1:best_insert_pos],\n                    [node],\n                    new_solution[best_insert_pos:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert_pos],\n                    [node],\n                    new_solution[best_insert_pos:node_pos],\n                    new_solution[node_pos+1:]\n                ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9200903935196403,
            1.9174396991729736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and spatial proximity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering with spatial consideration\n    if n > 4:\n        # Select a segment based on spatial proximity\n        segment_length = random.randint(2, min(4, n-2))\n        start_pos = random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n\n        # Find the most spatially distant segment to swap with\n        max_distance = -1\n        best_pos = start_pos\n        for i in range(0, n - segment_length):\n            if i != start_pos:\n                current_segment = new_solution[i:i+segment_length]\n                # Calculate average distance between segments in both spaces\n                dist1 = np.mean([distance_matrix_1[segment[j]][current_segment[j]] for j in range(segment_length)])\n                dist2 = np.mean([distance_matrix_2[segment[j]][current_segment[j]] for j in range(segment_length)])\n                total_dist = dist1 + dist2\n                if total_dist > max_distance:\n                    max_distance = total_dist\n                    best_pos = i\n\n        # Perform the swap\n        new_solution[start_pos:start_pos+segment_length] = new_solution[best_pos:best_pos+segment_length]\n        new_solution[best_pos:best_pos+segment_length] = segment\n\n        # Targeted node insertion based on spatial context\n        if random.random() < 0.4:\n            node_pos = random.randint(0, n-1)\n            node = new_solution[node_pos]\n            # Find the best insertion position based on spatial proximity\n            min_dist = float('inf')\n            best_insert_pos = node_pos\n            for i in range(n):\n                if i != node_pos and i != (node_pos + 1) % n:\n                    dist1 = distance_matrix_1[new_solution[(node_pos-1)%n]][new_solution[i]] + distance_matrix_1[new_solution[i]][node]\n                    dist2 = distance_matrix_2[new_solution[(node_pos-1)%n]][new_solution[i]] + distance_matrix_2[new_solution[i]][node]\n                    total_dist = dist1 + dist2\n                    if total_dist < min_dist:\n                        min_dist = total_dist\n                        best_insert_pos = i\n\n            # Perform the insertion\n            if best_insert_pos > node_pos:\n                new_solution = np.concatenate([\n                    new_solution[:node_pos],\n                    new_solution[node_pos+1:best_insert_pos],\n                    [node],\n                    new_solution[best_insert_pos:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert_pos],\n                    [node],\n                    new_solution[best_insert_pos:node_pos],\n                    new_solution[node_pos+1:]\n                ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value in either space, then applies a hybrid local search combining segment reversal, node insertion from another solution, and edge swapping to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    worst_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != worst_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8461114900320261,
            0.13371455669403076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    worst_idx = np.argmax([max(obj) for obj in objectives])\n    base_solution = archive[worst_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != worst_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0361066106464463,
            0.06782573461532593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0361066106464463,
            0.06782573461532593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0361066106464463,
            0.06782573461532593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining node insertion and a guided segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding = []\n    for sol, obj in archive:\n        idx1 = sorted_obj1.index(obj)\n        idx2 = sorted_obj2.index(obj)\n\n        if idx1 == 0 or idx1 == len(sorted_obj1)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]\n\n        if idx2 == 0 or idx2 == len(sorted_obj2)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]\n\n        crowding.append((dist1 + dist2, sol))\n\n    crowding.sort(key=lambda x: x[0], reverse=True)\n    base_solution = crowding[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion: remove a random node and insert it elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Guided segment reversal: reverse a segment based on distance improvement\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost before and after reversal\n        cost_before = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + \\\n                      sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost_after = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment))) + \\\n                    sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n        if cost_after < cost_before:\n            new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.5735487750438875,
            0.5501691102981567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding = []\n    for sol, obj in archive:\n        idx1 = sorted_obj1.index(obj)\n        idx2 = sorted_obj2.index(obj)\n\n        if idx1 == 0 or idx1 == len(sorted_obj1)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]\n\n        if idx2 == 0 or idx2 == len(sorted_obj2)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]\n\n        crowding.append((dist1 + dist2, sol))\n\n    crowding.sort(key=lambda x: x[0], reverse=True)\n    base_solution = crowding[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Node insertion: remove a random node and insert it elsewhere\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Guided segment reversal: reverse a segment based on distance improvement\n        a, b = sorted(random.sample(range(n-1), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost before and after reversal\n        cost_before = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + \\\n                      sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        cost_after = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment))) + \\\n                    sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n        if cost_after < cost_before:\n            new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized and exponentially weighted combination of objectives, then applies a hybrid local search combining node swapping with a dynamic segment perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def exp_weight(obj):\n        norm_obj1 = obj[0] / (obj[0] + obj[1] + 1e-6)\n        norm_obj2 = obj[1] / (obj[0] + obj[1] + 1e-6)\n        return np.exp(norm_obj1) * 0.5 + np.exp(norm_obj2) * 0.5\n\n    weighted_solutions = [(exp_weight(obj), sol) for sol, obj in archive]\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node swapping with dynamic segment perturbation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Dynamic segment perturbation\n        if random.random() < 0.7:\n            # Reverse segment\n            segment = segment[::-1]\n        else:\n            # Randomize segment order\n            np.random.shuffle(segment)\n\n        # Insert perturbed segment at a different position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8967489879072114,
            0.37040555477142334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def exp_weight(obj):\n        norm_obj1 = obj[0] / (obj[0] + obj[1] + 1e-6)\n        norm_obj2 = obj[1] / (obj[0] + obj[1] + 1e-6)\n        return np.exp(norm_obj1) * 0.5 + np.exp(norm_obj2) * 0.5\n\n    weighted_solutions = [(exp_weight(obj), sol) for sol, obj in archive]\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node swapping with dynamic segment perturbation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Dynamic segment perturbation\n        if random.random() < 0.7:\n            # Reverse segment\n            segment = segment[::-1]\n        else:\n            # Randomize segment order\n            np.random.shuffle(segment)\n\n        # Insert perturbed segment at a different position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of objective diversity and solution quality, then applies a novel local search operator combining a multi-segment shuffle with a probabilistic edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores\n        diversity_scores = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            diversity = 0\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j:\n                    diversity += np.sqrt((obj_i[0] - obj_j[0])**2 + (obj_i[1] - obj_j[1])**2)\n            diversity_scores.append(diversity)\n\n        # Select solution with highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: divide the tour into 3 segments and shuffle them\n        segment_size = n // 3\n        segments = [\n            new_solution[:segment_size],\n            new_solution[segment_size:2*segment_size],\n            new_solution[2*segment_size:]\n        ]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic edge swap: for each edge, decide with probability 0.3 to swap adjacent nodes\n        for i in range(n - 1):\n            if random.random() < 0.3:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Ensure feasibility by verifying all nodes are present\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If infeasible, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7993032174743122,
            0.6048451662063599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores\n        diversity_scores = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            diversity = 0\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j:\n                    diversity += np.sqrt((obj_i[0] - obj_j[0])**2 + (obj_i[1] - obj_j[1])**2)\n            diversity_scores.append(diversity)\n\n        # Select solution with highest diversity\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: divide the tour into 3 segments and shuffle them\n        segment_size = n // 3\n        segments = [\n            new_solution[:segment_size],\n            new_solution[segment_size:2*segment_size],\n            new_solution[2*segment_size:]\n        ]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Probabilistic edge swap: for each edge, decide with probability 0.3 to swap adjacent nodes\n        for i in range(n - 1):\n            if random.random() < 0.3:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Ensure feasibility by verifying all nodes are present\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If infeasible, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour segment quality, then applies a hybrid local search combining segment inversion and edge exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and segment quality\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        potential = 0\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and (other_obj1 < obj1 or other_obj2 < obj2):\n                potential += 1\n        improvement_potential.append(potential)\n\n    if not improvement_potential:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.argmax(improvement_potential)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge exchange\n    if n > 6:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.7663719663036586,
            6.100121259689331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and segment quality\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        potential = 0\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and (other_obj1 < obj1 or other_obj2 < obj2):\n                potential += 1\n        improvement_potential.append(potential)\n\n    if not improvement_potential:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.argmax(improvement_potential)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion and edge exchange\n    if n > 6:\n        # Segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n        # Edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and tour structure entropy, then applies a hybrid local search combining adaptive segment insertion, node swapping with distance-aware probability, and probabilistic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective values and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate entropy of tour structures\n    entropy_scores = []\n    for sol in solutions:\n        transitions = [(sol[i], sol[(i+1)%n]) for i in range(n)]\n        unique_transitions = len(set(transitions))\n        entropy = unique_transitions / n\n        entropy_scores.append(entropy)\n\n    # Combine objective and entropy scores\n    weights = [0.5, 0.3, 0.2]  # weights for objective1, objective2, entropy\n    scores = [w1 * obj[0] + w2 * obj[1] + w3 * ent\n              for obj, ent, (w1, w2, w3) in zip(objectives, entropy_scores, zip(weights, weights[1:], weights[2:]))]\n\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment insertion, node swapping, and edge reversal\n    # Adaptive segment insertion\n    if n > 4:\n        segment_length = random.randint(2, min(4, n//2))\n        start_pos = random.randint(0, n-segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n        insert_pos = random.randint(0, n-segment_length)\n        if insert_pos > start_pos:\n            insert_pos += segment_length\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            np.delete(new_solution, slice(start_pos, start_pos+segment_length))\n        ])\n\n    # Node swapping with distance-aware probability\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        node_i, node_j = new_solution[i], new_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]]\n        dist2 = distance_matrix_1[node_j, node_i] + distance_matrix_1[new_solution[(j-1)%n], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(j+1)%n]]\n        if dist2 < dist1 and random.random() < 0.7:  # Higher probability if swap improves both objectives\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge reversal\n    for i in range(n):\n        if random.random() < 0.1:  # 10% chance to reverse edge\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j]\n            dist2 = distance_matrix_1[node_j, node_i] + distance_matrix_2[node_j, node_i]\n            if dist2 < dist1 and random.random() < 0.6:  # Higher probability if reversal improves both objectives\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9695820784673734,
            0.5385908484458923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective values and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate entropy of tour structures\n    entropy_scores = []\n    for sol in solutions:\n        transitions = [(sol[i], sol[(i+1)%n]) for i in range(n)]\n        unique_transitions = len(set(transitions))\n        entropy = unique_transitions / n\n        entropy_scores.append(entropy)\n\n    # Combine objective and entropy scores\n    weights = [0.5, 0.3, 0.2]  # weights for objective1, objective2, entropy\n    scores = [w1 * obj[0] + w2 * obj[1] + w3 * ent\n              for obj, ent, (w1, w2, w3) in zip(objectives, entropy_scores, zip(weights, weights[1:], weights[2:]))]\n\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: adaptive segment insertion, node swapping, and edge reversal\n    # Adaptive segment insertion\n    if n > 4:\n        segment_length = random.randint(2, min(4, n//2))\n        start_pos = random.randint(0, n-segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n        insert_pos = random.randint(0, n-segment_length)\n        if insert_pos > start_pos:\n            insert_pos += segment_length\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            np.delete(new_solution, slice(start_pos, start_pos+segment_length))\n        ])\n\n    # Node swapping with distance-aware probability\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        node_i, node_j = new_solution[i], new_solution[j]\n        dist1 = distance_matrix_1[node_i, node_j] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(j-1)%n], new_solution[(j+1)%n]]\n        dist2 = distance_matrix_1[node_j, node_i] + distance_matrix_1[new_solution[(j-1)%n], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(j+1)%n]]\n        if dist2 < dist1 and random.random() < 0.7:  # Higher probability if swap improves both objectives\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic edge reversal\n    for i in range(n):\n        if random.random() < 0.1:  # 10% chance to reverse edge\n            j = (i + 1) % n\n            node_i, node_j = new_solution[i], new_solution[j]\n            dist1 = distance_matrix_1[node_i, node_j] + distance_matrix_2[node_i, node_j]\n            dist2 = distance_matrix_1[node_j, node_i] + distance_matrix_2[node_j, node_i]\n            if dist2 < dist1 and random.random() < 0.6:  # Higher probability if reversal improves both objectives\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive based on crowding distance in the objective space, then applies a hybrid local search combining edge assembly with a randomized segment reversal to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives = objectives[sorted_indices]\n        crowding_distance = np.zeros(len(objectives))\n        crowding_distance[0] = crowding_distance[-1] = float('inf')\n\n        for i in range(1, len(objectives)-1):\n            crowding_distance[i] = abs(objectives[i+1, 0] - objectives[i-1, 0]) / (objectives[-1, 0] - objectives[0, 0]) + \\\n                                  abs(objectives[i+1, 1] - objectives[i-1, 1]) / (objectives[-1, 1] - objectives[0, 1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distance)\n        base_solution = archive[sorted_indices[selected_idx]][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge assembly with segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:insert_pos + len(reversed_segment)],\n            new_solution[insert_pos + len(reversed_segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9281629257096587,
            0.21413880586624146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.argsort(objectives[:, 0])\n        objectives = objectives[sorted_indices]\n        crowding_distance = np.zeros(len(objectives))\n        crowding_distance[0] = crowding_distance[-1] = float('inf')\n\n        for i in range(1, len(objectives)-1):\n            crowding_distance[i] = abs(objectives[i+1, 0] - objectives[i-1, 0]) / (objectives[-1, 0] - objectives[0, 0]) + \\\n                                  abs(objectives[i+1, 1] - objectives[i-1, 1]) / (objectives[-1, 1] - objectives[0, 1])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distance)\n        base_solution = archive[sorted_indices[selected_idx]][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge assembly with segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:insert_pos + len(reversed_segment)],\n            new_solution[insert_pos + len(reversed_segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    normalized_scores = []\n    for obj in objectives:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        normalized_scores.append(0.7 * norm_obj1 + 0.3 * norm_obj2)\n\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8080487804500848,
            0.11430484056472778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    normalized_scores = []\n    for obj in objectives:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        normalized_scores.append(0.7 * norm_obj1 + 0.3 * norm_obj2)\n\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective ranks and diversity metrics, then applies a hybrid local search operator combining a multi-segment shuffle with a constrained edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective ranks and diversity\n    objectives = [obj for (sol, obj) in archive]\n    ranks = []\n    for m in range(2):\n        sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][m])\n        rank = [0] * len(objectives)\n        for i, idx in enumerate(sorted_idx):\n            rank[idx] = i\n        ranks.append(rank)\n\n    combined_scores = [sum(r) for r in zip(*ranks)]\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                diversity += sum(1 for a, b in zip(sol, other_sol) if a != b)\n        diversity_scores.append(diversity)\n\n    selection_scores = [0.7 * combined_scores[i] + 0.3 * diversity_scores[i] for i in range(len(archive))]\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: randomly select 3 non-overlapping segments and shuffle them\n        segments = []\n        positions = sorted(random.sample(range(1, n), 2))\n        segments.append((0, positions[0]))\n        segments.append((positions[0], positions[1]))\n        segments.append((positions[1], n))\n        random.shuffle(segments)\n\n        new_segments = []\n        for start, end in segments:\n            new_segments.append(new_solution[start:end])\n        new_solution = np.concatenate(new_segments)\n\n        # Constrained edge insertion: insert a random edge between non-adjacent nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution = np.concatenate([\n                new_solution[:i],\n                [new_solution[j]],\n                new_solution[i:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7713863442458362,
            2.318364441394806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective ranks and diversity\n    objectives = [obj for (sol, obj) in archive]\n    ranks = []\n    for m in range(2):\n        sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][m])\n        rank = [0] * len(objectives)\n        for i, idx in enumerate(sorted_idx):\n            rank[idx] = i\n        ranks.append(rank)\n\n    combined_scores = [sum(r) for r in zip(*ranks)]\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                diversity += sum(1 for a, b in zip(sol, other_sol) if a != b)\n        diversity_scores.append(diversity)\n\n    selection_scores = [0.7 * combined_scores[i] + 0.3 * diversity_scores[i] for i in range(len(archive))]\n    selected_idx = np.argmin(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: randomly select 3 non-overlapping segments and shuffle them\n        segments = []\n        positions = sorted(random.sample(range(1, n), 2))\n        segments.append((0, positions[0]))\n        segments.append((positions[0], positions[1]))\n        segments.append((positions[1], n))\n        random.shuffle(segments)\n\n        new_segments = []\n        for start, end in segments:\n            new_segments.append(new_solution[start:end])\n        new_solution = np.concatenate(new_segments)\n\n        # Constrained edge insertion: insert a random edge between non-adjacent nodes\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution = np.concatenate([\n                new_solution[:i],\n                [new_solution[j]],\n                new_solution[i:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator combining a multi-segment shuffle with a conditional edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = [obj for (sol, obj) in archive]\n    normalized_obj = np.array(objectives)\n    normalized_obj = (normalized_obj - np.min(normalized_obj, axis=0)) / (np.max(normalized_obj, axis=0) - np.min(normalized_obj, axis=0) + 1e-6)\n    diversity_scores = [np.sum(np.abs(normalized_obj[i] - normalized_obj)) for i in range(len(normalized_obj))]\n    combined_scores = [0.7 * normalized_obj[i][0] + 0.3 * normalized_obj[i][1] + 0.2 * diversity_scores[i] for i in range(len(normalized_obj))]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: randomly select 3 segments and shuffle their order\n        split_points = sorted(random.sample(range(1, n), 2))\n        segments = [\n            new_solution[:split_points[0]],\n            new_solution[split_points[0]:split_points[1]],\n            new_solution[split_points[1]:]\n        ]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Conditional edge inversion: invert edges if it improves both objectives\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        inverted_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7830014763803512,
            0.8627594113349915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = [obj for (sol, obj) in archive]\n    normalized_obj = np.array(objectives)\n    normalized_obj = (normalized_obj - np.min(normalized_obj, axis=0)) / (np.max(normalized_obj, axis=0) - np.min(normalized_obj, axis=0) + 1e-6)\n    diversity_scores = [np.sum(np.abs(normalized_obj[i] - normalized_obj)) for i in range(len(normalized_obj))]\n    combined_scores = [0.7 * normalized_obj[i][0] + 0.3 * normalized_obj[i][1] + 0.2 * diversity_scores[i] for i in range(len(normalized_obj))]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment shuffle: randomly select 3 segments and shuffle their order\n        split_points = sorted(random.sample(range(1, n), 2))\n        segments = [\n            new_solution[:split_points[0]],\n            new_solution[split_points[0]:split_points[1]],\n            new_solution[split_points[1]:]\n        ]\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Conditional edge inversion: invert edges if it improves both objectives\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        inverted_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a novel local search combining 3-opt moves, node insertion, and a guided crossover to generate a neighbor while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions\n    solutions = [sol for (sol, obj) in archive]\n    objectives = [obj for (sol, obj) in archive]\n    n = len(objectives)\n\n    # Sort objectives by each criterion\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distances\n    crowding = [0.0] * n\n    crowding[0] = crowding[-1] = float('inf')\n\n    # Calculate crowding distances\n    for obj_idx, obj_sort in enumerate([sorted_obj1, sorted_obj2]):\n        for i in range(1, n-1):\n            if objectives[sorted_obj1[i]][0] == objectives[sorted_obj1[i-1]][0] and objectives[sorted_obj1[i]][0] == objectives[sorted_obj1[i+1]][0]:\n                continue\n            if objectives[sorted_obj2[i]][1] == objectives[sorted_obj2[i-1]][1] and objectives[sorted_obj2[i]][1] == objectives[sorted_obj2[i+1]][1]:\n                continue\n            crowding[sorted_obj1[i]] += (objectives[sorted_obj1[i+1]][obj_idx] - objectives[sorted_obj1[i-1]][obj_idx]) / (objectives[sorted_obj1[-1]][obj_idx] - objectives[sorted_obj1[0]][obj_idx])\n\n    # Select solution with highest crowding distance\n    selected_idx = crowding.index(max(crowding))\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt move\n    n = len(new_solution)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply node insertion\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    # Apply guided crossover\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8513186113442767,
            0.23665684461593628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions\n    solutions = [sol for (sol, obj) in archive]\n    objectives = [obj for (sol, obj) in archive]\n    n = len(objectives)\n\n    # Sort objectives by each criterion\n    sorted_obj1 = sorted(range(n), key=lambda i: objectives[i][0])\n    sorted_obj2 = sorted(range(n), key=lambda i: objectives[i][1])\n\n    # Initialize crowding distances\n    crowding = [0.0] * n\n    crowding[0] = crowding[-1] = float('inf')\n\n    # Calculate crowding distances\n    for obj_idx, obj_sort in enumerate([sorted_obj1, sorted_obj2]):\n        for i in range(1, n-1):\n            if objectives[sorted_obj1[i]][0] == objectives[sorted_obj1[i-1]][0] and objectives[sorted_obj1[i]][0] == objectives[sorted_obj1[i+1]][0]:\n                continue\n            if objectives[sorted_obj2[i]][1] == objectives[sorted_obj2[i-1]][1] and objectives[sorted_obj2[i]][1] == objectives[sorted_obj2[i+1]][1]:\n                continue\n            crowding[sorted_obj1[i]] += (objectives[sorted_obj1[i+1]][obj_idx] - objectives[sorted_obj1[i-1]][obj_idx]) / (objectives[sorted_obj1[-1]][obj_idx] - objectives[sorted_obj1[0]][obj_idx])\n\n    # Select solution with highest crowding distance\n    selected_idx = crowding.index(max(crowding))\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt move\n    n = len(new_solution)\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Apply node insertion\n    node = random.choice(new_solution)\n    pos = random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    # Apply guided crossover\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment inversion and selective node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Selective node insertion\n        if random.random() < 0.4:\n            pos = random.randint(1, n-2)\n            node = new_solution[pos]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n            insert_pos = random.randint(1, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8686125755468918,
            1.0554260611534119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Selective node insertion\n        if random.random() < 0.4:\n            pos = random.randint(1, n-2)\n            node = new_solution[pos]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n            insert_pos = random.randint(1, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted sum of normalized objectives with different weights, then applies a hybrid local search combining edge relocation with a randomized segment reversal and swap operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Different weighting to focus more on the first objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal and swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Perform a random swap\n        swap_i, swap_j = random.sample(range(n), 2)\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.913429045971308,
            0.11167746782302856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Different weighting to focus more on the first objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal and swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Perform a random swap\n        swap_i, swap_j = random.sample(range(n), 2)\n        new_solution[swap_i], new_solution[swap_j] = new_solution[swap_j], new_solution[swap_i]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest normalized objective values, then applies a hybrid local search combining segment reversal, node swapping, and edge crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node swapping, and edge crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node swapping\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 3: Edge crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        pos = random.randint(0, n-1)\n        edge = other_solution[pos]\n        if edge in new_solution:\n            edge_pos = np.where(new_solution == edge)[0][0]\n            new_solution[edge_pos] = new_solution[pos]\n            new_solution[pos] = edge\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8229868977487025,
            0.2333517074584961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node swapping, and edge crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node swapping\n    if n > 1:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 3: Edge crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        pos = random.randint(0, n-1)\n        edge = other_solution[pos]\n        if edge in new_solution:\n            edge_pos = np.where(new_solution == edge)[0][0]\n            new_solution[edge_pos] = new_solution[pos]\n            new_solution[pos] = edge\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a novel \"multi-objective path relinking\" strategy that blends segments from multiple solutions while preserving feasibility, combined with a dynamic node reordering operator to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    if len(archive) > 1:\n        # Select two diverse solutions for blending\n        other_indices = [i for i in range(len(archive)) if i != selected_idx]\n        other_solution1 = archive[random.choice(other_indices)][0]\n        other_solution2 = archive[random.choice(other_indices)][0]\n\n        # Determine blend points\n        blend_start = random.randint(0, n-2)\n        blend_end = random.randint(blend_start+1, n-1)\n\n        # Create a blend mask\n        mask = np.zeros(n, dtype=bool)\n        mask[blend_start:blend_end] = True\n\n        # Blend segments from both solutions\n        for i in range(n):\n            if mask[i]:\n                if random.random() < 0.5:\n                    new_solution[i] = other_solution1[i]\n                else:\n                    new_solution[i] = other_solution2[i]\n\n    # Dynamic node reordering\n    if random.random() < 0.7:\n        # Select a segment to reorder\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate objective weights for each node in the segment\n        obj_weights = np.array([distance_matrix_1[segment[i-1]][segment[i]] + distance_matrix_2[segment[i-1]][segment[i]]\n                               for i in range(len(segment))])\n\n        # Reorder the segment based on weights\n        ordered_indices = np.argsort(obj_weights)\n        new_solution[seg_start:seg_end] = segment[ordered_indices]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8483100693209008,
            0.0934489369392395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    if len(archive) > 1:\n        # Select two diverse solutions for blending\n        other_indices = [i for i in range(len(archive)) if i != selected_idx]\n        other_solution1 = archive[random.choice(other_indices)][0]\n        other_solution2 = archive[random.choice(other_indices)][0]\n\n        # Determine blend points\n        blend_start = random.randint(0, n-2)\n        blend_end = random.randint(blend_start+1, n-1)\n\n        # Create a blend mask\n        mask = np.zeros(n, dtype=bool)\n        mask[blend_start:blend_end] = True\n\n        # Blend segments from both solutions\n        for i in range(n):\n            if mask[i]:\n                if random.random() < 0.5:\n                    new_solution[i] = other_solution1[i]\n                else:\n                    new_solution[i] = other_solution2[i]\n\n    # Dynamic node reordering\n    if random.random() < 0.7:\n        # Select a segment to reorder\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate objective weights for each node in the segment\n        obj_weights = np.array([distance_matrix_1[segment[i-1]][segment[i]] + distance_matrix_2[segment[i-1]][segment[i]]\n                               for i in range(len(segment))])\n\n        # Reorder the segment based on weights\n        ordered_indices = np.argsort(obj_weights)\n        new_solution[seg_start:seg_end] = segment[ordered_indices]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and node diversity, then applies a hybrid local search combining segment insertion, node swapping, and randomized path reversal to generate a neighbor solution while ensuring feasibility and exploring diverse solution spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and node diversity\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [np.sum(np.abs(np.diff(sol))) for (sol, _) in archive]\n    combined_scores = [0.5 * (obj[0] + obj[1]) + 0.5 * div for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = combined_scores.index(min(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment insertion, node swapping, and path reversal\n    n = len(new_solution)\n\n    # Step 1: Segment insertion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Step 2: Node swapping with diversity consideration\n    if n > 2:\n        swap_indices = random.sample(range(n), 2)\n        node1, node2 = new_solution[swap_indices[0]], new_solution[swap_indices[1]]\n        if np.abs(node1 - node2) > n // 2:  # Encourage swapping distant nodes\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = node2, node1\n\n    # Step 3: Randomized path reversal with objective-aware selection\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the potential improvement\n        current_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        new_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n\n        if new_cost < current_cost:  # Only reverse if it improves both objectives\n            new_solution[i:j] = reversed_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9645496822045998,
            0.806866466999054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective and node diversity\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [np.sum(np.abs(np.diff(sol))) for (sol, _) in archive]\n    combined_scores = [0.5 * (obj[0] + obj[1]) + 0.5 * div for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = combined_scores.index(min(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment insertion, node swapping, and path reversal\n    n = len(new_solution)\n\n    # Step 1: Segment insertion\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Step 2: Node swapping with diversity consideration\n    if n > 2:\n        swap_indices = random.sample(range(n), 2)\n        node1, node2 = new_solution[swap_indices[0]], new_solution[swap_indices[1]]\n        if np.abs(node1 - node2) > n // 2:  # Encourage swapping distant nodes\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = node2, node1\n\n    # Step 3: Randomized path reversal with objective-aware selection\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        reversed_segment = segment[::-1]\n\n        # Evaluate the potential improvement\n        current_cost = distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]\n        new_cost = distance_matrix_1[reversed_segment[-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n\n        if new_cost < current_cost:  # Only reverse if it improves both objectives\n            new_solution[i:j] = reversed_segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel adaptive weighting scheme that considers both objective values and their trade-off relationships, then applies a hybrid local search combining node insertion, segment rotation, and probabilistic path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighting selection\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    # Normalize and compute trade-off factor\n    norm_obj1 = [(o[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-10) for o in objectives]\n    norm_obj2 = [(o[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-10) for o in objectives]\n    trade_off = [abs(n1 - n2) for n1, n2 in zip(norm_obj1, norm_obj2)]\n\n    # Select solution with highest trade-off (most balanced)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion, segment rotation, and probabilistic path inversion\n        # Node insertion\n        node_to_insert = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Segment rotation\n        if n > 6:\n            start = random.randint(0, n-4)\n            segment_length = random.randint(2, min(4, n-start))\n            segment = new_solution[start:start+segment_length]\n            rotation = random.randint(1, segment_length-1)\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Probabilistic path inversion\n        if random.random() < 0.5 and n > 5:\n            start = random.randint(0, n-3)\n            end = random.randint(start+2, min(start+5, n-1))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7637316222412719,
            0.2423703670501709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighting selection\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    # Normalize and compute trade-off factor\n    norm_obj1 = [(o[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-10) for o in objectives]\n    norm_obj2 = [(o[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-10) for o in objectives]\n    trade_off = [abs(n1 - n2) for n1, n2 in zip(norm_obj1, norm_obj2)]\n\n    # Select solution with highest trade-off (most balanced)\n    selected_idx = np.argmax(trade_off)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion, segment rotation, and probabilistic path inversion\n        # Node insertion\n        node_to_insert = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Segment rotation\n        if n > 6:\n            start = random.randint(0, n-4)\n            segment_length = random.randint(2, min(4, n-start))\n            segment = new_solution[start:start+segment_length]\n            rotation = random.randint(1, segment_length-1)\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Probabilistic path inversion\n        if random.random() < 0.5 and n > 5:\n            start = random.randint(0, n-3)\n            end = random.randint(start+2, min(start+5, n-1))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining segment reversal and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and adaptive edge insertion\n    if n > 6:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive edge insertion\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9144501588056606,
            0.23423027992248535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and adaptive edge insertion\n    if n > 6:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive edge insertion\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge insertion, segment reversal, and crossover with a solution from the Pareto front to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n    normalized_scores = [(obj[0] - min_obj1) / (max_obj1 - min_obj1) + (obj[1] - min_obj2) / (max_obj2 - min_obj2) for obj in objectives]\n    selected_idx = normalized_scores.index(max(normalized_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, segment reversal, and crossover with Pareto front solution\n    n = len(new_solution)\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with a Pareto front solution\n    if len(archive) > 1:\n        pareto_front = [sol for sol, obj in archive if all(obj[0] <= o[0] and obj[1] <= o[1] and (obj[0] < o[0] or obj[1] < o[1]) for _, o in archive)]\n        if pareto_front:\n            other_solution = random.choice(pareto_front)\n            crossover_point = random.randint(1, n-1)\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9060666736891276,
            0.34818440675735474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n    normalized_scores = [(obj[0] - min_obj1) / (max_obj1 - min_obj1) + (obj[1] - min_obj2) / (max_obj2 - min_obj2) for obj in objectives]\n    selected_idx = normalized_scores.index(max(normalized_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion, segment reversal, and crossover with Pareto front solution\n    n = len(new_solution)\n\n    # Step 1: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with a Pareto front solution\n    if len(archive) > 1:\n        pareto_front = [sol for sol, obj in archive if all(obj[0] <= o[0] and obj[1] <= o[1] and (obj[0] < o[0] or obj[1] < o[1]) for _, o in archive)]\n        if pareto_front:\n            other_solution = random.choice(pareto_front)\n            crossover_point = random.randint(1, n-1)\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of normalized objectives, then applies a hybrid local search combining edge swaps with a probabilistic segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Different weighting to focus more on the first objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge swap with probabilistic segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # 70% chance to do edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # 30% chance to do segment reversal\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            insert_pos = random.randint(0, n - len(reversed_segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                reversed_segment,\n                new_solution[insert_pos:]\n            ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7826216486767089,
            0.1977248191833496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Different weighting to focus more on the first objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge swap with probabilistic segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7:  # 70% chance to do edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:  # 30% chance to do segment reversal\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            insert_pos = random.randint(0, n - len(reversed_segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                reversed_segment,\n                new_solution[insert_pos:]\n            ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects the solution with the highest variance in objective values from the archive, then applies a novel local search combining multi-segment swapping, adaptive node relocation, and objective-aware edge replacement to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest variance in objectives\n    variances = [(obj[0] - obj[1])**2 for (sol, obj) in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment swapping\n    if n > 3:\n        points = sorted(random.sample(range(n), 4))\n        a, b, c, d = points\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n    # Adaptive node relocation\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Objective-aware edge replacement\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        if (obj1_after > obj1_before and obj2_after > obj2_before) or (obj1_after < obj1_before and obj2_after < obj2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5852756999934343,
            0.2195596694946289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest variance in objectives\n    variances = [(obj[0] - obj[1])**2 for (sol, obj) in archive]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment swapping\n    if n > 3:\n        points = sorted(random.sample(range(n), 4))\n        a, b, c, d = points\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n    # Adaptive node relocation\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Objective-aware edge replacement\n    if n > 1:\n        i, j = random.sample(range(n), 2)\n        obj1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        obj1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        obj2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        if (obj1_after > obj1_before and obj2_after > obj2_before) or (obj1_after < obj1_before and obj2_after < obj2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining a novel \"node chain\" operator with a probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement based on objective diversity\n    objectives = [obj for (sol, obj) in archive]\n    avg_obj1 = sum(obj[0] for obj in objectives) / len(objectives)\n    avg_obj2 = sum(obj[1] for obj in objectives) / len(objectives)\n\n    # Prefer solutions with objectives below average in at least one dimension\n    candidates = [(i, obj) for i, obj in enumerate(objectives) if obj[0] <= avg_obj1 or obj[1] <= avg_obj2]\n    if not candidates:\n        candidates = list(enumerate(objectives))\n\n    selected_idx = random.choice([i for i, _ in candidates])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node chain operator with probabilistic segment inversion\n    if n > 3:\n        # Node chain operator: select a chain of nodes and rotate them\n        chain_length = random.randint(2, min(4, n-1))\n        start = random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Rotate the chain\n        rotated_chain = np.roll(chain, shift=1)\n        new_solution[start:start+chain_length] = rotated_chain\n\n        # Probabilistic segment inversion\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reconstruct solution if duplicates exist\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(new_solution) - set(range(n))\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution[pos] = node\n        for node in extra:\n            pos = np.where(new_solution == node)[0][0]\n            new_solution[pos] = random.choice(list(missing))\n            missing.remove(new_solution[pos])\n\n    return new_solution\n\n",
        "score": [
            -0.9083082004605361,
            0.2062898874282837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement based on objective diversity\n    objectives = [obj for (sol, obj) in archive]\n    avg_obj1 = sum(obj[0] for obj in objectives) / len(objectives)\n    avg_obj2 = sum(obj[1] for obj in objectives) / len(objectives)\n\n    # Prefer solutions with objectives below average in at least one dimension\n    candidates = [(i, obj) for i, obj in enumerate(objectives) if obj[0] <= avg_obj1 or obj[1] <= avg_obj2]\n    if not candidates:\n        candidates = list(enumerate(objectives))\n\n    selected_idx = random.choice([i for i, _ in candidates])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node chain operator with probabilistic segment inversion\n    if n > 3:\n        # Node chain operator: select a chain of nodes and rotate them\n        chain_length = random.randint(2, min(4, n-1))\n        start = random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Rotate the chain\n        rotated_chain = np.roll(chain, shift=1)\n        new_solution[start:start+chain_length] = rotated_chain\n\n        # Probabilistic segment inversion\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reconstruct solution if duplicates exist\n        missing = set(range(n)) - set(unique_nodes)\n        extra = set(new_solution) - set(range(n))\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution[pos] = node\n        for node in extra:\n            pos = np.where(new_solution == node)[0][0]\n            new_solution[pos] = random.choice(list(missing))\n            missing.remove(new_solution[pos])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{The new algorithm selects a solution from the archive based on a Pareto dominance metric and applies a novel local search combining segment insertion with a probabilistic node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best Pareto dominance (non-dominated solutions preferred)\n    objectives = [obj for _, obj in archive]\n    dominated_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominated_counts[i] += 1\n\n    selected_index = np.argmax(dominated_counts)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Novel local search: segment insertion with probabilistic node reinsertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Remove the segment from its current position\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Probabilistic node reinsertion\n        if random.random() < 0.4 and n > 4:\n            node_pos = random.randint(0, len(new_solution) - 1)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            new_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9093094250824217,
            0.3141974210739136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best Pareto dominance (non-dominated solutions preferred)\n    objectives = [obj for _, obj in archive]\n    dominated_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominated_counts[i] += 1\n\n    selected_index = np.argmax(dominated_counts)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Novel local search: segment insertion with probabilistic node reinsertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Remove the segment from its current position\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Probabilistic node reinsertion\n        if random.random() < 0.4 and n > 4:\n            node_pos = random.randint(0, len(new_solution) - 1)\n            node = new_solution[node_pos]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            new_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search combining node insertion with a probabilistic edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined scores for each solution\n    scored_solutions = []\n    for sol, obj in archive:\n        score = obj[0] + obj[1]  # Combined score\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: node insertion with probabilistic edge swap\n        # Select a random node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:  # 30% chance to swap edges\n            swap_pos = random.randint(0, n-2)\n            new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.8347414773721169,
            0.21734976768493652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined scores for each solution\n    scored_solutions = []\n    for sol, obj in archive:\n        score = obj[0] + obj[1]  # Combined score\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: node insertion with probabilistic edge swap\n        # Select a random node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:  # 30% chance to swap edges\n            swap_pos = random.randint(0, n-2)\n            new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{A new algorithm selects a solution from the archive based on a weighted sum of objectives and a diversity metric, then applies a hybrid local search combining a k-opt move with a segment reversal to generate a feasible neighbor solution while ensuring no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]\n    scored_solutions = [(sol, obj[0] * weights[0] + obj[1] * weights[1]) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[1])\n    selected_solutions = scored_solutions[:max(1, len(archive)//3)]\n\n    # Diversity-based selection\n    if len(selected_solutions) > 1:\n        distances = []\n        for i in range(len(selected_solutions)):\n            dist = 0\n            for j in range(len(selected_solutions)):\n                if i != j:\n                    dist += np.sum(selected_solutions[i][0] != selected_solutions[j][0])\n            distances.append(dist)\n        base_solution = selected_solutions[np.argmax(distances)][0].copy()\n    else:\n        base_solution = selected_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # k-opt move (k=3)\n        indices = sorted(random.sample(range(n), 3))\n        a, b, c = indices\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Segment reversal\n        x, y = sorted(random.sample(range(n), 2))\n        new_solution[x:y] = new_solution[x:y][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8357496285235345,
            0.25750279426574707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]\n    scored_solutions = [(sol, obj[0] * weights[0] + obj[1] * weights[1]) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[1])\n    selected_solutions = scored_solutions[:max(1, len(archive)//3)]\n\n    # Diversity-based selection\n    if len(selected_solutions) > 1:\n        distances = []\n        for i in range(len(selected_solutions)):\n            dist = 0\n            for j in range(len(selected_solutions)):\n                if i != j:\n                    dist += np.sum(selected_solutions[i][0] != selected_solutions[j][0])\n            distances.append(dist)\n        base_solution = selected_solutions[np.argmax(distances)][0].copy()\n    else:\n        base_solution = selected_solutions[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # k-opt move (k=3)\n        indices = sorted(random.sample(range(n), 3))\n        a, b, c = indices\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Segment reversal\n        x, y = sorted(random.sample(range(n), 2))\n        new_solution[x:y] = new_solution[x:y][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based score that combines crowding distance and dominance count, then applies a hybrid local search combining segment reversal with a probabilistic edge swap, followed by a dominance-based acceptance criterion to ensure improvement in at least one objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance-based scores\n    objectives = [obj for _, obj in archive]\n    dominance_counts = np.zeros(len(objectives))\n    crowding_distances = np.zeros(len(objectives))\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    combined_scores = crowding_distances / (1 + dominance_counts)\n    selected_index = np.argmax(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        if random.random() < 0.8:\n            segment = segment[::-1]\n\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        if random.random() < 0.4 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8789459991467409,
            2.556151807308197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance-based scores\n    objectives = [obj for _, obj in archive]\n    dominance_counts = np.zeros(len(objectives))\n    crowding_distances = np.zeros(len(objectives))\n\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    combined_scores = crowding_distances / (1 + dominance_counts)\n    selected_index = np.argmax(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        if random.random() < 0.8:\n            segment = segment[::-1]\n\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        if random.random() < 0.4 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest improvement potential by combining objective values with a random weight, then applies a hybrid local search combining segment rotation, node relocation, and a novel \"objective-biased crossover\" that prioritizes edges with better combined objective values while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with random weight combination\n    objectives = [obj for (sol, obj) in archive]\n    weights = [random.uniform(0.3, 0.7), random.uniform(0.3, 0.7)]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, weights))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation\n    k = random.randint(1, n//2)\n    new_solution = np.roll(new_solution, k)\n\n    # Node relocation\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Objective-biased crossover\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n\n        # Calculate edge quality in both objectives\n        def edge_quality(a, b):\n            d1 = distance_matrix_1[a, b]\n            d2 = distance_matrix_2[a, b]\n            return (d1 + d2) / 2\n\n        # Prefer edges with better combined quality\n        for i in range(crossover_point):\n            if random.random() < 0.7:  # 70% chance to keep current edge\n                continue\n            # Find best possible edge in other solution\n            current_node = new_solution[i]\n            best_node = None\n            best_quality = float('inf')\n            for node in other_solution:\n                if node not in new_solution[:i]:\n                    q = edge_quality(current_node, node)\n                    if q < best_quality:\n                        best_quality = q\n                        best_node = node\n            if best_node is not None:\n                pos = np.where(new_solution == best_node)[0]\n                if len(pos) > 0:\n                    new_solution[i], new_solution[pos[0]] = new_solution[pos[0]], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7590134386164645,
            0.4468172788619995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with random weight combination\n    objectives = [obj for (sol, obj) in archive]\n    weights = [random.uniform(0.3, 0.7), random.uniform(0.3, 0.7)]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, weights))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation\n    k = random.randint(1, n//2)\n    new_solution = np.roll(new_solution, k)\n\n    # Node relocation\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Objective-biased crossover\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n\n        # Calculate edge quality in both objectives\n        def edge_quality(a, b):\n            d1 = distance_matrix_1[a, b]\n            d2 = distance_matrix_2[a, b]\n            return (d1 + d2) / 2\n\n        # Prefer edges with better combined quality\n        for i in range(crossover_point):\n            if random.random() < 0.7:  # 70% chance to keep current edge\n                continue\n            # Find best possible edge in other solution\n            current_node = new_solution[i]\n            best_node = None\n            best_quality = float('inf')\n            for node in other_solution:\n                if node not in new_solution[:i]:\n                    q = edge_quality(current_node, node)\n                    if q < best_quality:\n                        best_quality = q\n                        best_node = node\n            if best_node is not None:\n                pos = np.where(new_solution == best_node)[0]\n                if len(pos) > 0:\n                    new_solution[i], new_solution[pos[0]] = new_solution[pos[0]], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swap with probabilistic insertion\n    if n > 4:\n        # Select two random segments and reverse them\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n        # Probabilistic edge swap\n        if random.random() < 0.5 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Probabilistic insertion of a random segment\n        if random.random() < 0.4 and n > 5:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            insert_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8388147644697602,
            0.6313884854316711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal and edge swap with probabilistic insertion\n    if n > 4:\n        # Select two random segments and reverse them\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n        # Probabilistic edge swap\n        if random.random() < 0.5 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Probabilistic insertion of a random segment\n        if random.random() < 0.4 and n > 5:\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b]\n            insert_pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and tour structure entropy, then applies a hybrid local search combining probabilistic node insertion with a multi-segment crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective improvement potential and tour entropy\n    objectives = np.array([obj for _, obj in archive])\n    tour_lengths = np.array([np.sum(distance_matrix_1[sol[:-1], sol[1:]] + distance_matrix_2[sol[:-1], sol[1:]]) for sol, _ in archive])\n    entropy = np.array([len(np.unique(sol)) / len(sol) for sol, _ in archive])\n    scores = (1 / (1 + objectives[:, 0])) * (1 / (1 + objectives[:, 1])) * entropy * (1 / (1 + tour_lengths))\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: probabilistic node insertion with multi-segment crossover\n    if n > 5:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Probabilistic node insertion\n        if random.random() < 0.4:\n            insert_pos = random.randint(0, len(segment1))\n            node_to_insert = random.choice(segment2)\n            segment1 = np.insert(segment1, insert_pos, node_to_insert)\n\n        # Multi-segment crossover\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6873214447066178,
            3.883413076400757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective improvement potential and tour entropy\n    objectives = np.array([obj for _, obj in archive])\n    tour_lengths = np.array([np.sum(distance_matrix_1[sol[:-1], sol[1:]] + distance_matrix_2[sol[:-1], sol[1:]]) for sol, _ in archive])\n    entropy = np.array([len(np.unique(sol)) / len(sol) for sol, _ in archive])\n    scores = (1 / (1 + objectives[:, 0])) * (1 / (1 + objectives[:, 1])) * entropy * (1 / (1 + tour_lengths))\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: probabilistic node insertion with multi-segment crossover\n    if n > 5:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Probabilistic node insertion\n        if random.random() < 0.4:\n            insert_pos = random.randint(0, len(segment1))\n            node_to_insert = random.choice(segment2)\n            segment1 = np.insert(segment1, insert_pos, node_to_insert)\n\n        # Multi-segment crossover\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a hybrid local search combining node insertion with a randomized segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding = np.zeros(len(objectives))\n    crowding[0] = crowding[-1] = float('inf')\n\n    for i in range(1, len(objectives) - 1):\n        crowding[i] = abs(objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0] + 1e-10)\n\n    # Select solution with minimum crowding distance\n    min_crowding_idx = np.argmin(crowding)\n    base_solution = archive[sorted_indices[min_crowding_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion with randomized segment rotation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Rotate the segment\n        rotate_amount = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        rotated_segment = np.roll(segment, rotate_amount)\n\n        # Insert the rotated segment at a random position\n        new_solution = np.concatenate([\n            new_solution[:i],\n            rotated_segment,\n            new_solution[j:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7428063261240776,
            0.2596457600593567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding = np.zeros(len(objectives))\n    crowding[0] = crowding[-1] = float('inf')\n\n    for i in range(1, len(objectives) - 1):\n        crowding[i] = abs(objectives_sorted[i+1, 0] - objectives_sorted[i-1, 0]) / (objectives_sorted[-1, 0] - objectives_sorted[0, 0] + 1e-10)\n\n    # Select solution with minimum crowding distance\n    min_crowding_idx = np.argmin(crowding)\n    base_solution = archive[sorted_indices[min_crowding_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: node insertion with randomized segment rotation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Rotate the segment\n        rotate_amount = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n        rotated_segment = np.roll(segment, rotate_amount)\n\n        # Insert the rotated segment at a random position\n        new_solution = np.concatenate([\n            new_solution[:i],\n            rotated_segment,\n            new_solution[j:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based ranking to prioritize non-dominated solutions, then applies a hybrid local search combining a probabilistic segment insertion with a guided edge swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_index = random.choice(non_dominated)\n    else:\n        selected_index = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: probabilistic segment insertion with guided edge swap\n        segment_length = random.randint(2, min(4, n-2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Guided edge swap based on distance improvement\n        if n > 3 and random.random() < 0.5:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            a, b = swap_positions\n            current_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n            new_cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] + \\\n                       distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n            if new_cost < current_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8826306137979479,
            0.4134204387664795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution if available\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_index = random.choice(non_dominated)\n    else:\n        selected_index = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: probabilistic segment insertion with guided edge swap\n        segment_length = random.randint(2, min(4, n-2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Guided edge swap based on distance improvement\n        if n > 3 and random.random() < 0.5:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            a, b = swap_positions\n            current_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + \\\n                           distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n            new_cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] + \\\n                       distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n            if new_cost < current_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal, node insertion, and edge swapping with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.7, 0.3]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8259190783731339,
            0.08929377794265747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.7, 0.3]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping with adaptive segment sizes and probabilistic edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with adaptive parameters\n    if n > 6:\n        # Adaptive multi-segment rotation\n        segment_size = max(2, min(5, n // 4))\n        a, b = sorted(random.sample(range(n - segment_size), 2))\n        segment1 = new_solution[a:a+segment_size]\n        segment2 = new_solution[b:b+segment_size]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a+segment_size:b], segment1, new_solution[b+segment_size:]])\n\n        # Probabilistic selective edge flipping\n        flip_prob = min(0.5, 0.1 * n)\n        for i in range(1, n-1):\n            if random.random() < flip_prob:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9082721435079036,
            0.25137972831726074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search with adaptive parameters\n    if n > 6:\n        # Adaptive multi-segment rotation\n        segment_size = max(2, min(5, n // 4))\n        a, b = sorted(random.sample(range(n - segment_size), 2))\n        segment1 = new_solution[a:a+segment_size]\n        segment2 = new_solution[b:b+segment_size]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[a+segment_size:b], segment1, new_solution[b+segment_size:]])\n\n        # Probabilistic selective edge flipping\n        flip_prob = min(0.5, 0.1 * n)\n        for i in range(1, n-1):\n            if random.random() < flip_prob:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining a randomized 3-opt move with a guided segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    scores = [(obj[0]/max_obj1 + obj[1]/max_obj2, sol) for sol, obj in archive]\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Randomized 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Reconstruct with segments in different order\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment2,\n            segment1,\n            new_solution[k:]\n        ])\n\n        # Guided segment relocation\n        if random.random() < 0.7:\n            reloc_pos = random.randint(0, n - 3)\n            segment = new_solution[reloc_pos:reloc_pos+3]\n            new_solution = np.concatenate([\n                new_solution[:reloc_pos],\n                new_solution[reloc_pos+3:],\n                segment\n            ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7188878556101804,
            0.19949555397033691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    scores = [(obj[0]/max_obj1 + obj[1]/max_obj2, sol) for sol, obj in archive]\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Randomized 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Reconstruct with segments in different order\n        new_solution = np.concatenate([\n            new_solution[:i],\n            segment2,\n            segment1,\n            new_solution[k:]\n        ])\n\n        # Guided segment relocation\n        if random.random() < 0.7:\n            reloc_pos = random.randint(0, n - 3)\n            segment = new_solution[reloc_pos:reloc_pos+3]\n            new_solution = np.concatenate([\n                new_solution[:reloc_pos],\n                new_solution[reloc_pos+3:],\n                segment\n            ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a novel local search combining segment rotation, node insertion, and a guided edge swap operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for exploration)\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_obj1 = np.sort(objectives[:, 0])\n    sorted_obj2 = np.sort(objectives[:, 1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1] - sorted_obj1[i-1]\n            dist2 = sorted_obj2[i+1] - sorted_obj2[i-1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(1, j-i)\n    segment = new_solution[i:j]\n    new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion\n    a, b = sorted(random.sample(range(n), 2))\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    new_solution = np.insert(new_solution, b, node)\n\n    # Guided edge swap\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8421691464522756,
            0.30291175842285156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for exploration)\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_obj1 = np.sort(objectives[:, 0])\n    sorted_obj2 = np.sort(objectives[:, 1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1] - sorted_obj1[i-1]\n            dist2 = sorted_obj2[i+1] - sorted_obj2[i-1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(1, j-i)\n    segment = new_solution[i:j]\n    new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n    # Node insertion\n    a, b = sorted(random.sample(range(n), 2))\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    new_solution = np.insert(new_solution, b, node)\n\n    # Guided edge swap\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid score combining objective values and solution diversity, then applies a novel local search operator combining a multi-segment swap with a dynamic edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid score selection\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives\n        norm_obj = (obj[0] / (max(o[0] for _, o in archive) + 1e-6),\n                    obj[1] / (max(o[1] for _, o in archive) + 1e-6))\n        # Calculate diversity score based on solution structure\n        diversity = np.mean([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        diversity += np.mean([distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        scores.append(norm_obj[0] * norm_obj[1] * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Multi-segment swap\n        k = min(3, n // 4)\n        segments = sorted(random.sample(range(1, n), k))\n        segments = [0] + segments + [n]\n\n        # Create a new order by shuffling segments\n        shuffled_segments = random.sample(range(1, len(segments)), len(segments)-1)\n        new_order = []\n        for i in range(len(shuffled_segments)):\n            start, end = segments[i], segments[i+1]\n            segment = base_solution[start:end]\n            if random.random() > 0.5:\n                segment = segment[::-1]  # Dynamic edge reversal\n            new_order.extend(segment)\n\n        new_solution = np.array(new_order)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9028934324607216,
            4.778765022754669
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid score selection\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives\n        norm_obj = (obj[0] / (max(o[0] for _, o in archive) + 1e-6),\n                    obj[1] / (max(o[1] for _, o in archive) + 1e-6))\n        # Calculate diversity score based on solution structure\n        diversity = np.mean([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        diversity += np.mean([distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)])\n        scores.append(norm_obj[0] * norm_obj[1] * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Multi-segment swap\n        k = min(3, n // 4)\n        segments = sorted(random.sample(range(1, n), k))\n        segments = [0] + segments + [n]\n\n        # Create a new order by shuffling segments\n        shuffled_segments = random.sample(range(1, len(segments)), len(segments)-1)\n        new_order = []\n        for i in range(len(shuffled_segments)):\n            start, end = segments[i], segments[i+1]\n            segment = base_solution[start:end]\n            if random.random() > 0.5:\n                segment = segment[::-1]  # Dynamic edge reversal\n            new_order.extend(segment)\n\n        new_solution = np.array(new_order)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and node centrality, then applies a hybrid local search combining node relocation with a segment from another solution, followed by a segment reversal and edge insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate node centrality based on distance matrices\n    centrality = np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1)\n    centrality_scores = [centrality[node] for node in archive[0][0]]\n\n    # Select solution with high centrality nodes\n    selected_idx = np.argmax([np.mean([centrality_scores[i] for i in sol]) for sol, _ in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Relocate a segment from another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.delete(new_solution, j)\n    insert_pos = random.randint(0, n-2)\n    if insert_pos >= i:\n        insert_pos += 1\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8620943089223017,
            0.9622070789337158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate node centrality based on distance matrices\n    centrality = np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1)\n    centrality_scores = [centrality[node] for node in archive[0][0]]\n\n    # Select solution with high centrality nodes\n    selected_idx = np.argmax([np.mean([centrality_scores[i] for i in sol]) for sol, _ in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Relocate a segment from another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Edge insertion\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.delete(new_solution, j)\n    insert_pos = random.randint(0, n-2)\n    if insert_pos >= i:\n        insert_pos += 1\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator combining adaptive segment rotation with a probabilistic k-opt move to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_index = np.argmin(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        # Rotate segment with probability based on segment length\n        if random.random() < (k / n):\n            rotate_amount = random.randint(1, k-1)\n            segment = np.roll(segment, rotate_amount)\n\n        # Insert at random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + k],\n            new_solution[insert_pos + k:]\n        ])\n\n        # Probabilistic k-opt move (k=3)\n        if random.random() < 0.4 and n > 5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[c:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.952135701056884,
            0.10517460107803345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_index = np.argmin(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        # Rotate segment with probability based on segment length\n        if random.random() < (k / n):\n            rotate_amount = random.randint(1, k-1)\n            segment = np.roll(segment, rotate_amount)\n\n        # Insert at random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + k],\n            new_solution[insert_pos + k:]\n        ])\n\n        # Probabilistic k-opt move (k=3)\n        if random.random() < 0.4 and n > 5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[c:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel adaptive weighting scheme that dynamically adjusts based on the current distribution of objectives, then applies a hybrid local search combining a multi-segment shuffle, a node insertion with inversion, and a distance-aware edge swap to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighting based on objective distribution\n    objectives = [obj for (sol, obj) in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj1_range = max(obj1_values) - min(obj1_values) + 1e-6\n    obj2_range = max(obj2_values) - min(obj2_values) + 1e-6\n\n    # Select solution with potential for improvement using adaptive weights\n    selected_idx = 0\n    max_score = -float('inf')\n    for i, obj in enumerate(objectives):\n        # Adaptive weight based on relative position in objective space\n        w1 = (obj[0] - min(obj1_values)) / obj1_range\n        w2 = (obj[1] - min(obj2_values)) / obj2_range\n        score = w1 * obj[0] + w2 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle\n    if n > 3:\n        num_segments = random.randint(2, min(4, n//2))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n        segments = []\n        start = 0\n        for idx in segment_indices:\n            segments.append(new_solution[start:idx])\n            start = idx\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Node insertion with inversion\n    if n > 2:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos:][::-1]])\n\n    # Distance-aware edge swap\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Only swap if both objectives improve\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.6266357352674211,
            0.7023882269859314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weighting based on objective distribution\n    objectives = [obj for (sol, obj) in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj1_range = max(obj1_values) - min(obj1_values) + 1e-6\n    obj2_range = max(obj2_values) - min(obj2_values) + 1e-6\n\n    # Select solution with potential for improvement using adaptive weights\n    selected_idx = 0\n    max_score = -float('inf')\n    for i, obj in enumerate(objectives):\n        # Adaptive weight based on relative position in objective space\n        w1 = (obj[0] - min(obj1_values)) / obj1_range\n        w2 = (obj[1] - min(obj2_values)) / obj2_range\n        score = w1 * obj[0] + w2 * obj[1]\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle\n    if n > 3:\n        num_segments = random.randint(2, min(4, n//2))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n        segments = []\n        start = 0\n        for idx in segment_indices:\n            segments.append(new_solution[start:idx])\n            start = idx\n        segments.append(new_solution[start:])\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Node insertion with inversion\n    if n > 2:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n        if random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos:][::-1]])\n\n    # Distance-aware edge swap\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Only swap if both objectives improve\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm selects a solution from the archive based on a novelty score combining objective diversity and solution quality, then applies a hybrid local search operator that combines a multi-segment crossover with a dynamic edge reallocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate novelty score for each solution\n    objectives = [obj for (sol, obj) in archive]\n    obj_range = [max(obj[m] for obj in objectives) - min(obj[m] for obj in objectives) for m in range(2)]\n    novelty_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        diversity = sum(abs(obj[m] - obj[m]) / (obj_range[m] + 1e-6) for m in range(2))\n        quality = sum(obj[m] / (obj_range[m] + 1e-6) for m in range(2))\n        novelty_scores.append(diversity * quality)\n\n    # Select solution with highest novelty score\n    selected_idx = np.argmax(novelty_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment crossover with dynamic edge reallocation\n    if n > 4:\n        # Multi-segment crossover\n        points = sorted(random.sample(range(1, n-1), 2))\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            new_solution[points[0]:points[1]] = other_solution[points[0]:points[1]]\n\n        # Dynamic edge reallocation\n        k = random.randint(2, min(5, n//2))\n        indices = sorted(random.sample(range(n), k))\n        for i in range(1, len(indices)):\n            if random.random() < 0.5:\n                new_solution[indices[i-1]:indices[i]] = new_solution[indices[i-1]:indices[i]][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9864427028875287,
            0.32621508836746216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate novelty score for each solution\n    objectives = [obj for (sol, obj) in archive]\n    obj_range = [max(obj[m] for obj in objectives) - min(obj[m] for obj in objectives) for m in range(2)]\n    novelty_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        diversity = sum(abs(obj[m] - obj[m]) / (obj_range[m] + 1e-6) for m in range(2))\n        quality = sum(obj[m] / (obj_range[m] + 1e-6) for m in range(2))\n        novelty_scores.append(diversity * quality)\n\n    # Select solution with highest novelty score\n    selected_idx = np.argmax(novelty_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment crossover with dynamic edge reallocation\n    if n > 4:\n        # Multi-segment crossover\n        points = sorted(random.sample(range(1, n-1), 2))\n        if len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n            new_solution[points[0]:points[1]] = other_solution[points[0]:points[1]]\n\n        # Dynamic edge reallocation\n        k = random.randint(2, min(5, n//2))\n        indices = sorted(random.sample(range(n), k))\n        for i in range(1, len(indices)):\n            if random.random() < 0.5:\n                new_solution[indices[i-1]:indices[i]] = new_solution[indices[i-1]:indices[i]][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The new algorithm selects solutions from the archive based on a combination of objective improvement potential and tour structure entropy, then applies a novel hybrid local search combining adaptive segment inversion and probabilistic edge relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    avg_obj = np.mean(objectives, axis=0)\n\n    selection_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Objective improvement potential (closer to the average objective)\n        improvement_potential = np.sum(np.abs(obj - avg_obj))\n\n        # Tour structure entropy (diversity in node ordering)\n        entropy = 0\n        for j in range(len(sol)-1):\n            entropy += abs(sol[j] - sol[j+1]) / len(sol)\n\n        selection_scores.append((improvement_potential, entropy, i))\n\n    # Select solution with highest combined score\n    selected_idx = max(selection_scores, key=lambda x: x[0] + 0.5 * x[1])[2]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and probabilistic edge relocation\n    if n > 4:\n        # Adaptive segment inversion\n        segment_length = random.randint(2, min(5, n//2))\n        start_pos = random.randint(0, n - segment_length)\n        new_solution[start_pos:start_pos+segment_length] = np.flip(new_solution[start_pos:start_pos+segment_length])\n\n        # Probabilistic edge relocation\n        for i in range(1, n-1):\n            if random.random() < 0.2:  # 20% chance to relocate\n                new_pos = random.randint(0, n-1)\n                if new_pos != i:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8206034019056712,
            0.5174960494041443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and tour structure entropy\n    objectives = np.array([obj for _, obj in archive])\n    avg_obj = np.mean(objectives, axis=0)\n\n    selection_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Objective improvement potential (closer to the average objective)\n        improvement_potential = np.sum(np.abs(obj - avg_obj))\n\n        # Tour structure entropy (diversity in node ordering)\n        entropy = 0\n        for j in range(len(sol)-1):\n            entropy += abs(sol[j] - sol[j+1]) / len(sol)\n\n        selection_scores.append((improvement_potential, entropy, i))\n\n    # Select solution with highest combined score\n    selected_idx = max(selection_scores, key=lambda x: x[0] + 0.5 * x[1])[2]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and probabilistic edge relocation\n    if n > 4:\n        # Adaptive segment inversion\n        segment_length = random.randint(2, min(5, n//2))\n        start_pos = random.randint(0, n - segment_length)\n        new_solution[start_pos:start_pos+segment_length] = np.flip(new_solution[start_pos:start_pos+segment_length])\n\n        # Probabilistic edge relocation\n        for i in range(1, n-1):\n            if random.random() < 0.2:  # 20% chance to relocate\n                new_pos = random.randint(0, n-1)\n                if new_pos != i:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining adaptive segment relocation and objective-aware edge perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement and good diversity\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation and objective-aware edge perturbation\n    if n > 3:\n        # Adaptive segment relocation\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Objective-aware edge perturbation\n        obj_weights = np.array(archive[selected_idx][1])\n        obj_weights = obj_weights / (np.sum(obj_weights) + 1e-6)\n\n        for i in range(n-1):\n            if random.random() < obj_weights[0]:\n                j = random.randint(0, n-2)\n                if abs(i - j) > 1:\n                    new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                        new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n                    )\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6752051538535758,
            0.2212347388267517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement and good diversity\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation and objective-aware edge perturbation\n    if n > 3:\n        # Adaptive segment relocation\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Objective-aware edge perturbation\n        obj_weights = np.array(archive[selected_idx][1])\n        obj_weights = obj_weights / (np.sum(obj_weights) + 1e-6)\n\n        for i in range(n-1):\n            if random.random() < obj_weights[0]:\n                j = random.randint(0, n-2)\n                if abs(i - j) > 1:\n                    new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n                        new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n                    )\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a novel local search combining partial path reversal, node insertion, and a guided crossover with a non-dominated solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using diversity-aware selection\n    objectives = [obj for (sol, obj) in archive]\n    crowding_distances = [sum(obj) for obj in objectives]  # Simple diversity metric\n    selected_idx = crowding_distances.index(max(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: partial path reversal, node insertion, and guided crossover\n    n = len(new_solution)\n\n    # Step 1: Partial path reversal\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    new_solution[i:j] = segment\n\n    # Step 2: Node insertion\n    if n > 3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Guided crossover with a non-dominated solution\n    if len(archive) > 1:\n        non_dominated = [i for i, (sol, obj) in enumerate(archive)\n                        if all(obj[0] <= other_obj[0] and obj[1] <= other_obj[1] and (obj[0] < other_obj[0] or obj[1] < other_obj[1])\n                              for other_obj in objectives)]\n        if non_dominated:\n            other_solution = archive[random.choice(non_dominated)][0]\n            crossover_point = random.randint(1, n-1)\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8647253686210588,
            0.31397902965545654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using diversity-aware selection\n    objectives = [obj for (sol, obj) in archive]\n    crowding_distances = [sum(obj) for obj in objectives]  # Simple diversity metric\n    selected_idx = crowding_distances.index(max(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: partial path reversal, node insertion, and guided crossover\n    n = len(new_solution)\n\n    # Step 1: Partial path reversal\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    new_solution[i:j] = segment\n\n    # Step 2: Node insertion\n    if n > 3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Guided crossover with a non-dominated solution\n    if len(archive) > 1:\n        non_dominated = [i for i, (sol, obj) in enumerate(archive)\n                        if all(obj[0] <= other_obj[0] and obj[1] <= other_obj[1] and (obj[0] < other_obj[0] or obj[1] < other_obj[1])\n                              for other_obj in objectives)]\n        if non_dominated:\n            other_solution = archive[random.choice(non_dominated)][0]\n            crossover_point = random.randint(1, n-1)\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a solution from the archive based on the lowest combined objective values, then applies a hybrid local search combining path inversion, node relocation, and a novel \"objective-balanced edge crossover\" to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low potential for further improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: path inversion, node relocation, and objective-balanced edge crossover\n    n = len(new_solution)\n\n    # Step 1: Path inversion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node relocation\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced edge crossover\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_balances = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]) + 1e-6)\n        for k in range(n):\n            if random.random() < obj_balances[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9620367184504678,
            0.12156176567077637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with low potential for further improvement\n    objectives = [obj for (sol, obj) in archive]\n    min_obj = min(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == min_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: path inversion, node relocation, and objective-balanced edge crossover\n    n = len(new_solution)\n\n    # Step 1: Path inversion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node relocation\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced edge crossover\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_balances = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]) + 1e-6)\n        for k in range(n):\n            if random.random() < obj_balances[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search combining edge swaps, segment reversal, and a novel \"path merging\" operator to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the non-dominated front\n    objectives = [obj for (sol, obj) in archive]\n    dominated = [False] * len(objectives)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1] and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                dominated[i] = True\n                break\n    nondominated_indices = [i for i in range(len(objectives)) if not dominated[i]]\n    if not nondominated_indices:\n        nondominated_indices = range(len(objectives))\n    selected_idx = random.choice(nondominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Path merging (novel operator)\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:crossover_point], other_solution[crossover_point:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8721289376933778,
            0.20223009586334229
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the non-dominated front\n    objectives = [obj for (sol, obj) in archive]\n    dominated = [False] * len(objectives)\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1] and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                dominated[i] = True\n                break\n    nondominated_indices = [i for i in range(len(objectives)) if not dominated[i]]\n    if not nondominated_indices:\n        nondominated_indices = range(len(objectives))\n    selected_idx = random.choice(nondominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Path merging (novel operator)\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:crossover_point], other_solution[crossover_point:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge relocation with a randomized segment reversal and a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores with different weights\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Different weighting to focus more on the first objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal and probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.5\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n        else:\n            reversed_segment = segment\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:\n            swap_pos1, swap_pos2 = random.sample(range(n), 2)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7991080497173475,
            0.10718536376953125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores with different weights\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Different weighting to focus more on the first objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal and probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.5\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n        else:\n            reversed_segment = segment\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3:\n            swap_pos1, swap_pos2 = random.sample(range(n), 2)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest normalized objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" with adaptive weights to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using normalized objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_obj = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and adaptive objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Adaptive objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0] * (1 + random.uniform(-0.1, 0.1)):\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9461191457766218,
            0.15126579999923706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using normalized objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    combined_obj = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and adaptive objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Adaptive objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0] * (1 + random.uniform(-0.1, 0.1)):\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This new algorithm selects a solution from the archive based on a non-linear combination of objectives, then applies a hybrid local search combining segment reversal with edge exchange and node insertion from another solution's segment, while ensuring feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.4, 0.6]\n    weighted_scores = [obj[0] * (w1 ** 2) + obj[1] * (w2 ** 2) for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8976749496999689,
            0.07374000549316406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.4, 0.6]\n    weighted_scores = [obj[0] * (w1 ** 2) + obj[1] * (w2 ** 2) for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and a novel \"objective-weighted edge swap\" to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and objective-weighted edge swap\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge swap\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        obj_weights = np.array(archive[selected_idx][1]) / (np.array(archive[selected_idx][1]) + np.array(archive[other_idx][1]))\n        for k in range(n):\n            if random.random() < obj_weights[0]:\n                new_solution[k] = other_solution[k]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced objective values, then applies a novel \"objective-aware segment rotation\" local search that rotates segments of the tour while considering the trade-off between the two objectives, and ensures feasibility by maintaining node uniqueness and tour completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    objectives = [obj for (sol, obj) in archive]\n    balanced_solutions = [(i, abs(obj[0] - obj[1])) for i, obj in enumerate(objectives)]\n    selected_idx = min(balanced_solutions, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n > 3:\n        # Objective-aware segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Rotate segment based on objective trade-off\n        if segment_cost1 > segment_cost2:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        # Insert rotated segment back\n        new_solution[a:b] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.818087539444976,
            0.27152085304260254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives\n    objectives = [obj for (sol, obj) in archive]\n    balanced_solutions = [(i, abs(obj[0] - obj[1])) for i, obj in enumerate(objectives)]\n    selected_idx = min(balanced_solutions, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n > 3:\n        # Objective-aware segment rotation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Rotate segment based on objective trade-off\n        if segment_cost1 > segment_cost2:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        # Insert rotated segment back\n        new_solution[a:b] = segment\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel local search operator combining a k-opt exchange with a path reversal and a node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # k-opt exchange (k=3)\n        k = 3\n        indices = random.sample(range(n), k)\n        indices.sort()\n        new_solution[indices] = new_solution[indices[::-1]]\n\n        # Path reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion\n        node = new_solution[random.randint(0, n-1)]\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:-1]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7961355014001513,
            0.24802684783935547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # k-opt exchange (k=3)\n        k = 3\n        indices = random.sample(range(n), k)\n        indices.sort()\n        new_solution[indices] = new_solution[indices[::-1]]\n\n        # Path reversal\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Node insertion\n        node = new_solution[random.randint(0, n-1)]\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:-1]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware selection criterion that combines crowding distance with solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection score combining crowding distance and solution quality\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n    quality_scores = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n        quality_scores += np.array([obj[m] for obj in objectives])\n\n    # Normalize scores and combine\n    normalized_crowding = (crowding_distances - np.min(crowding_distances)) / (np.max(crowding_distances) - np.min(crowding_distances) + 1e-10)\n    normalized_quality = (np.max(quality_scores) - quality_scores) / (np.max(quality_scores) - np.min(quality_scores) + 1e-10)\n    selection_scores = 0.6 * normalized_crowding + 0.4 * normalized_quality\n\n    # Select solution with highest selection score\n    selected_index = np.argmax(selection_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Novel local search: probabilistic segment rotation with guided edge insertion\n        # Select a segment to rotate\n        segment_length = random.randint(2, min(5, n//2))\n        start_pos = random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Rotate the segment left or right with probability\n        if random.random() < 0.5:\n            segment = np.concatenate([segment[1:], segment[:1]])\n        else:\n            segment = np.concatenate([segment[-1:], segment[:-1]])\n\n        # Insert the rotated segment at a guided position\n        # Calculate insertion cost for all possible positions\n        insertion_costs = []\n        for pos in range(n - segment_length + 1):\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos + segment_length:]\n            ])\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            insertion_costs.append(cost1 + cost2)\n\n        # Select the position with minimum insertion cost\n        best_pos = np.argmin(insertion_costs)\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos + segment_length:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9362176290326565,
            3.4518495202064514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection score combining crowding distance and solution quality\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n    quality_scores = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n        quality_scores += np.array([obj[m] for obj in objectives])\n\n    # Normalize scores and combine\n    normalized_crowding = (crowding_distances - np.min(crowding_distances)) / (np.max(crowding_distances) - np.min(crowding_distances) + 1e-10)\n    normalized_quality = (np.max(quality_scores) - quality_scores) / (np.max(quality_scores) - np.min(quality_scores) + 1e-10)\n    selection_scores = 0.6 * normalized_crowding + 0.4 * normalized_quality\n\n    # Select solution with highest selection score\n    selected_index = np.argmax(selection_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Novel local search: probabilistic segment rotation with guided edge insertion\n        # Select a segment to rotate\n        segment_length = random.randint(2, min(5, n//2))\n        start_pos = random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Rotate the segment left or right with probability\n        if random.random() < 0.5:\n            segment = np.concatenate([segment[1:], segment[:1]])\n        else:\n            segment = np.concatenate([segment[-1:], segment[:-1]])\n\n        # Insert the rotated segment at a guided position\n        # Calculate insertion cost for all possible positions\n        insertion_costs = []\n        for pos in range(n - segment_length + 1):\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos + segment_length:]\n            ])\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            insertion_costs.append(cost1 + cost2)\n\n        # Select the position with minimum insertion cost\n        best_pos = np.argmin(insertion_costs)\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos + segment_length:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions of the Pareto front, then applies a hybrid local search combining a randomized 3-opt move with a guided segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1]][i] - objectives[sorted_idx[j-1]][i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: randomized 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Guided segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Calculate improvement in both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        reversed_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.2:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.6828435215269619,
            0.31809520721435547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1]][i] - objectives[sorted_idx[j-1]][i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: randomized 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Guided segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Calculate improvement in both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        reversed_segment = new_solution[start:end][::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.2:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    normalized_scores = [(obj[0] + obj[1]) / 2 for obj in objectives]\n    selected_idx = normalized_scores.index(max(normalized_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8041116778147137,
            0.0862765908241272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    normalized_scores = [(obj[0] + obj[1]) / 2 for obj in objectives]\n    selected_idx = normalized_scores.index(max(normalized_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator combining adaptive segment swaps with a probabilistic insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using a combination of objectives and diversity\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [sum(abs(sol[i] - archive[0][0][i]) for i in range(len(sol))) for (sol, obj) in archive]\n    combined_scores = [0.5 * (obj[0] + obj[1]) + 0.5 * div for (obj, div) in zip(objectives, diversity_scores)]\n    selected_idx = combined_scores.index(max(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment swaps\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[end:]\n        ])\n\n    # Probabilistic insertion heuristic\n    if random.random() < 0.3:\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6690562320251575,
            0.6378379464149475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using a combination of objectives and diversity\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [sum(abs(sol[i] - archive[0][0][i]) for i in range(len(sol))) for (sol, obj) in archive]\n    combined_scores = [0.5 * (obj[0] + obj[1]) + 0.5 * div for (obj, div) in zip(objectives, diversity_scores)]\n    selected_idx = combined_scores.index(max(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment swaps\n    if n > 4:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_pos = random.randint(0, n - segment_length)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[end:]\n        ])\n\n    # Probabilistic insertion heuristic\n    if random.random() < 0.3:\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates and adding missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined hypervolume contribution and angle-based selection metric, then applies a novel local search operator combining a k-swap operation with a dynamic segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate hypervolume contribution\n        objectives = [obj for _, obj in archive]\n        ref_point = (max(obj[0] for obj in objectives) * 1.1, max(obj[1] for obj in objectives) * 1.1)\n        hv_contributions = []\n        for i in range(len(archive)):\n            temp_archive = archive[:i] + archive[i+1:]\n            temp_objectives = [obj for _, obj in temp_archive]\n            temp_ref = (max(obj[0] for obj in temp_objectives) * 1.1, max(obj[1] for obj in temp_objectives) * 1.1)\n            hv = 0\n            for obj in temp_objectives:\n                hv += (temp_ref[0] - obj[0]) * (temp_ref[1] - obj[1])\n            hv_contributions.append(hv)\n\n        # Calculate angle-based metric\n        angles = []\n        for _, obj in archive:\n            angles.append(np.arctan2(obj[1], obj[0]))\n\n        # Combine metrics and select solution\n        combined_metrics = [hv + angle for hv, angle in zip(hv_contributions, angles)]\n        selected_idx = np.argmax(combined_metrics)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic k-swap operation (k varies between 2 and 4)\n        k = random.randint(2, 4)\n        indices = random.sample(range(n), k)\n        for i in range(k//2):\n            new_solution[indices[i]], new_solution[indices[k-i-1]] = new_solution[indices[k-i-1]], new_solution[indices[i]]\n\n        # Dynamic segment relocation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9670090894439693,
            4.5272470116615295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate hypervolume contribution\n        objectives = [obj for _, obj in archive]\n        ref_point = (max(obj[0] for obj in objectives) * 1.1, max(obj[1] for obj in objectives) * 1.1)\n        hv_contributions = []\n        for i in range(len(archive)):\n            temp_archive = archive[:i] + archive[i+1:]\n            temp_objectives = [obj for _, obj in temp_archive]\n            temp_ref = (max(obj[0] for obj in temp_objectives) * 1.1, max(obj[1] for obj in temp_objectives) * 1.1)\n            hv = 0\n            for obj in temp_objectives:\n                hv += (temp_ref[0] - obj[0]) * (temp_ref[1] - obj[1])\n            hv_contributions.append(hv)\n\n        # Calculate angle-based metric\n        angles = []\n        for _, obj in archive:\n            angles.append(np.arctan2(obj[1], obj[0]))\n\n        # Combine metrics and select solution\n        combined_metrics = [hv + angle for hv, angle in zip(hv_contributions, angles)]\n        selected_idx = np.argmax(combined_metrics)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic k-swap operation (k varies between 2 and 4)\n        k = random.randint(2, 4)\n        indices = random.sample(range(n), k)\n        for i in range(k//2):\n            new_solution[indices[i]], new_solution[indices[k-i-1]] = new_solution[indices[k-i-1]], new_solution[indices[i]]\n\n        # Dynamic segment relocation\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{The algorithm selects a solution from the archive based on a Pareto-dominance criterion, then applies a hybrid local search operator combining edge exchange with a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge exchange with randomized segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_segment = np.flip(segment) if random.random() < 0.5 else segment\n\n        # Reinsert the segment at a different position\n        insert_pos = random.randint(0, n - len(new_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_segment,\n            new_solution[insert_pos + len(new_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7345667987725364,
            0.3029707670211792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge exchange with randomized segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        new_segment = np.flip(segment) if random.random() < 0.5 else segment\n\n        # Reinsert the segment at a different position\n        insert_pos = random.randint(0, n - len(new_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_segment,\n            new_solution[insert_pos + len(new_segment):]\n        ])\n\n        # Ensure feasibility by removing duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a non-linear combination of objectives, then applies a hybrid local search combining segment reversal with edge exchange and node insertion from another solution's segment, while ensuring feasibility by validating the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.4, 0.6]\n    weighted_scores = [obj[0] * (w1 ** 2) + obj[1] * (w2 ** 2) for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment relocation, node inversion, and path crossover with another solution while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [sum(abs(sol[i] - sol[i+1]) for i in range(len(sol)-1)) for (sol, obj) in archive]\n    combined_scores = [obj[0] * 0.5 + obj[1] * 0.5 + div * 0.2 for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        c = random.randint(0, n-len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d:e] = new_solution[d:e][::-1]\n\n        f = random.randint(0, n-1)\n        g = random.randint(0, n-1)\n        if f != g:\n            new_solution[f], new_solution[g] = new_solution[g], new_solution[f]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9187837061530401,
            0.9819806218147278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [sum(abs(sol[i] - sol[i+1]) for i in range(len(sol)-1)) for (sol, obj) in archive]\n    combined_scores = [obj[0] * 0.5 + obj[1] * 0.5 + div * 0.2 for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        c = random.randint(0, n-len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d:e] = new_solution[d:e][::-1]\n\n        f = random.randint(0, n-1)\n        g = random.randint(0, n-1)\n        if f != g:\n            new_solution[f], new_solution[g] = new_solution[g], new_solution[f]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic score combining objectives with adaptive weights, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a high-quality solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using dynamic weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = np.max(objectives, axis=0)\n    weights = [0.4, 0.6] if max_obj[0] > max_obj[1] else [0.7, 0.3]\n    weighted_scores = [w1 * (obj[0]/max_obj[0]) + w2 * (obj[1]/max_obj[1]) for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with a high-quality solution\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        other_solution = sorted_archive[min(2, len(sorted_archive)-1)][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9853067038391838,
            0.15848380327224731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using dynamic weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = np.max(objectives, axis=0)\n    weights = [0.4, 0.6] if max_obj[0] > max_obj[1] else [0.7, 0.3]\n    weighted_scores = [w1 * (obj[0]/max_obj[0]) + w2 * (obj[1]/max_obj[1]) for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with a high-quality solution\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        other_solution = sorted_archive[min(2, len(sorted_archive)-1)][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dominance-based score that combines both objectives, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance-based scores\n    scores = []\n    for sol, obj in archive:\n        score = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                score += 1\n        scores.append(score)\n\n    # Select solution with highest score (most dominated solutions)\n    selected_index = np.argmax(scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        if random.random() < 0.6:\n            # Perform 3-opt\n            a, b, c, d, e, f = sorted(random.sample(range(n), 6))\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:c],\n                new_solution[d:e],\n                new_solution[a:b],\n                new_solution[f:],\n                new_solution[c:d],\n                new_solution[e:f]\n            ])\n\n        # Probabilistic node insertion\n        if random.random() < 0.4 and n > 4:\n            node = random.choice(new_solution)\n            mask = new_solution != node\n            new_solution = new_solution[mask]\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8408768714198911,
            1.0336152911186218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance-based scores\n    scores = []\n    for sol, obj in archive:\n        score = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                score += 1\n        scores.append(score)\n\n    # Select solution with highest score (most dominated solutions)\n    selected_index = np.argmax(scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        if random.random() < 0.6:\n            # Perform 3-opt\n            a, b, c, d, e, f = sorted(random.sample(range(n), 6))\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:c],\n                new_solution[d:e],\n                new_solution[a:b],\n                new_solution[f:],\n                new_solution[c:d],\n                new_solution[e:f]\n            ])\n\n        # Probabilistic node insertion\n        if random.random() < 0.4 and n > 4:\n            node = random.choice(new_solution)\n            mask = new_solution != node\n            new_solution = new_solution[mask]\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator combining adaptive segment rotation with a probabilistic k-opt move to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_index = np.argmin(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        # Rotate segment with probability based on segment length\n        if random.random() < (k / n):\n            rotate_amount = random.randint(1, k-1)\n            segment = np.roll(segment, rotate_amount)\n\n        # Insert at random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + k],\n            new_solution[insert_pos + k:]\n        ])\n\n        # Probabilistic k-opt move (k=3)\n        if random.random() < 0.4 and n > 5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[c:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid of Pareto dominance and objective space coverage, then applies a novel local search operator combining adaptive segment reversal with a probabilistic segment swapping mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on hybrid Pareto dominance and objective space coverage\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_index = random.choice(pareto_front)\n    else:\n        coverage_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_index = np.argmax(coverage_scores)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment reversal\n        k = random.randint(2, min(4, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        # Reverse segment with probability based on segment length\n        if random.random() < (k / n):\n            segment = segment[::-1]\n\n        # Insert at random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + k],\n            new_solution[insert_pos + k:]\n        ])\n\n        # Probabilistic segment swapping\n        if random.random() < 0.5 and n > 6:\n            a, b = sorted(random.sample(range(n), 2))\n            segment1 = new_solution[a:b]\n            c, d = sorted(random.sample(range(n), 2))\n            segment2 = new_solution[c:d]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                new_solution[b:c],\n                segment1,\n                new_solution[d:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9116605311217109,
            0.5715134739875793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on hybrid Pareto dominance and objective space coverage\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_index = random.choice(pareto_front)\n    else:\n        coverage_scores = np.max(objectives, axis=1) - np.min(objectives, axis=1)\n        selected_index = np.argmax(coverage_scores)\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment reversal\n        k = random.randint(2, min(4, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        # Reverse segment with probability based on segment length\n        if random.random() < (k / n):\n            segment = segment[::-1]\n\n        # Insert at random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + k],\n            new_solution[insert_pos + k:]\n        ])\n\n        # Probabilistic segment swapping\n        if random.random() < 0.5 and n > 6:\n            a, b = sorted(random.sample(range(n), 2))\n            segment1 = new_solution[a:b]\n            c, d = sorted(random.sample(range(n), 2))\n            segment2 = new_solution[c:d]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                new_solution[b:c],\n                segment1,\n                new_solution[d:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive based on Pareto dominance, then applies a novel local search combining segment rotation, node insertion, and guided edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution\n    objectives = [obj for (sol, obj) in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Node insertion\n    node_to_move = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_move]\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node_to_move)\n\n    # Guided edge swap\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, n//2)) % n\n        if new_solution[i] in new_solution[j-1:j+1] or new_solution[j] in new_solution[i-1:i+1]:\n            continue\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8032254992349324,
            0.24095678329467773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution\n    objectives = [obj for (sol, obj) in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = random.choice(range(len(archive)))\n    else:\n        selected_idx = random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Node insertion\n    node_to_move = random.choice(new_solution)\n    new_solution = new_solution[new_solution != node_to_move]\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node_to_move)\n\n    # Guided edge swap\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, n//2)) % n\n        if new_solution[i] in new_solution[j-1:j+1] or new_solution[j] in new_solution[i-1:i+1]:\n            continue\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a hybrid local search combining probabilistic segment inversion with adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate potential improvement scores\n    improvement_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        # Calculate average distance reduction potential\n        dist1 = sum(distance_matrix_1[solutions[i][j], solutions[i][(j+1)%n]] for j in range(n))\n        dist2 = sum(distance_matrix_2[solutions[i][j], solutions[i][(j+1)%n]] for j in range(n))\n        improvement_scores[i] = (dist1 + dist2) / (objectives[i][0] + objectives[i][1])\n\n    # Select solution with highest improvement potential\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic segment inversion with adaptive edge insertion\n    if n > 4:\n        # Probabilistic segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.6:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive edge insertion\n        if random.random() < 0.4 and n > 5:\n            # Find the most distant edge in the tour\n            max_dist = -1\n            max_pos = 0\n            for k in range(n):\n                dist = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_pos = k\n\n            # Insert a new edge by swapping nodes\n            swap_pos = random.randint(1, n-2)\n            if swap_pos != max_pos and swap_pos != (max_pos + 1) % n:\n                new_solution[max_pos], new_solution[swap_pos] = new_solution[swap_pos], new_solution[max_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8308105152718959,
            1.1427159905433655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate potential improvement scores\n    improvement_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        # Calculate average distance reduction potential\n        dist1 = sum(distance_matrix_1[solutions[i][j], solutions[i][(j+1)%n]] for j in range(n))\n        dist2 = sum(distance_matrix_2[solutions[i][j], solutions[i][(j+1)%n]] for j in range(n))\n        improvement_scores[i] = (dist1 + dist2) / (objectives[i][0] + objectives[i][1])\n\n    # Select solution with highest improvement potential\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic segment inversion with adaptive edge insertion\n    if n > 4:\n        # Probabilistic segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.6:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Adaptive edge insertion\n        if random.random() < 0.4 and n > 5:\n            # Find the most distant edge in the tour\n            max_dist = -1\n            max_pos = 0\n            for k in range(n):\n                dist = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_pos = k\n\n            # Insert a new edge by swapping nodes\n            swap_pos = random.randint(1, n-2)\n            if swap_pos != max_pos and swap_pos != (max_pos + 1) % n:\n                new_solution[max_pos], new_solution[swap_pos] = new_solution[swap_pos], new_solution[max_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a non-linear combination of objectives, then applies a hybrid local search combining segment reversal with edge exchange and node insertion from another solution's segment, while ensuring feasibility by validating the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.4, 0.6]\n    weighted_scores = [obj[0] * (w1 ** 2) + obj[1] * (w2 ** 2) for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This new algorithm selects a solution from the archive based on a non-linear ranking of objectives, then applies a hybrid local search combining segment reversal with a probabilistic edge exchange and node insertion from a solution's segment, while ensuring feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    ranks = [np.sum([np.sum(obj[i] < o[i] for o in objectives) for i in range(2)]) for obj in objectives]\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    if len(archive) > 1 and random.random() < 0.3:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8248480977401967,
            5.076399087905884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    ranks = [np.sum([np.sum(obj[i] < o[i] for o in objectives) for i in range(2)]) for obj in objectives]\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    if len(archive) > 1 and random.random() < 0.3:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator combining adaptive segment rotation with a probabilistic k-opt move to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_index = np.argmin(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        k = random.randint(2, min(5, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        # Rotate segment with probability based on segment length\n        if random.random() < (k / n):\n            rotate_amount = random.randint(1, k-1)\n            segment = np.roll(segment, rotate_amount)\n\n        # Insert at random position\n        insert_pos = random.randint(0, n - k)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + k],\n            new_solution[insert_pos + k:]\n        ])\n\n        # Probabilistic k-opt move (k=3)\n        if random.random() < 0.4 and n > 5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[c:]\n            ])\n\n        # Ensure feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator combining adaptive segment reversal with a probabilistic 3-opt move to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.3 * diversity_scores\n    selected_index = np.argmin(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        k = random.randint(2, min(4, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        if random.random() < (k / n):\n            new_solution[i:i+k] = segment[::-1]\n\n        if random.random() < 0.5 and n > 5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[c:]\n            ])\n\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.8161035696506569,
            0.46765148639678955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.3 * diversity_scores\n    selected_index = np.argmin(combined_scores)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        k = random.randint(2, min(4, n-1))\n        i = random.randint(0, n - k)\n        segment = new_solution[i:i+k]\n\n        if random.random() < (k / n):\n            new_solution[i:i+k] = segment[::-1]\n\n        if random.random() < 0.5 and n > 5:\n            a, b, c = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[c:]\n            ])\n\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This new algorithm selects a solution from the archive using a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining edge exchange with a randomized node reinsertion to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n    for i in range(len(objectives)):\n        left_obj = objectives[i-1] if i > 0 else None\n        right_obj = objectives[i+1] if i < len(objectives)-1 else None\n        if left_obj is None or right_obj is None:\n            crowding_distances.append(float('inf'))\n        else:\n            distance = abs(right_obj[0] - left_obj[0]) + abs(right_obj[1] - left_obj[1])\n            crowding_distances.append(distance)\n\n    # Select the solution with the highest crowding distance (most promising for improvement)\n    max_crowding_idx = np.argmax(crowding_distances)\n    base_solution = archive[max_crowding_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange with randomized node reinsertion\n    if n > 4:\n        # Select two non-adjacent edges to exchange\n        i = random.randint(0, n-3)\n        j = random.randint(i+2, n-1)\n\n        # Perform edge exchange\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n        # Randomly select a node and reinsert it at a new position\n        node_to_move = random.choice(new_solution)\n        new_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([\n            new_solution[new_solution != node_to_move],\n            [node_to_move]\n        ])\n\n    # Ensure feasibility by checking for duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6942095565824533,
            0.2279224395751953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    objectives = [obj for _, obj in archive]\n    for i in range(len(objectives)):\n        left_obj = objectives[i-1] if i > 0 else None\n        right_obj = objectives[i+1] if i < len(objectives)-1 else None\n        if left_obj is None or right_obj is None:\n            crowding_distances.append(float('inf'))\n        else:\n            distance = abs(right_obj[0] - left_obj[0]) + abs(right_obj[1] - left_obj[1])\n            crowding_distances.append(distance)\n\n    # Select the solution with the highest crowding distance (most promising for improvement)\n    max_crowding_idx = np.argmax(crowding_distances)\n    base_solution = archive[max_crowding_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge exchange with randomized node reinsertion\n    if n > 4:\n        # Select two non-adjacent edges to exchange\n        i = random.randint(0, n-3)\n        j = random.randint(i+2, n-1)\n\n        # Perform edge exchange\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n        # Randomly select a node and reinsert it at a new position\n        node_to_move = random.choice(new_solution)\n        new_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([\n            new_solution[new_solution != node_to_move],\n            [node_to_move]\n        ])\n\n    # Ensure feasibility by checking for duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objectives (with equal weights) and applies a hybrid local search combining edge relocation with a randomized segment reversal and a probabilistic edge swap to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        operation = random.choice(['segment_reversal', 'edge_swap'])\n\n        if operation == 'segment_reversal':\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            insert_pos = random.randint(0, n - len(reversed_segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                reversed_segment,\n                new_solution[insert_pos:]\n            ])\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                new_solution = base_solution.copy()\n\n        elif operation == 'edge_swap':\n            if n > 2:\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                unique_nodes = np.unique(new_solution)\n                if len(unique_nodes) != n:\n                    new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8209494211988526,
            0.11800706386566162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        operation = random.choice(['segment_reversal', 'edge_swap'])\n\n        if operation == 'segment_reversal':\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n            insert_pos = random.randint(0, n - len(reversed_segment))\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                reversed_segment,\n                new_solution[insert_pos:]\n            ])\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                new_solution = base_solution.copy()\n\n        elif operation == 'edge_swap':\n            if n > 2:\n                i, j = random.sample(range(n), 2)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                unique_nodes = np.unique(new_solution)\n                if len(unique_nodes) != n:\n                    new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized ranking of objective values, then applies a hybrid local search operator combining edge exchange with a randomized segment permutation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and rank solutions\n    objs = np.array([obj for _, obj in archive])\n    normalized_objs = (objs - objs.min(axis=0)) / (objs.max(axis=0) - objs.min(axis=0) + 1e-10)\n    ranks = np.lexsort((normalized_objs[:, 0], normalized_objs[:, 1]))\n    selected_idx = ranks[0]  # Select the best solution\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid edge exchange with segment permutation\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Exchange segments and permute within them\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2[::-1] if random.random() > 0.5 else segment2,\n            new_solution[b:c],\n            segment1[::-1] if random.random() > 0.5 else segment1,\n            new_solution[d:]\n        ])\n\n        # Remove duplicates and restore missing nodes\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.937303495195974,
            0.21424800157546997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and rank solutions\n    objs = np.array([obj for _, obj in archive])\n    normalized_objs = (objs - objs.min(axis=0)) / (objs.max(axis=0) - objs.min(axis=0) + 1e-10)\n    ranks = np.lexsort((normalized_objs[:, 0], normalized_objs[:, 1]))\n    selected_idx = ranks[0]  # Select the best solution\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid edge exchange with segment permutation\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Exchange segments and permute within them\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2[::-1] if random.random() > 0.5 else segment2,\n            new_solution[b:c],\n            segment1[::-1] if random.random() > 0.5 else segment1,\n            new_solution[d:]\n        ])\n\n        # Remove duplicates and restore missing nodes\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n            new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of dominance rank and objective diversity, then applies a novel local search operator combining a multi-segment crossover with a probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance rank and objective diversity\n    dominance_rank = [0] * len(archive)\n    for i, (_, obj_i) in enumerate(archive):\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j:\n                if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]:\n                    dominance_rank[i] += 1\n\n    objectives = [obj for (_, obj) in archive]\n    obj_diversity = [np.std([obj[0] for _, obj in archive]) + np.std([obj[1] for _, obj in archive]) for _ in archive]\n\n    selection_score = [rank * diversity for rank, diversity in zip(dominance_rank, obj_diversity)]\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment crossover with probabilistic edge insertion\n        segments = []\n        num_segments = random.randint(2, min(5, n//2))\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append(new_solution[a:b])\n\n        # Shuffle and recombine segments\n        random.shuffle(segments)\n        combined = []\n        for seg in segments:\n            if random.random() < 0.7:  # 70% chance to include segment\n                combined.extend(seg)\n\n        # Fill remaining positions with probabilistic edge insertion\n        remaining_nodes = list(set(range(n)) - set(combined))\n        random.shuffle(remaining_nodes)\n\n        for node in remaining_nodes:\n            if random.random() < 0.5:  # 50% chance to insert at optimal position\n                best_pos = 0\n                best_cost = float('inf')\n                for pos in range(len(combined) + 1):\n                    temp = combined[:pos] + [node] + combined[pos:]\n                    cost = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(len(temp)))\n                    cost += sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(len(temp)))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                combined.insert(best_pos, node)\n            else:\n                combined.append(node)\n\n        new_solution = np.array(combined)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8343036517533701,
            1.598533570766449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance rank and objective diversity\n    dominance_rank = [0] * len(archive)\n    for i, (_, obj_i) in enumerate(archive):\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j:\n                if obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]:\n                    dominance_rank[i] += 1\n\n    objectives = [obj for (_, obj) in archive]\n    obj_diversity = [np.std([obj[0] for _, obj in archive]) + np.std([obj[1] for _, obj in archive]) for _ in archive]\n\n    selection_score = [rank * diversity for rank, diversity in zip(dominance_rank, obj_diversity)]\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment crossover with probabilistic edge insertion\n        segments = []\n        num_segments = random.randint(2, min(5, n//2))\n        for _ in range(num_segments):\n            a, b = sorted(random.sample(range(n), 2))\n            segments.append(new_solution[a:b])\n\n        # Shuffle and recombine segments\n        random.shuffle(segments)\n        combined = []\n        for seg in segments:\n            if random.random() < 0.7:  # 70% chance to include segment\n                combined.extend(seg)\n\n        # Fill remaining positions with probabilistic edge insertion\n        remaining_nodes = list(set(range(n)) - set(combined))\n        random.shuffle(remaining_nodes)\n\n        for node in remaining_nodes:\n            if random.random() < 0.5:  # 50% chance to insert at optimal position\n                best_pos = 0\n                best_cost = float('inf')\n                for pos in range(len(combined) + 1):\n                    temp = combined[:pos] + [node] + combined[pos:]\n                    cost = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(len(temp)))\n                    cost += sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(len(temp)))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n                combined.insert(best_pos, node)\n            else:\n                combined.append(node)\n\n        new_solution = np.array(combined)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search combining multiple segment operations, node reinsertion, and a dynamic crossover with another solution to generate a high-quality neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using a combination of objectives and diversity\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [np.sum(np.abs(sol - archive[0][0])) for (sol, obj) in archive]\n    combined_scores = [0.5 * (obj[0] + obj[1]) + 0.5 * div for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multiple segment operations\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node reinsertion\n    node_to_move = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Dynamic crossover with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        if random.random() < 0.5:\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n        else:\n            new_solution[crossover_point:] = other_solution[crossover_point:]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9417247884379623,
            0.6846599578857422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using a combination of objectives and diversity\n    objectives = [obj for (sol, obj) in archive]\n    diversity_scores = [np.sum(np.abs(sol - archive[0][0])) for (sol, obj) in archive]\n    combined_scores = [0.5 * (obj[0] + obj[1]) + 0.5 * div for obj, div in zip(objectives, diversity_scores)]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Multiple segment operations\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node reinsertion\n    node_to_move = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Dynamic crossover with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        if random.random() < 0.5:\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n        else:\n            new_solution[crossover_point:] = other_solution[crossover_point:]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective value, then applies a novel segment-based crossover with path relinking, followed by a dynamic edge insertion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective\n    objectives = [obj[0] + obj[1] for (sol, obj) in archive]\n    selected_idx = objectives.index(max(objectives))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment-based crossover with path relinking\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find common segments between solutions\n        segments = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if np.array_equal(base_solution[i:j], other_solution[i:j]):\n                    segments.append((i, j))\n\n        if segments:\n            # Select longest common segment\n            start, end = max(segments, key=lambda x: x[1]-x[0])\n            # Relink the segment\n            new_solution[start:end] = base_solution[start:end]\n        else:\n            # If no common segments, perform random crossover\n            crossover_point = random.randint(1, n-1)\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Step 2: Dynamic edge insertion\n    for _ in range(2):\n        # Select a random edge to break\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Remove the edge and insert nodes in reverse order\n        removed = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], removed[::-1], new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8920276901029661,
            0.6646993160247803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective\n    objectives = [obj[0] + obj[1] for (sol, obj) in archive]\n    selected_idx = objectives.index(max(objectives))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment-based crossover with path relinking\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find common segments between solutions\n        segments = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if np.array_equal(base_solution[i:j], other_solution[i:j]):\n                    segments.append((i, j))\n\n        if segments:\n            # Select longest common segment\n            start, end = max(segments, key=lambda x: x[1]-x[0])\n            # Relink the segment\n            new_solution[start:end] = base_solution[start:end]\n        else:\n            # If no common segments, perform random crossover\n            crossover_point = random.randint(1, n-1)\n            new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Step 2: Dynamic edge insertion\n    for _ in range(2):\n        # Select a random edge to break\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Remove the edge and insert nodes in reverse order\n        removed = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], removed[::-1], new_solution[j+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a non-linear combination of objectives, then applies a hybrid local search combining segment reversal with edge exchange and node insertion from another solution's segment, while ensuring feasibility by validating the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.4, 0.6]\n    weighted_scores = [obj[0] * (w1 ** 2) + obj[1] * (w2 ** 2) for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective weighting that adapts to the current distribution of solutions, then applies a hybrid local search combining segment reversal with adaptive edge exchange and node insertion from another solution's segment, while ensuring feasibility by validating the tour structure and using a novel repair mechanism to handle missing nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    obj1_mean = np.mean([obj[0] for obj in objectives])\n    obj2_mean = np.mean([obj[1] for obj in objectives])\n    weights = [0.5 + 0.5 * (obj[0] / obj1_mean) for obj in objectives]\n    weighted_scores = [w * obj[0] + (1 - w) * obj[1] for w, obj in zip(weights, objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k = random.randint(0, n-1)\n    l = (k + random.randint(1, n-1)) % n\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9663348284558249,
            0.12110227346420288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    obj1_mean = np.mean([obj[0] for obj in objectives])\n    obj2_mean = np.mean([obj[1] for obj in objectives])\n    weights = [0.5 + 0.5 * (obj[0] / obj1_mean) for obj in objectives]\n    weighted_scores = [w * obj[0] + (1 - w) * obj[1] for w, obj in zip(weights, objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k = random.randint(0, n-1)\n    l = (k + random.randint(1, n-1)) % n\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n        pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment reversal with a probabilistic edge swap to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    # Select solution with highest crowding distance (most isolated)\n    selected_index = np.argmax(crowding_distances)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment with probability 0.7\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Probabilistic edge swap\n        if random.random() < 0.3 and n > 3:\n            swap_positions = sorted(random.sample(range(1, n-1), 2))\n            new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that combines crowding distance with solution quality, then applies a novel local search strategy that combines segment rotation with adaptive edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined selection metric: crowding distance multiplied by inverse of objective sum\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    objective_sums = [sum(obj) for obj in objectives]\n    selection_metric = crowding_distances * (1 / np.array(objective_sums))\n    selected_index = np.argmax(selection_metric)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Novel local search: segment rotation with adaptive edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Rotate the segment left or right with equal probability\n        if random.random() < 0.5:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Adaptive edge insertion: insert a random edge from another solution\n        if len(archive) > 1 and random.random() < 0.4:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_index])\n            other_solution = archive[other_idx][0]\n            edge_pos = random.randint(0, n-2)\n            edge = other_solution[edge_pos:edge_pos+2]\n\n            # Find position to insert the edge\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, edge)\n            new_solution = np.unique(new_solution)  # Remove duplicates\n\n            # Ensure tour length remains correct\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n            elif len(new_solution) < n:\n                missing = set(range(n)) - set(new_solution)\n                for node in missing:\n                    pos = random.randint(0, len(new_solution)-1)\n                    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8765736416320928,
            0.4575095772743225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined selection metric: crowding distance multiplied by inverse of objective sum\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_indices = np.argsort([obj[m] for obj in objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, len(objectives)-1):\n            if objectives[sorted_indices[-1]][m] == objectives[sorted_indices[0]][m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1]][m] - objectives[sorted_indices[i-1]][m]) / (objectives[sorted_indices[-1]][m] - objectives[sorted_indices[0]][m])\n\n    objective_sums = [sum(obj) for obj in objectives]\n    selection_metric = crowding_distances * (1 / np.array(objective_sums))\n    selected_index = np.argmax(selection_metric)\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Novel local search: segment rotation with adaptive edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Rotate the segment left or right with equal probability\n        if random.random() < 0.5:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Adaptive edge insertion: insert a random edge from another solution\n        if len(archive) > 1 and random.random() < 0.4:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_index])\n            other_solution = archive[other_idx][0]\n            edge_pos = random.randint(0, n-2)\n            edge = other_solution[edge_pos:edge_pos+2]\n\n            # Find position to insert the edge\n            insert_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, edge)\n            new_solution = np.unique(new_solution)  # Remove duplicates\n\n            # Ensure tour length remains correct\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n            elif len(new_solution) < n:\n                missing = set(range(n)) - set(new_solution)\n                for node in missing:\n                    pos = random.randint(0, len(new_solution)-1)\n                    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining 3-opt moves, path relinking with a randomly selected solution, and a novel segment insertion operator to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (potential for improvement)\n    objectives = [obj for (sol, obj) in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left = objectives[i-1] if i > 0 else objectives[-1]\n        right = objectives[(i+1)%len(objectives)]\n        dist = sum(abs(objectives[i][j] - left[j]) + abs(right[j] - objectives[i][j]) for j in range(2))\n        crowding_distances.append(dist)\n    selected_idx = crowding_distances.index(max(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt, path relinking, and segment insertion\n    # Step 1: 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Path relinking with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        relink_point = random.randint(1, n-2)\n        new_solution[:relink_point] = other_solution[:relink_point]\n\n    # Step 3: Segment insertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8538880683326788,
            0.21052324771881104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance (potential for improvement)\n    objectives = [obj for (sol, obj) in archive]\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left = objectives[i-1] if i > 0 else objectives[-1]\n        right = objectives[(i+1)%len(objectives)]\n        dist = sum(abs(objectives[i][j] - left[j]) + abs(right[j] - objectives[i][j]) for j in range(2))\n        crowding_distances.append(dist)\n    selected_idx = crowding_distances.index(max(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt, path relinking, and segment insertion\n    # Step 1: 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Path relinking with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        relink_point = random.randint(1, n-2)\n        new_solution[:relink_point] = other_solution[:relink_point]\n\n    # Step 3: Segment insertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined hypervolume contribution and adaptive neighborhood search metric, then applies a novel local search operator combining a dynamic swap chain with a conditional segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    reference_point = (max(o[0] for o in objectives), max(o[1] for o in objectives))\n    contributions = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            contributions.append(1.0)\n            continue\n        # Calculate hypervolume contribution (simplified approximation)\n        contribution = (reference_point[0] - obj[0]) * (reference_point[1] - obj[1])\n        contributions.append(contribution)\n\n    # Select solution with highest hypervolume contribution\n    selected_idx = np.argmax(contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic swap chain: perform a series of adjacent swaps based on distance metrics\n        for _ in range(random.randint(1, 3)):\n            i = random.randint(0, n-2)\n            # Choose swap direction based on which objective shows better potential improvement\n            obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for _ in range(2))\n            obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for _ in range(2))\n            if obj1 > obj2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Conditional segment relocation: move a segment to a new position if it improves both objectives\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n - len(segment) + 1):\n            if pos == a:\n                continue\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:pos + len(segment)],\n                new_solution[pos + len(segment):]\n            ])\n            # Calculate improvement in both objectives\n            original_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            improvement = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:best_pos + len(segment)],\n                new_solution[best_pos + len(segment):]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.7825618400302292,
            0.6316569447517395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    reference_point = (max(o[0] for o in objectives), max(o[1] for o in objectives))\n    contributions = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            contributions.append(1.0)\n            continue\n        # Calculate hypervolume contribution (simplified approximation)\n        contribution = (reference_point[0] - obj[0]) * (reference_point[1] - obj[1])\n        contributions.append(contribution)\n\n    # Select solution with highest hypervolume contribution\n    selected_idx = np.argmax(contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic swap chain: perform a series of adjacent swaps based on distance metrics\n        for _ in range(random.randint(1, 3)):\n            i = random.randint(0, n-2)\n            # Choose swap direction based on which objective shows better potential improvement\n            obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for _ in range(2))\n            obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for _ in range(2))\n            if obj1 > obj2:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n        # Conditional segment relocation: move a segment to a new position if it improves both objectives\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n - len(segment) + 1):\n            if pos == a:\n                continue\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:pos + len(segment)],\n                new_solution[pos + len(segment):]\n            ])\n            # Calculate improvement in both objectives\n            original_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            improvement = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:best_pos + len(segment)],\n                new_solution[best_pos + len(segment):]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 2.5-opt, path relinking with a random segment, and a probabilistic edge insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj1, min_obj1 = max(o[0] for o in objectives), min(o[0] for o in objectives)\n    max_obj2, min_obj2 = max(o[1] for o in objectives), min(o[1] for o in objectives)\n\n    if max_obj1 == min_obj1:\n        normalized_scores = [o[1] for o in objectives]\n    elif max_obj2 == min_obj2:\n        normalized_scores = [o[0] for o in objectives]\n    else:\n        normalized_scores = [(o[0] - min_obj1)/(max_obj1 - min_obj1) + (o[1] - min_obj2)/(max_obj2 - min_obj2) for o in objectives]\n\n    selected_idx = normalized_scores.index(max(normalized_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2.5-opt, path relinking, and probabilistic edge insertion\n    # Step 1: 2.5-opt (remove 2 edges and reconnect 3)\n    if n >= 5:\n        a, b, c, d, e = sorted(random.sample(range(n), 5))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:e], new_solution[e:]])\n\n    # Step 2: Path relinking with a random segment\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = other_solution[start:end]\n\n    # Step 3: Probabilistic edge insertion\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9932014399012087,
            0.1507047414779663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized objectives\n    objectives = [obj for (sol, obj) in archive]\n    max_obj1, min_obj1 = max(o[0] for o in objectives), min(o[0] for o in objectives)\n    max_obj2, min_obj2 = max(o[1] for o in objectives), min(o[1] for o in objectives)\n\n    if max_obj1 == min_obj1:\n        normalized_scores = [o[1] for o in objectives]\n    elif max_obj2 == min_obj2:\n        normalized_scores = [o[0] for o in objectives]\n    else:\n        normalized_scores = [(o[0] - min_obj1)/(max_obj1 - min_obj1) + (o[1] - min_obj2)/(max_obj2 - min_obj2) for o in objectives]\n\n    selected_idx = normalized_scores.index(max(normalized_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2.5-opt, path relinking, and probabilistic edge insertion\n    # Step 1: 2.5-opt (remove 2 edges and reconnect 3)\n    if n >= 5:\n        a, b, c, d, e = sorted(random.sample(range(n), 5))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:e], new_solution[e:]])\n\n    # Step 2: Path relinking with a random segment\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = other_solution[start:end]\n\n    # Step 3: Probabilistic edge insertion\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized Pareto dominance score, then applies a hybrid local search combining 3-opt, segment insertion, and crossover with a solution from a different Pareto front to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized Pareto dominance\n    objectives = [obj for (sol, obj) in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    def dominance_score(obj):\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        return 0.7 * norm_obj1 + 0.3 * norm_obj2\n\n    scores = [dominance_score(obj) for obj in objectives]\n    selected_idx = scores.index(min(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt, segment insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Step 2: Segment insertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 3: Crossover with another solution from different Pareto front\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8138780220777058,
            0.11806297302246094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using normalized Pareto dominance\n    objectives = [obj for (sol, obj) in archive]\n    min_obj1, max_obj1 = min(o[0] for o in objectives), max(o[0] for o in objectives)\n    min_obj2, max_obj2 = min(o[1] for o in objectives), max(o[1] for o in objectives)\n\n    def dominance_score(obj):\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        return 0.7 * norm_obj1 + 0.3 * norm_obj2\n\n    scores = [dominance_score(obj) for obj in objectives]\n    selected_idx = scores.index(min(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt, segment insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Step 2: Segment insertion\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Step 3: Crossover with another solution from different Pareto front\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining edge swaps, segment reversal, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement using weighted objectives\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for obj, (w1, w2) in zip(objectives, zip(weights, reversed(weights)))]\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swaps, segment reversal, and crossover\n    n = len(new_solution)\n\n    # Step 1: Edge swaps\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and solution structure, then applies a novel hybrid local search combining path inversion with alternating segment swaps and probabilistic edge insertions to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential\n    objectives = [obj for _, obj in archive]\n    improvements = []\n    for i in range(len(archive)):\n        current_obj = objectives[i]\n        better_solutions = [obj for j, obj in enumerate(objectives) if (obj[0] < current_obj[0] and obj[1] <= current_obj[1]) or (obj[0] <= current_obj[0] and obj[1] < current_obj[1])]\n        improvements.append(len(better_solutions))\n\n    selected_idx = improvements.index(min(improvements)) if improvements else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: path inversion with alternating segment swaps and probabilistic edge insertions\n    if n > 4:\n        # Path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Alternating segment swaps\n        if n > 6:\n            segments = random.sample(range(1, n-1), 2)\n            seg1_start, seg1_end = min(segments[0], segments[1]), max(segments[0], segments[1])\n            seg2_start, seg2_end = seg1_end, seg1_end + (seg1_end - seg1_start)\n            if seg2_end < n:\n                seg1 = new_solution[seg1_start:seg1_end]\n                seg2 = new_solution[seg2_start:seg2_end]\n                new_solution = np.concatenate([new_solution[:seg1_start], seg2, seg1, new_solution[seg2_end:]])\n\n        # Probabilistic edge insertions\n        for _ in range(2):\n            if random.random() < 0.4:\n                i, j = sorted(random.sample(range(n), 2))\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.778733435470731,
            0.2738407850265503
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective improvement potential\n    objectives = [obj for _, obj in archive]\n    improvements = []\n    for i in range(len(archive)):\n        current_obj = objectives[i]\n        better_solutions = [obj for j, obj in enumerate(objectives) if (obj[0] < current_obj[0] and obj[1] <= current_obj[1]) or (obj[0] <= current_obj[0] and obj[1] < current_obj[1])]\n        improvements.append(len(better_solutions))\n\n    selected_idx = improvements.index(min(improvements)) if improvements else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: path inversion with alternating segment swaps and probabilistic edge insertions\n    if n > 4:\n        # Path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Alternating segment swaps\n        if n > 6:\n            segments = random.sample(range(1, n-1), 2)\n            seg1_start, seg1_end = min(segments[0], segments[1]), max(segments[0], segments[1])\n            seg2_start, seg2_end = seg1_end, seg1_end + (seg1_end - seg1_start)\n            if seg2_end < n:\n                seg1 = new_solution[seg1_start:seg1_end]\n                seg2 = new_solution[seg2_start:seg2_end]\n                new_solution = np.concatenate([new_solution[:seg1_start], seg2, seg1, new_solution[seg2_end:]])\n\n        # Probabilistic edge insertions\n        for _ in range(2):\n            if random.random() < 0.4:\n                i, j = sorted(random.sample(range(n), 2))\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search combining segment rotation, adaptive node insertion, and cross-solution segment transfer with a probability-based segment selection mechanism to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (furthest in objective space)\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n    np.fill_diagonal(distances, -1)\n    selected_idx = np.argmax(distances.max(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    rot_amount = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    new_solution[i:j] = np.roll(segment, rot_amount)\n\n    # Adaptive node insertion\n    if random.random() < 0.3:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node_to_move)\n\n    # Cross-solution segment transfer with probability\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment_len = min(b-a, len(new_solution)-a)\n        new_solution[a:a+segment_len] = other_solution[a:a+segment_len]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if needed\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.700221943519848,
            0.2903518080711365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (furthest in objective space)\n    objectives = np.array([obj for (_, obj) in archive])\n    distances = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n    np.fill_diagonal(distances, -1)\n    selected_idx = np.argmax(distances.max(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Segment rotation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j]\n    rot_amount = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    new_solution[i:j] = np.roll(segment, rot_amount)\n\n    # Adaptive node insertion\n    if random.random() < 0.3:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, pos, node_to_move)\n\n    # Cross-solution segment transfer with probability\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment_len = min(b-a, len(new_solution)-a)\n        new_solution[a:a+segment_len] = other_solution[a:a+segment_len]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if needed\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search operator combining segment swapping with a distance-based insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined scores for each solution\n    scored_solutions = []\n    for sol, obj in archive:\n        combined_score = 0.5 * obj[0] + 0.5 * obj[1]\n        scored_solutions.append((combined_score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        if a >= c:\n            a, c = c, a\n            b, d = d, b\n\n        # Ensure segments don't overlap\n        if b >= c:\n            b, c = c, b\n            if b >= d:\n                b, d = d, b\n\n        # Swap segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n        # Distance-based insertion: find the best insertion point for the swapped segments\n        if len(segment1) > 0 and len(segment2) > 0:\n            best_pos = -1\n            min_cost = float('inf')\n\n            for pos in range(n - len(segment1) + 1):\n                temp_sol = np.concatenate([\n                    new_solution[:pos],\n                    segment1,\n                    new_solution[pos:]\n                ])\n                cost = 0\n                for i in range(n-1):\n                    cost += distance_matrix_1[temp_sol[i], temp_sol[i+1]] + distance_matrix_2[temp_sol[i], temp_sol[i+1]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment1,\n                    new_solution[best_pos:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.7658526109009623,
            0.27276504039764404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined scores for each solution\n    scored_solutions = []\n    for sol, obj in archive:\n        combined_score = 0.5 * obj[0] + 0.5 * obj[1]\n        scored_solutions.append((combined_score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        if a >= c:\n            a, c = c, a\n            b, d = d, b\n\n        # Ensure segments don't overlap\n        if b >= c:\n            b, c = c, b\n            if b >= d:\n                b, d = d, b\n\n        # Swap segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b:c],\n            segment1,\n            new_solution[d:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n        # Distance-based insertion: find the best insertion point for the swapped segments\n        if len(segment1) > 0 and len(segment2) > 0:\n            best_pos = -1\n            min_cost = float('inf')\n\n            for pos in range(n - len(segment1) + 1):\n                temp_sol = np.concatenate([\n                    new_solution[:pos],\n                    segment1,\n                    new_solution[pos:]\n                ])\n                cost = 0\n                for i in range(n-1):\n                    cost += distance_matrix_1[temp_sol[i], temp_sol[i+1]] + distance_matrix_2[temp_sol[i], temp_sol[i+1]]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment1,\n                    new_solution[best_pos:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a non-linear combination of objectives, then applies a hybrid local search combining segment reversal with edge exchange and node insertion from another solution's segment, while ensuring feasibility by validating the tour structure.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.4, 0.6]\n    weighted_scores = [obj[0] * (w1 ** 2) + obj[1] * (w2 ** 2) for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    temp = new_solution[k]\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and tour structure diversity, then applies a hybrid local search combining segment inversion with probabilistic edge swapping and partial path reinsertion from another solution's segment, while ensuring feasibility through careful validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n\n        if random.random() < 0.5:\n            pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.4:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9089769081800381,
            0.146989643573761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_solution[a:b]\n\n        if random.random() < 0.5:\n            pos = random.randint(0, n - len(segment))\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.4:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search combining segment inversion with a randomized node swap to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] += objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n\n    # Select solution with lowest crowding distance (most crowded region)\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: segment inversion with randomized node swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Randomly swap two nodes in the segment\n        if len(inverted_segment) > 1:\n            swap_pos = random.sample(range(len(inverted_segment)), 2)\n            inverted_segment[swap_pos[0]], inverted_segment[swap_pos[1]] = inverted_segment[swap_pos[1]], inverted_segment[swap_pos[0]]\n\n        # Replace the segment with the modified version\n        new_solution[i:j] = inverted_segment\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7965805594097456,
            0.3611164689064026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    crowding = np.zeros(len(archive))\n\n    for m in range(objectives.shape[1]):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] += objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]\n\n    # Select solution with lowest crowding distance (most crowded region)\n    selected_idx = np.argmin(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Hybrid local search: segment inversion with randomized node swap\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Randomly swap two nodes in the segment\n        if len(inverted_segment) > 1:\n            swap_pos = random.sample(range(len(inverted_segment)), 2)\n            inverted_segment[swap_pos[0]], inverted_segment[swap_pos[1]] = inverted_segment[swap_pos[1]], inverted_segment[swap_pos[0]]\n\n        # Replace the segment with the modified version\n        new_solution[i:j] = inverted_segment\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid selection criterion combining objective space dominance and solution structure diversity, then applies a novel local search operator that combines a partial tour reversal with a segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective space dominance and diversity\n        objective_scores = [obj[0] + obj[1] for _, obj in archive]\n        min_obj = min(objective_scores)\n        max_obj = max(objective_scores)\n        normalized_scores = [(max_obj - obj)/(max_obj - min_obj + 1e-6) for obj in objective_scores]\n\n        # Calculate structural diversity (Hamming distance to other solutions)\n        diversity_scores = []\n        for i in range(len(archive)):\n            diversity = 0\n            for j in range(len(archive)):\n                if i != j:\n                    diversity += np.sum(archive[i][0] != archive[j][0])\n            diversity_scores.append(diversity)\n\n        max_diversity = max(diversity_scores) if max(diversity_scores) > 0 else 1\n        normalized_diversity = [d/max_diversity for d in diversity_scores]\n\n        # Combine scores\n        combined_scores = [0.7 * norm_obj + 0.3 * norm_div for norm_obj, norm_div in zip(normalized_scores, normalized_diversity)]\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Partial tour reversal: select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Segment relocation: select another random segment and insert it at a different position\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:c],\n            new_solution[d:],\n            segment\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -1.0109410039303919,
            0.8442725539207458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective space dominance and diversity\n        objective_scores = [obj[0] + obj[1] for _, obj in archive]\n        min_obj = min(objective_scores)\n        max_obj = max(objective_scores)\n        normalized_scores = [(max_obj - obj)/(max_obj - min_obj + 1e-6) for obj in objective_scores]\n\n        # Calculate structural diversity (Hamming distance to other solutions)\n        diversity_scores = []\n        for i in range(len(archive)):\n            diversity = 0\n            for j in range(len(archive)):\n                if i != j:\n                    diversity += np.sum(archive[i][0] != archive[j][0])\n            diversity_scores.append(diversity)\n\n        max_diversity = max(diversity_scores) if max(diversity_scores) > 0 else 1\n        normalized_diversity = [d/max_diversity for d in diversity_scores]\n\n        # Combine scores\n        combined_scores = [0.7 * norm_obj + 0.3 * norm_div for norm_obj, norm_div in zip(normalized_scores, normalized_diversity)]\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Partial tour reversal: select a random segment and reverse it\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Segment relocation: select another random segment and insert it at a different position\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:c],\n            new_solution[d:],\n            segment\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n"
    }
]