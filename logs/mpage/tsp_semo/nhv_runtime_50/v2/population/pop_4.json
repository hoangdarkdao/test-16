[
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Centric Path Decomposition and Reconstruction with Dynamic Segment Fusion,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective dominance\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then reconstructed using a dynamic fusion strategy that merges segments of the same objective type while preserving their original order, followed by an \"objective-aware segment inversion\" phase that probabilistically reverses segments of one objective to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.5 * cost2 or cost2 > 1.5 * cost1:\n            # If significantly dominated by one objective, end current segment\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic segment fusion\n    merged_segments = []\n    i = 0\n    while i < len(segments):\n        current_obj = 1 if sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1)) > \\\n                           sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1)) else 2\n\n        j = i + 1\n        while j < len(segments):\n            next_obj = 1 if sum(distance_matrix_1[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1)) > \\\n                            sum(distance_matrix_2[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1)) else 2\n\n            if current_obj == next_obj:\n                # Merge segments of the same objective\n                segments[i] = segments[i] + segments[j][1:]\n                j += 1\n            else:\n                break\n\n        merged_segments.append(segments[i])\n        i = j\n\n    # Step 4: Objective-aware segment inversion\n    for i in range(len(merged_segments)):\n        segment = merged_segments[i]\n        if len(segment) < 3:\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Decide whether to invert based on objective dominance\n        if cost1 > 1.3 * cost2:\n            # More dominated by objective 2, consider inversion\n            if random.random() < 0.5:\n                merged_segments[i] = segment[::-1]\n        elif cost2 > 1.3 * cost1:\n            # More dominated by objective 1, consider inversion\n            if random.random() < 0.5:\n                merged_segments[i] = segment[::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in merged_segments:\n        new_solution.extend(segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        if len(merged_segments) > 1:\n            i = random.randint(0, len(merged_segments)-1)\n            merged_segments[i] = merged_segments[i][::-1]\n            new_solution = []\n            for segment in merged_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9650858580707128,
               0.1937757134437561
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Multi-Objective Tour Fragmentation and Reconstruction,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's Pareto front, then adaptively selects and fragments the tour into multiple segments based on their contribution to each objective. These segments are then reconstructed using a novel \"objective-aware segment merging\" heuristic that prioritizes the most beneficial segments for each objective while maintaining tour feasibility. The method dynamically adjusts the fragmentation size and merging strategy based on the current solution's performance in both objective spaces, allowing for both fine-grained local improvements and more disruptive global explorations. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"segment quality assessment\" mechanism that evaluates each segment's impact on both objectives before merging.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Step 2: Select base solution with probability based on solution quality\n    base_solution = random.choices(\n        non_dominated,\n        weights=[1/(i+1) for i in range(len(non_dominated))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Adaptive tour fragmentation and reconstruction\n    if n > 3:\n        # Determine fragmentation size based on solution quality\n        fragment_size = min(3, max(1, n // 10))\n        num_fragments = max(2, n // fragment_size)\n\n        # Randomly select fragments to reconstruct\n        fragment_indices = sorted(random.sample(range(1, n-1), num_fragments-1))\n        fragments = []\n        start = 0\n        for idx in fragment_indices:\n            fragments.append(new_solution[start:idx])\n            start = idx\n        fragments.append(new_solution[start:])\n\n        # Shuffle fragments with probability based on objective performance\n        if random.random() < 0.7:\n            random.shuffle(fragments)\n\n        # Reconstruct solution with objective-aware merging\n        merged_solution = []\n        for i in range(len(fragments)):\n            # Calculate fragment quality for each objective\n            frag = fragments[i]\n            if len(frag) < 2:\n                merged_solution.extend(frag)\n                continue\n\n            # Calculate objective contributions\n            obj1_contrib = sum(distance_matrix_1[frag[j], frag[j+1]] for j in range(len(frag)-1))\n            obj2_contrib = sum(distance_matrix_2[frag[j], frag[j+1]] for j in range(len(frag)-1))\n\n            # Decide whether to reverse the fragment based on objective performance\n            if i > 0 and i < len(fragments)-1:\n                prev_node = merged_solution[-1] if merged_solution else fragments[i-1][-1]\n                next_node = fragments[i+1][0] if i < len(fragments)-1 else frag[-1]\n\n                # Calculate potential improvement if reversed\n                rev_obj1 = sum(distance_matrix_1[frag[j], frag[j+1]] for j in range(len(frag)-1))\n                rev_obj2 = sum(distance_matrix_2[frag[j], frag[j+1]] for j in range(len(frag)-1))\n\n                if (rev_obj1 < obj1_contrib and rev_obj2 < obj2_contrib) or \\\n                   (random.random() < 0.3 and (rev_obj1 < obj1_contrib or rev_obj2 < obj2_contrib)):\n                    frag = frag[::-1]\n\n            merged_solution.extend(frag)\n\n        # Ensure the tour is circular\n        if merged_solution[0] != merged_solution[-1]:\n            merged_solution.append(merged_solution[0])\n\n        new_solution = np.array(merged_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9578128800630137,
               0.3399670124053955
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Centric Tour Recombination and Adaptive Edge Refinement,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's Pareto front, then selects a base solution based on its objective performance and structural diversity. The algorithm then partitions the tour into multiple segments and recombines them using an objective-centric approach that prioritizes the most beneficial edges for each objective while maintaining tour feasibility. This is followed by an adaptive edge refinement phase that selectively improves the tour by replacing edges with better alternatives from a candidate pool, where the selection of candidates is guided by both objective improvements and spatial proximity in the coordinate spaces. The method dynamically adjusts the refinement intensity based on the current solution's performance in both objective spaces, allowing for both fine-grained local improvements and more disruptive global explorations. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"edge quality assessment\" mechanism that evaluates each edge's impact on both objectives before refinement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Select base solution with probability based on solution quality\n    base_solution = random.choices(\n        non_dominated,\n        weights=[1/(i+1) for i in range(len(non_dominated))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-centric tour recombination\n    if n > 3:\n        # Partition the tour into segments\n        num_segments = max(2, n // 5)\n        segment_length = n // num_segments\n        segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(num_segments)]\n\n        # For each segment, identify the best edges for each objective\n        for i in range(len(segments)):\n            seg = segments[i]\n            if len(seg) < 2:\n                continue\n\n            # Find the best edge in the segment for each objective\n            best_edge1 = (0, 1)\n            best_edge2 = (0, 1)\n            min_dist1 = distance_matrix_1[seg[0], seg[1]]\n            min_dist2 = distance_matrix_2[seg[0], seg[1]]\n\n            for j in range(len(seg)-1):\n                if distance_matrix_1[seg[j], seg[j+1]] < min_dist1:\n                    min_dist1 = distance_matrix_1[seg[j], seg[j+1]]\n                    best_edge1 = (j, j+1)\n                if distance_matrix_2[seg[j], seg[j+1]] < min_dist2:\n                    min_dist2 = distance_matrix_2[seg[j], seg[j+1]]\n                    best_edge2 = (j, j+1)\n\n            # Decide which edges to keep based on objective priorities\n            if random.random() < 0.5:\n                # Prioritize first objective\n                if best_edge1 != best_edge2:\n                    # Replace the non-optimal edges with optimal ones\n                    if best_edge1[0] < best_edge2[0]:\n                        seg[best_edge2[0]:best_edge2[1]] = seg[best_edge1[0]:best_edge1[1]]\n                    else:\n                        seg[best_edge1[0]:best_edge1[1]] = seg[best_edge2[0]:best_edge2[1]]\n            else:\n                # Prioritize second objective\n                if best_edge1 != best_edge2:\n                    if best_edge2[0] < best_edge1[0]:\n                        seg[best_edge1[0]:best_edge1[1]] = seg[best_edge2[0]:best_edge2[1]]\n                    else:\n                        seg[best_edge2[0]:best_edge2[1]] = seg[best_edge1[0]:best_edge1[1]]\n\n            segments[i] = seg\n\n        # Recombine segments with adaptive edge refinement\n        merged_solution = []\n        for i in range(len(segments)):\n            seg = segments[i]\n            if not merged_solution:\n                merged_solution.extend(seg)\n            else:\n                # Find the best connection between current end and next segment start\n                last_node = merged_solution[-1]\n                next_seg = segments[(i+1) % len(segments)]\n                first_node = next_seg[0]\n\n                # Create candidate edges\n                candidates = []\n                for node in seg:\n                    candidates.append((last_node, node))\n                    candidates.append((node, first_node))\n\n                # Evaluate candidates based on both objectives\n                best_candidate = candidates[0]\n                min_cost1 = distance_matrix_1[last_node, seg[0]] + distance_matrix_1[seg[-1], first_node]\n                min_cost2 = distance_matrix_2[last_node, seg[0]] + distance_matrix_2[seg[-1], first_node]\n\n                for (a, b) in candidates:\n                    cost1 = distance_matrix_1[a, b]\n                    cost2 = distance_matrix_2[a, b]\n                    if (cost1 < min_cost1 and cost2 <= min_cost2) or (cost1 <= min_cost1 and cost2 < min_cost2):\n                        min_cost1 = cost1\n                        min_cost2 = cost2\n                        best_candidate = (a, b)\n\n                # Apply the best connection\n                if best_candidate[0] == last_node:\n                    merged_solution.extend(seg)\n                else:\n                    # Find the node in seg that connects to first_node\n                    connection_node = None\n                    for node in seg:\n                        if distance_matrix_1[node, first_node] < distance_matrix_1[seg[0], first_node] or \\\n                           distance_matrix_2[node, first_node] < distance_matrix_2[seg[0], first_node]:\n                            connection_node = node\n                            break\n\n                    if connection_node is not None:\n                        # Split the segment at the connection node\n                        idx = np.where(seg == connection_node)[0][0]\n                        merged_solution.extend(seg[:idx+1])\n                        merged_solution.extend(seg[idx+1:])\n                    else:\n                        merged_solution.extend(seg)\n\n        # Ensure the tour is circular\n        if merged_solution[0] != merged_solution[-1]:\n            merged_solution.append(merged_solution[0])\n\n        new_solution = np.array(merged_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9645529101975834,
               0.40858298540115356
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive  # Fallback to all solutions if none are non-dominated\n\n    # Step 2: Select a solution with high diversity (sum of distances in both objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in non_dominated])\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Segmented inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment lengths dynamically based on instance size\n    segment_length = max(2, n // 10)  # At least 2 nodes per segment\n\n    for i in range(0, n, segment_length):\n        segment_start = i\n        segment_end = min(i + segment_length, n)\n\n        # Calculate segment cost in both objectives\n        segment_cost_1 = 0\n        segment_cost_2 = 0\n        for j in range(segment_start, segment_end - 1):\n            node_a = base_solution[j]\n            node_b = base_solution[j + 1]\n            segment_cost_1 += distance_matrix_1[node_a, node_b]\n            segment_cost_2 += distance_matrix_2[node_a, node_b]\n\n        # Probability of inversion is inversely proportional to segment cost\n        total_cost = segment_cost_1 + segment_cost_2\n        if total_cost > 0:\n            inversion_prob = 1.0 / (1.0 + total_cost / (distance_matrix_1.sum() + distance_matrix_2.sum()))\n        else:\n            inversion_prob = 0.5\n\n        if np.random.rand() < inversion_prob:\n            # Invert the segment\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
          "score": [
               -0.9562401881074726,
               0.8160168528556824
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Balanced Tour Rebalancing with Dynamic Segment Optimization,\" builds on the common backbone of identifying promising solutions from the archive and performing local improvements, but introduces a fundamentally different approach. It first selects a base solution by analyzing the archive's Pareto front and then dynamically partitions the tour into segments based on their balanced contribution to both objectives. These segments are then reoptimized using a novel \"objective-balancing heuristic\" that prioritizes segments with imbalanced contributions, either by reversing them or reinserting nodes, while maintaining tour feasibility. The method dynamically adjusts the segment size and optimization strategy based on the current solution's performance in both objective spaces, allowing for both fine-grained local improvements and more disruptive global explorations. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"segment imbalance assessment\" mechanism that evaluates each segment's contribution to both objectives before reoptimization.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select base solution with probability based on solution quality\n    base_solution = random.choices(\n        [sol for sol, _ in non_dominated],\n        weights=[1/(i+1) for i in range(len(non_dominated))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Dynamic segment partitioning and rebalancing\n    if n > 3:\n        # Calculate segment size based on solution quality\n        segment_size = min(4, max(2, n // 8))\n        num_segments = max(2, n // segment_size)\n\n        # Partition the tour into segments\n        segments = []\n        for i in range(num_segments):\n            start = i * segment_size\n            end = min((i + 1) * segment_size, n)\n            segments.append(new_solution[start:end])\n\n        # Rebalance segments based on objective contributions\n        for i in range(len(segments)):\n            segment = segments[i]\n            if len(segment) < 2:\n                continue\n\n            # Calculate segment contributions to each objective\n            obj1_contrib = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n            obj2_contrib = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n            # Calculate imbalance ratio\n            imbalance = abs(obj1_contrib - obj2_contrib) / max(obj1_contrib, obj2_contrib, 1e-6)\n\n            # If segment is highly imbalanced, attempt to rebalance\n            if imbalance > 0.3:\n                # Try reversing the segment\n                reversed_segment = segment[::-1]\n                rev_obj1 = sum(distance_matrix_1[reversed_segment[j], reversed_segment[j+1]] for j in range(len(reversed_segment)-1))\n                rev_obj2 = sum(distance_matrix_2[reversed_segment[j], reversed_segment[j+1]] for j in range(len(reversed_segment)-1))\n                rev_imbalance = abs(rev_obj1 - rev_obj2) / max(rev_obj1, rev_obj2, 1e-6)\n\n                if rev_imbalance < imbalance:\n                    segments[i] = reversed_segment\n                else:\n                    # Try reinserting nodes to improve balance\n                    for _ in range(3):  # Limit attempts to avoid excessive computation\n                        pos1, pos2 = random.sample(range(len(segment)), 2)\n                        if pos1 > pos2:\n                            pos1, pos2 = pos2, pos1\n                        if pos2 - pos1 > 1:\n                            segment_copy = segment.copy()\n                            segment_copy[pos1:pos2] = segment_copy[pos1:pos2][::-1]\n                            new_obj1 = sum(distance_matrix_1[segment_copy[j], segment_copy[j+1]] for j in range(len(segment_copy)-1))\n                            new_obj2 = sum(distance_matrix_2[segment_copy[j], segment_copy[j+1]] for j in range(len(segment_copy)-1))\n                            new_imbalance = abs(new_obj1 - new_obj2) / max(new_obj1, new_obj2, 1e-6)\n                            if new_imbalance < imbalance:\n                                segments[i] = segment_copy\n                                imbalance = new_imbalance\n\n        # Reconstruct the solution\n        new_solution = np.concatenate(segments)\n\n        # Ensure the tour is circular\n        if new_solution[0] != new_solution[-1]:\n            new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
          "score": [
               -0.8684187620585094,
               0.41307729482650757
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Centric Segmented Path Reconstruction,\" departs from traditional approaches by first identifying the most promising segments of solutions based on their individual contributions to each objective. It then reconstructs a new tour by selectively incorporating these high-quality segments while intelligently handling the remaining nodes through a novel \"objective-balanced insertion\" mechanism. The algorithm dynamically adjusts the selection of segments based on their performance in both objectives, using a probabilistic model that prioritizes segments with better objective-specific contributions. After segment selection, the algorithm ensures tour feasibility by carefully inserting the remaining nodes while maintaining a balanced improvement across both objectives, and includes a \"segment compatibility assessment\" that evaluates potential connections between segments before finalizing the new tour. This approach differs fundamentally from both provided algorithms by focusing on segment-level quality assessment and objective-aware reconstruction rather than solution-level inversion or fragmentation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best solution in each objective\n    best_obj1 = min(archive, key=lambda x: x[1][0])\n    best_obj2 = min(archive, key=lambda x: x[1][1])\n\n    # Step 2: Extract high-quality segments from both solutions\n    segments = []\n    for sol in [best_obj1[0], best_obj2[0]]:\n        n = len(sol)\n        segment_length = max(2, n // 5)  # At least 2 nodes per segment\n        for i in range(0, n, segment_length):\n            segment = sol[i:i+segment_length]\n            if len(segment) > 1:\n                segments.append(segment)\n\n    # Step 3: Select segments with high quality in either objective\n    selected_segments = []\n    for seg in segments:\n        seg_obj1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        seg_obj2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        if seg_obj1 < np.median([s[1][0] for s in archive]) or seg_obj2 < np.median([s[1][1] for s in archive]):\n            selected_segments.append(seg)\n\n    if not selected_segments:\n        selected_segments = segments[:3] if segments else [archive[0][0][:3]]\n\n    # Step 4: Build new solution by combining selected segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in selected_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 5: Insert remaining nodes with objective-balanced approach\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        # Find best insertion point for the next node\n        best_node = None\n        best_pos = -1\n        best_improvement = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                # Calculate potential improvement for both objectives\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                original_cost = distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n                new_cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                            distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                improvement = new_cost - original_cost\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            # Fallback: append remaining nodes\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure the solution is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Ensure all nodes are visited exactly once\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9375113695337816,
               0.47108250856399536
          ]
     },
     {
          "algorithm": "{This new algorithm first identifies the solution in the archive with the highest combined objective value, then applies a novel \"objective-aware segment insertion\" strategy. It partitions the solution into three segments based on the current objective values, where the middle segment is strategically reinserted at a new position determined by analyzing the distance matrices in both objective spaces. The algorithm ensures feasibility by verifying the new solution maintains a valid TSP tour, and if not, it falls back to a simple segment reversal as a backup. The method prioritizes high-quality solutions and leverages multi-objective information to guide the local search process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Objective-aware segment insertion\n    obj1, obj2 = selected[1]\n    total_obj = obj1 + obj2\n\n    # Determine segment boundaries based on objective ratios\n    split1 = int(n * (obj1 / total_obj))\n    split2 = int(n * (obj2 / total_obj))\n    split1, split2 = sorted([split1, split2])\n\n    # Extract segments\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n\n    # Determine insertion position based on distance matrices\n    if obj1 > obj2:\n        # Prefer positions that minimize distance in first objective space\n        candidate_positions = np.argsort(distance_matrix_1[new_solution[split1-1], new_solution[split2:split2+5]])[:3]\n    else:\n        # Prefer positions that minimize distance in second objective space\n        candidate_positions = np.argsort(distance_matrix_2[new_solution[split1-1], new_solution[split2:split2+5]])[:3]\n\n    if len(candidate_positions) > 0:\n        insert_pos = np.random.choice(candidate_positions)\n        new_solution = np.concatenate([segment1, segment3[:insert_pos], segment2, segment3[insert_pos:]])\n    else:\n        # Fallback: simple segment reversal\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3])\n\n    # Step 3: Verify feasibility\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9495246321471995,
               0.4726450443267822
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or all if fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 3-opt with a novel segment reversal strategy\n    # First, perform a random 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    if i == 0 and k == n-1:  # Avoid full reversal which is equivalent to a swap\n        i, j, k = 0, 1, 2\n\n    # Create three segments and reverse the middle one\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j+1][::-1]\n    segment3 = new_solution[j+1:k+1][::-1]\n    segment4 = new_solution[k+1:]\n\n    # Combine segments with a novel crossover pattern\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Ensure the solution remains feasible\n    # Verify all nodes are present and unique\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.5515284065342554,
               0.4913042187690735
          ]
     },
     {
          "algorithm": "{This new algorithm, named \"Bi-Objective Path Refinement with Multi-Dimensional Rebalancing,\" operates by first selecting the solution from the archive with the most balanced objectives (closest to Pareto-optimal) as the base solution. It then identifies critical segments where the path's balance between objectives is most imbalanced, using a novel segment scoring metric that combines the absolute difference in segment costs with their relative positions in the tour. These segments are subjected to a hybrid local search that includes: 1) a probabilistic node replacement mechanism that prioritizes nodes which improve both objectives simultaneously, 2) a cross-dimensional alignment phase that swaps nodes between segments to better align their contributions to each objective, and 3) a dynamic segment reversal operation that flips segments to potentially improve both objectives. The algorithm ensures feasibility by maintaining a permutation of nodes and validates the solution before returning it, falling back to a simple swap if invalid. The method's novelty lies in its multi-faceted approach that simultaneously addresses both objectives through coordinated segment operations and cross-dimensional alignment.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments for improvement\n    segment_length = max(2, n // 4)\n    segment_scores = []\n\n    for i in range(n - segment_length + 1):\n        segment = new_solution[i:i+segment_length]\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n\n        # Score based on imbalance and potential for improvement\n        imbalance = abs(cost1 - cost2)\n        total_cost = cost1 + cost2\n        score = imbalance * (1 / (total_cost + 1e-6)) + 0.5 * (cost1 + cost2) / (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]] + 1e-6)\n        segment_scores.append((i, score))\n\n    if not segment_scores:\n        segment_scores = [(0, 0)]\n\n    # Select top segments for refinement\n    segment_scores.sort(key=lambda x: x[1], reverse=True)\n    selected_segments = [x[0] for x in segment_scores[:3]]\n\n    # Process selected segments\n    for start_idx in selected_segments:\n        segment = new_solution[start_idx:start_idx+segment_length]\n\n        # Multi-dimensional node replacement\n        for i in range(len(segment)):\n            current_node = segment[i]\n            best_node = current_node\n            best_improvement = 0\n\n            # Find best replacement node\n            for candidate_node in range(n):\n                if candidate_node not in segment:\n                    # Calculate improvement in both objectives\n                    prev_node = segment[(i-1)%len(segment)]\n                    next_node = segment[(i+1)%len(segment)]\n\n                    current_cost = (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node] +\n                                   distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node])\n\n                    candidate_cost = (distance_matrix_1[prev_node, candidate_node] + distance_matrix_1[candidate_node, next_node] +\n                                     distance_matrix_2[prev_node, candidate_node] + distance_matrix_2[candidate_node, next_node])\n\n                    improvement = current_cost - candidate_cost\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_node = candidate_node\n\n            if best_node != current_node:\n                segment[i] = best_node\n\n        # Cross-dimensional alignment\n        if random.random() < 0.6:\n            # Find nodes that are better in one objective but worse in another\n            for i in range(len(segment)):\n                node = segment[i]\n                prev_node = segment[(i-1)%len(segment)]\n                next_node = segment[(i+1)%len(segment)]\n\n                cost1_prev = distance_matrix_1[prev_node, node]\n                cost2_prev = distance_matrix_2[prev_node, node]\n                cost1_next = distance_matrix_1[node, next_node]\n                cost2_next = distance_matrix_2[node, next_node]\n\n                # Find potential swap partner\n                for j in range(i+1, len(segment)):\n                    other_node = segment[j]\n                    other_prev = segment[(j-1)%len(segment)]\n                    other_next = segment[(j+1)%len(segment)]\n\n                    # Check if swapping would improve both objectives\n                    new_cost1 = (distance_matrix_1[prev_node, other_node] + distance_matrix_1[other_node, next_node] +\n                                 distance_matrix_1[other_prev, node] + distance_matrix_1[node, other_next])\n                    new_cost2 = (distance_matrix_2[prev_node, other_node] + distance_matrix_2[other_node, next_node] +\n                                 distance_matrix_2[other_prev, node] + distance_matrix_2[node, other_next])\n\n                    old_cost1 = cost1_prev + cost1_next + distance_matrix_1[other_prev, other_node] + distance_matrix_1[other_node, other_next]\n                    old_cost2 = cost2_prev + cost2_next + distance_matrix_2[other_prev, other_node] + distance_matrix_2[other_node, other_next]\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                        # Perform swap\n                        segment[i], segment[j] = segment[j], segment[i]\n                        break\n\n        # Dynamic segment reversal\n        if random.random() < 0.4:\n            # Reverse the segment and check if it improves both objectives\n            reversed_segment = segment[::-1]\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[j], reversed_segment[j+1]] for j in range(len(reversed_segment)-1))\n            original_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[j], reversed_segment[j+1]] for j in range(len(reversed_segment)-1))\n\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n                segment = reversed_segment\n\n        # Reinsert processed segment\n        new_solution = np.concatenate([new_solution[:start_idx], segment, new_solution[start_idx+segment_length:]])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If invalid, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9512152601147608,
               9.916679382324219
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Dynamic Objective-Aligned Path Evolution,\" departs fundamentally from the other approaches by first performing a comprehensive analysis of the archive's objective landscape to identify regions of interest through clustering. It then selects a base solution based on both its objective performance and its structural uniqueness. The algorithm constructs a dynamic path evolution graph where nodes represent segments of the tour and edges represent potential connections between segments, weighted by their combined objective improvements. This graph is traversed using a novel multi-objective pathfinding algorithm that prioritizes edges which offer the best trade-offs between the two objectives. The method dynamically adjusts the exploration depth based on the solution's current objective dominance, allowing for both local refinements and global diversifications. After reconstructing the tour from the selected path, it applies a probabilistic edge refinement phase where each edge is replaced with a better alternative from a candidate pool, with the selection probability weighted by both objective improvements and spatial proximity in the coordinate spaces. The algorithm ensures feasibility by maintaining a valid tour structure throughout and includes an edge quality assessment mechanism that evaluates each edge's impact on both objectives before refinement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Step 2: Select base solution with probability based on solution quality and diversity\n    base_solution = random.choices(\n        non_dominated,\n        weights=[1/(i+1) * (1 + 0.1 * np.std([np.linalg.norm(instance[sol] - instance[other_sol]) for other_sol in non_dominated]))\n                for i, sol in enumerate(non_dominated)],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Dynamic path evolution graph construction\n    if n > 3:\n        # Create segments with adaptive size based on solution quality\n        segment_size = max(2, min(5, n // 5))\n        segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n        # Create path evolution graph\n        graph = {}\n        for i in range(len(segments)):\n            graph[i] = {}\n            for j in range(len(segments)):\n                if i != j:\n                    # Calculate connection cost between segment i and j\n                    last_i = segments[i][-1]\n                    first_j = segments[j][0]\n                    cost1 = distance_matrix_1[last_i, first_j]\n                    cost2 = distance_matrix_2[last_i, first_j]\n\n                    # Calculate objective improvement potential\n                    current_cost1 = sum(distance_matrix_1[segments[i][k], segments[i][k+1]] for k in range(len(segments[i])-1))\n                    current_cost2 = sum(distance_matrix_2[segments[i][k], segments[i][k+1]] for k in range(len(segments[i])-1))\n                    new_cost1 = current_cost1 + cost1\n                    new_cost2 = current_cost2 + cost2\n\n                    # Weighted combined cost\n                    weight = random.random()\n                    combined_cost = weight * new_cost1 + (1-weight) * new_cost2\n\n                    graph[i][j] = (combined_cost, cost1, cost2)\n\n        # Step 4: Multi-objective pathfinding\n        path = [0]\n        current_node = 0\n        visited = set([0])\n\n        while len(path) < len(segments):\n            candidates = []\n            for neighbor in graph[current_node]:\n                if neighbor not in visited:\n                    candidates.append((neighbor, graph[current_node][neighbor][0]))\n\n            if not candidates:\n                break\n\n            # Select next segment based on both cost and objective improvement\n            candidates.sort(key=lambda x: x[1])\n            selected = candidates[0][0]\n            path.append(selected)\n            visited.add(selected)\n            current_node = selected\n\n        # Step 5: Reconstruct solution from path\n        merged_solution = []\n        for i in range(len(path)):\n            seg_idx = path[i]\n            seg = segments[seg_idx]\n            if not merged_solution:\n                merged_solution.extend(seg)\n            else:\n                # Find best connection between current end and next segment\n                last_node = merged_solution[-1]\n                next_seg = segments[path[(i+1) % len(path)]]\n                first_node = next_seg[0]\n\n                # Try different connection strategies\n                strategies = [\n                    (last_node, seg[0]),  # direct connection\n                    (seg[-1], first_node),  # reverse connection\n                    (last_node, random.choice(seg)),  # random connection\n                    (random.choice(seg), first_node)  # random connection\n                ]\n\n                best_strategy = strategies[0]\n                min_cost = graph[path[i-1]][path[i]][0] if i > 0 else float('inf')\n\n                for strategy in strategies:\n                    a, b = strategy\n                    cost1 = distance_matrix_1[a, b]\n                    cost2 = distance_matrix_2[a, b]\n                    combined = weight * cost1 + (1-weight) * cost2\n\n                    if combined < min_cost:\n                        min_cost = combined\n                        best_strategy = strategy\n\n                # Apply the best connection\n                a, b = best_strategy\n                if a == last_node:\n                    merged_solution.extend(seg)\n                else:\n                    # Find the node in seg that connects to first_node\n                    connection_node = None\n                    for node in seg:\n                        if distance_matrix_1[node, first_node] < distance_matrix_1[seg[0], first_node] or \\\n                           distance_matrix_2[node, first_node] < distance_matrix_2[seg[0], first_node]:\n                            connection_node = node\n                            break\n\n                    if connection_node is not None:\n                        idx = np.where(seg == connection_node)[0][0]\n                        merged_solution.extend(seg[:idx+1])\n                        merged_solution.extend(seg[idx+1:])\n                    else:\n                        merged_solution.extend(seg)\n\n        # Ensure the tour is circular\n        if merged_solution[0] != merged_solution[-1]:\n            merged_solution.append(merged_solution[0])\n\n        new_solution = np.array(merged_solution)\n\n    # Step 6: Probabilistic edge refinement\n    for i in range(len(new_solution)-1):\n        a, b = new_solution[i], new_solution[i+1]\n        if random.random() < 0.3:  # Refinement probability\n            # Find candidate edges\n            candidates = []\n            for j in range(len(new_solution)-1):\n                if j != i and j != i+1:\n                    x, y = new_solution[j], new_solution[j+1]\n                    # Check if replacing (a,b) with (a,x) and (y,b) is valid\n                    if a != x and b != y and a != y and b != x:\n                        cost1 = distance_matrix_1[a, x] + distance_matrix_1[y, b]\n                        cost2 = distance_matrix_2[a, x] + distance_matrix_2[y, b]\n                        candidates.append(((a, x, y, b), cost1, cost2))\n\n            if candidates:\n                # Select best candidate based on objective improvements\n                best_candidate = None\n                min_improvement = 0\n                current_cost1 = distance_matrix_1[a, b]\n                current_cost2 = distance_matrix_2[a, b]\n\n                for (a_x_y_b, cost1, cost2) in candidates:\n                    improvement1 = current_cost1 - cost1\n                    improvement2 = current_cost2 - cost2\n                    combined_improvement = weight * improvement1 + (1-weight) * improvement2\n\n                    if combined_improvement > min_improvement:\n                        min_improvement = combined_improvement\n                        best_candidate = a_x_y_b\n\n                if best_candidate:\n                    a, x, y, b = best_candidate\n                    # Apply the refinement\n                    new_solution[i] = a\n                    new_solution[i+1] = x\n                    # Insert y before b\n                    new_solution = np.insert(new_solution, i+2, y)\n\n    return new_solution\n\n",
          "score": [
               -0.9453635955605797,
               2.5722045302391052
          ]
     }
]