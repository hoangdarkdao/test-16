[
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a quality-aware selection strategy that balances objective values and solution diversity, then applies a novel \"multi-objective segment insertion\" operator that inserts segments from high-quality solutions into the current tour while considering both distance matrices to maintain balance between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if len(archive) > 1 and n > 3:\n        # Select a high-quality solution to extract a segment\n        high_quality_sol = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0][0]\n\n        # Determine segment size based on solution quality\n        quality = (distance_matrix_1[high_quality_sol[:-1], high_quality_sol[1:]].sum() +\n                  distance_matrix_2[high_quality_sol[:-1], high_quality_sol[1:]].sum()) / (2 * n)\n        seg_size = max(2, int(n * 0.2 * (1 - quality / (quality + 1))))\n\n        # Extract segment from high-quality solution\n        seg_start = np.random.randint(1, n - seg_size)\n        segment = high_quality_sol[seg_start:seg_start+seg_size]\n\n        # Insert segment into current solution\n        insert_pos = np.random.randint(1, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # If duplicates exist, perform a simple swap to fix\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9204589336911608,
            0.09317189455032349
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the balance between its objectives' ratio and diversity, then applies a \"multi-objective segment insertion\" operator that intelligently inserts segments from the best solutions in each objective space while ensuring feasibility and maintaining a good trade-off between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective ratio and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / x[1][1]) if x[1][1] != 0 else float('inf'))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find best solutions in each objective space\n    best_obj1 = min(archive, key=lambda x: x[1][0])[0]\n    best_obj2 = min(archive, key=lambda x: x[1][1])[0]\n\n    if n > 4:\n        # Multi-objective segment insertion\n        seg_size = max(2, n // 4)\n        seg_start = np.random.randint(1, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Choose segment from best solutions with probability based on objective importance\n        if np.random.random() < 0.6:\n            segment = best_obj1[seg_start:seg_end]\n        else:\n            segment = best_obj2[seg_start:seg_end]\n\n        # Insert segment at random position\n        insert_pos = np.random.randint(1, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates by swapping with non-conflicting nodes\n        unique_nodes = set(new_solution)\n        if len(unique_nodes) != n:\n            for i in range(1, n-1):\n                if new_solution[i] in new_solution[:i] or new_solution[i] in new_solution[i+1:]:\n                    available_nodes = [node for node in range(n) if node not in unique_nodes]\n                    if available_nodes:\n                        new_solution[i] = np.random.choice(available_nodes)\n                        unique_nodes.add(new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.9533564934434349,
            0.09863150119781494
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a quality-aware selection strategy that balances objective values and solution diversity, then applies a novel \"multi-objective segment insertion\" operator that inserts segments from high-quality solutions into the current tour while considering both distance matrices to maintain balance between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if len(archive) > 1 and n > 3:\n        # Select a high-quality solution to extract a segment\n        high_quality_sol = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0][0]\n\n        # Determine segment size based on solution quality\n        quality = (distance_matrix_1[high_quality_sol[:-1], high_quality_sol[1:]].sum() +\n                  distance_matrix_2[high_quality_sol[:-1], high_quality_sol[1:]].sum()) / (2 * n)\n        seg_size = max(2, int(n * 0.2 * (1 - quality / (quality + 1))))\n\n        # Extract segment from high-quality solution\n        seg_start = np.random.randint(1, n - seg_size)\n        segment = high_quality_sol[seg_start:seg_start+seg_size]\n\n        # Insert segment into current solution\n        insert_pos = np.random.randint(1, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # If duplicates exist, perform a simple swap to fix\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9204589336911608,
            0.09317189455032349
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"multi-objective segment crossover\" operator that combines segments from multiple solutions in the archive, followed by an \"adaptive segment mutation\" that modifies segments based on their contribution to both objectives, ensuring feasibility while exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives and compute a combined score\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined_scores = normalized[:, 0] + normalized[:, 1] - 0.5 * np.std(normalized, axis=1)\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment crossover\n    if n > 4 and len(archive) > 1:\n        # Select another solution from archive\n        other_idx = np.random.randint(0, len(archive))\n        while other_idx == selected_idx and len(archive) > 1:\n            other_idx = np.random.randint(0, len(archive))\n        other_solution = archive[other_idx][0]\n\n        # Find segments that contribute differently to each objective\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Find corresponding segment in other solution\n        other_segment = other_solution[np.where(np.isin(other_solution, segment))[0]]\n\n        # Combine segments based on objective contributions\n        combined_segment = np.concatenate([segment, other_segment])\n        combined_segment = np.unique(combined_segment)\n\n        # Insert combined segment at random position\n        insert_pos = np.random.randint(1, n)\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            combined_segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, combined_segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple insertion if duplicates occur\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_end:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Adaptive segment mutation\n    if n > 3:\n        # Select segment based on its contribution to both objectives\n        seg_start = np.random.randint(1, n-1)\n        seg_end = np.random.randint(seg_start+1, n)\n\n        # Calculate segment cost in both objectives\n        def segment_cost(sol, start, end, dist_mat):\n            cost = 0\n            for i in range(start, end-1):\n                cost += dist_mat[sol[i], sol[i+1]]\n            cost += dist_mat[sol[end-1], sol[start]]\n            return cost\n\n        cost1 = segment_cost(new_solution, seg_start, seg_end, distance_matrix_1)\n        cost2 = segment_cost(new_solution, seg_start, seg_end, distance_matrix_2)\n\n        # Decide mutation based on which objective is more critical\n        if cost1 > cost2 * 1.2:  # First objective is more critical\n            # Reverse segment to reduce first objective cost\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        elif cost2 > cost1 * 1.2:  # Second objective is more critical\n            # Rotate segment to reduce second objective cost\n            new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], 1)\n        else:  # Both objectives are balanced\n            # Randomly choose between reverse and rotate\n            if np.random.rand() < 0.5:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9649220163944144,
            0.20292329788208008
        ]
    }
]