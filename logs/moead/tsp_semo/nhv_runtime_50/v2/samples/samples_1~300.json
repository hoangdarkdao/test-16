[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.785383739934572,
            1.5138196349143982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.785383739934572,
            1.5138196349143982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.785383739934572,
            1.5138196349143982
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8594225974254139,
            2.6805266737937927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8594225974254139,
            2.6805266737937927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Node insertion\n    k = np.random.choice(n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    m = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, m, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8149781357511242,
            2.615936040878296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Node insertion\n    k = np.random.choice(n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    m = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, m, node)\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Perform 2-opt on the first objective\n    for i in range(N):\n        for j in range(i + 2, N):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%N]\n            if distance_matrix_1[a, c] + distance_matrix_1[b, d] < distance_matrix_1[a, b] + distance_matrix_1[c, d]:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Step 2: Apply a novel edge insertion strategy on the second objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            a, b = new_solution[i], new_solution[(i+1)%N]\n            c, d = new_solution[j], new_solution[(j+1)%N]\n            if distance_matrix_2[a, d] + distance_matrix_2[b, c] < distance_matrix_2[a, b] + distance_matrix_2[c, d]:\n                # Insert c between a and b, and d between c and b\n                new_solution[(i+1)%N] = c\n                new_solution[(j+1)%N] = d\n\n    return new_solution\n\n",
        "score": [
            -0.664781108396442,
            8.626519560813904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Step 1: Perform 2-opt on the first objective\n    for i in range(N):\n        for j in range(i + 2, N):\n            a, b = new_solution[i], new_solution[i+1]\n            c, d = new_solution[j], new_solution[(j+1)%N]\n            if distance_matrix_1[a, c] + distance_matrix_1[b, d] < distance_matrix_1[a, b] + distance_matrix_1[c, d]:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Step 2: Apply a novel edge insertion strategy on the second objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            a, b = new_solution[i], new_solution[(i+1)%N]\n            c, d = new_solution[j], new_solution[(j+1)%N]\n            if distance_matrix_2[a, d] + distance_matrix_2[b, c] < distance_matrix_2[a, b] + distance_matrix_2[c, d]:\n                # Insert c between a and b, and d between c and b\n                new_solution[(i+1)%N] = c\n                new_solution[(j+1)%N] = d\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply a novel segment shift (move a segment to a new position)\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.9599399568327655,
            1.1090697050094604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply a novel segment shift (move a segment to a new position)\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply a novel segment shift (move a segment to a new position)\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.9599399568327655,
            1.1090697050094604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply a novel segment shift (move a segment to a new position)\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply a novel segment shift (move a segment to a new position)\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.9599399568327655,
            1.1090697050094604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal and swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select two segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly select two nodes and swap them\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply a novel segment shift (move a segment to a new position)\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware partial tour reconstruction with a randomized node insertion, prioritizing solutions with high crowding distance or Pareto dominance to explore promising regions while ensuring feasibility through a novel feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Step 1: Multi-objective aware partial tour reconstruction\n    if n > 3:\n        k = np.random.randint(2, n-1)\n        i = np.random.randint(0, n-k)\n        segment = base_solution[i:i+k]\n\n        # Calculate cost of the segment\n        segment_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, k))\n        segment_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, k))\n\n        # Reconstruct the segment in reverse order\n        new_segment = segment[::-1]\n        new_segment_cost1 = sum(distance_matrix_1[new_segment[j-1], new_segment[j]] for j in range(1, k))\n        new_segment_cost2 = sum(distance_matrix_2[new_segment[j-1], new_segment[j]] for j in range(1, k))\n\n        # Accept if at least one objective improves\n        if (new_segment_cost1 < segment_cost1) or (new_segment_cost2 < segment_cost2):\n            base_solution[i:i+k] = new_segment\n\n    # Step 2: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i-j) > 1:\n            node = base_solution[i]\n            new_solution = np.delete(base_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Ensure feasibility by checking if all nodes are visited exactly once\n            if len(np.unique(new_solution)) == n:\n                base_solution = new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.8276733495390356,
            1.4295347332954407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Step 1: Multi-objective aware partial tour reconstruction\n    if n > 3:\n        k = np.random.randint(2, n-1)\n        i = np.random.randint(0, n-k)\n        segment = base_solution[i:i+k]\n\n        # Calculate cost of the segment\n        segment_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, k))\n        segment_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, k))\n\n        # Reconstruct the segment in reverse order\n        new_segment = segment[::-1]\n        new_segment_cost1 = sum(distance_matrix_1[new_segment[j-1], new_segment[j]] for j in range(1, k))\n        new_segment_cost2 = sum(distance_matrix_2[new_segment[j-1], new_segment[j]] for j in range(1, k))\n\n        # Accept if at least one objective improves\n        if (new_segment_cost1 < segment_cost1) or (new_segment_cost2 < segment_cost2):\n            base_solution[i:i+k] = new_segment\n\n    # Step 2: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i-j) > 1:\n            node = base_solution[i]\n            new_solution = np.delete(base_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Ensure feasibility by checking if all nodes are visited exactly once\n            if len(np.unique(new_solution)) == n:\n                base_solution = new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel multi-objective dominance metric, then applies a hybrid local search combining edge-based crossovers and adaptive segment insertions, ensuring feasibility through a constraint-aware validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose solution with highest product of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-8)\n    scores = normalized.prod(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Edge crossover with adaptive segment insertion\n    for _ in range(3):\n        # Random edge selection from base solution\n        a, b = np.random.choice(n, size=2, replace=False)\n        edge_a = (base_solution[a], base_solution[(a+1)%n])\n        edge_b = (base_solution[b], base_solution[(b+1)%n])\n\n        # Create new segment by combining edges\n        new_segment = [edge_a[0], edge_b[0], edge_a[1], edge_b[1]]\n        new_segment = np.unique(new_segment)\n\n        # Insert adaptively into new solution\n        pos = np.random.randint(n)\n        new_solution = np.concatenate([\n            new_solution[:pos],\n            new_segment,\n            new_solution[pos:]\n        ])\n\n        # Remove duplicates and ensure tour validity\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n        if len(new_solution) == n:\n            break\n\n    # Final validation\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.818540008726769,
            1.69881272315979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose solution with highest product of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-8)\n    scores = normalized.prod(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Edge crossover with adaptive segment insertion\n    for _ in range(3):\n        # Random edge selection from base solution\n        a, b = np.random.choice(n, size=2, replace=False)\n        edge_a = (base_solution[a], base_solution[(a+1)%n])\n        edge_b = (base_solution[b], base_solution[(b+1)%n])\n\n        # Create new segment by combining edges\n        new_segment = [edge_a[0], edge_b[0], edge_a[1], edge_b[1]]\n        new_segment = np.unique(new_segment)\n\n        # Insert adaptively into new solution\n        pos = np.random.randint(n)\n        new_solution = np.concatenate([\n            new_solution[:pos],\n            new_segment,\n            new_solution[pos:]\n        ])\n\n        # Remove duplicates and ensure tour validity\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n        if len(new_solution) == n:\n            break\n\n    # Final validation\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment relocation with a guided node insertion, using a combined objective ranking to prioritize segments with high potential for improvement while maintaining feasibility through a permutation validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    if n > 3:\n        # Select a random segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b].copy()\n\n        # Calculate potential insertion points\n        candidates = [i for i in range(n) if i < a or i >= b]\n        if not candidates:\n            return base_solution\n\n        # Evaluate insertion points based on combined cost reduction\n        best_insert = None\n        min_cost = float('inf')\n\n        for i in candidates:\n            # Calculate cost before insertion\n            if i == 0:\n                before_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n                before_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n            else:\n                before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n                before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n\n            total_cost = (new_cost1 - before_cost1) + (new_cost2 - before_cost2)\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert = i\n\n        if best_insert is not None:\n            # Remove the segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:]\n            ])\n\n            if best_insert == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert],\n                    segment,\n                    new_solution[best_insert:]\n                ])\n\n    # Guided node insertion\n    if n > 2:\n        # Select a random node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node temporarily\n        temp_solution = np.concatenate([\n            new_solution[:node_idx],\n            new_solution[node_idx+1:]\n        ])\n\n        # Find best insertion point based on combined cost reduction\n        best_pos = None\n        min_cost = float('inf')\n\n        for i in range(len(temp_solution)):\n            if i == 0:\n                cost1 = distance_matrix_1[temp_solution[-1], node] + distance_matrix_1[node, temp_solution[0]]\n                cost2 = distance_matrix_2[temp_solution[-1], node] + distance_matrix_2[node, temp_solution[0]]\n            else:\n                cost1 = distance_matrix_1[temp_solution[i-1], node] + distance_matrix_1[node, temp_solution[i]]\n                cost2 = distance_matrix_2[temp_solution[i-1], node] + distance_matrix_2[node, temp_solution[i]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        if best_pos is not None:\n            if best_pos == 0:\n                new_solution = np.concatenate([[node], temp_solution])\n            else:\n                new_solution = np.concatenate([\n                    temp_solution[:best_pos],\n                    [node],\n                    temp_solution[best_pos:]\n                ])\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9228909905241007,
            1.870855450630188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    if n > 3:\n        # Select a random segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b].copy()\n\n        # Calculate potential insertion points\n        candidates = [i for i in range(n) if i < a or i >= b]\n        if not candidates:\n            return base_solution\n\n        # Evaluate insertion points based on combined cost reduction\n        best_insert = None\n        min_cost = float('inf')\n\n        for i in candidates:\n            # Calculate cost before insertion\n            if i == 0:\n                before_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n                before_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n            else:\n                before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n                before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n\n            total_cost = (new_cost1 - before_cost1) + (new_cost2 - before_cost2)\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert = i\n\n        if best_insert is not None:\n            # Remove the segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:]\n            ])\n\n            if best_insert == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:best_insert],\n                    segment,\n                    new_solution[best_insert:]\n                ])\n\n    # Guided node insertion\n    if n > 2:\n        # Select a random node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node temporarily\n        temp_solution = np.concatenate([\n            new_solution[:node_idx],\n            new_solution[node_idx+1:]\n        ])\n\n        # Find best insertion point based on combined cost reduction\n        best_pos = None\n        min_cost = float('inf')\n\n        for i in range(len(temp_solution)):\n            if i == 0:\n                cost1 = distance_matrix_1[temp_solution[-1], node] + distance_matrix_1[node, temp_solution[0]]\n                cost2 = distance_matrix_2[temp_solution[-1], node] + distance_matrix_2[node, temp_solution[0]]\n            else:\n                cost1 = distance_matrix_1[temp_solution[i-1], node] + distance_matrix_1[node, temp_solution[i]]\n                cost2 = distance_matrix_2[temp_solution[i-1], node] + distance_matrix_2[node, temp_solution[i]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        if best_pos is not None:\n            if best_pos == 0:\n                new_solution = np.concatenate([[node], temp_solution])\n            else:\n                new_solution = np.concatenate([\n                    temp_solution[:best_pos],\n                    [node],\n                    temp_solution[best_pos:]\n                ])\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This novel algorithm combines adaptive edge exchanges with multi-objective-aware segment insertions, guided by a dynamic balance of objective-space improvements while ensuring feasibility through a constrained validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest product of objectives (trade-off solutions)\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive edge exchange with segment insertion\n    for _ in range(5):\n        # Randomly select two edges to exchange\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        l = (k + 1) % n\n\n        # Store original connections\n        orig_i = new_solution[i]\n        orig_j = new_solution[j]\n        orig_k = new_solution[k]\n        orig_l = new_solution[l]\n\n        # Perform edge exchange\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Check if exchange improved both objectives\n        original_cost1 = distance_matrix_1[orig_i, orig_j] + distance_matrix_1[orig_k, orig_l]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]]\n        original_cost2 = distance_matrix_2[orig_i, orig_j] + distance_matrix_2[orig_k, orig_l]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or np.random.random() < 0.3:\n            # Accept if both objectives improved or with small probability\n            pass\n        else:\n            # Revert exchange if not beneficial\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Perform segment insertion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8449626322027493,
            1.9574848413467407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest product of objectives (trade-off solutions)\n    selected_idx = np.argmax([obj[0] * obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive edge exchange with segment insertion\n    for _ in range(5):\n        # Randomly select two edges to exchange\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        l = (k + 1) % n\n\n        # Store original connections\n        orig_i = new_solution[i]\n        orig_j = new_solution[j]\n        orig_k = new_solution[k]\n        orig_l = new_solution[l]\n\n        # Perform edge exchange\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Check if exchange improved both objectives\n        original_cost1 = distance_matrix_1[orig_i, orig_j] + distance_matrix_1[orig_k, orig_l]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]]\n        original_cost2 = distance_matrix_2[orig_i, orig_j] + distance_matrix_2[orig_k, orig_l]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or np.random.random() < 0.3:\n            # Accept if both objectives improved or with small probability\n            pass\n        else:\n            # Revert exchange if not beneficial\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n        # Perform segment insertion\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The new algorithm combines a novel multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with higher crowding distance or Pareto dominance to explore less crowded regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Select a segment and a position to relocate it\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        pos = np.random.randint(0, n - (b - a))\n\n        # Extract the segment and remove it from the solution\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        # Select two random edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8771955923437851,
            2.3361749053001404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Select a segment and a position to relocate it\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        pos = np.random.randint(0, n - (b - a))\n\n        # Extract the segment and remove it from the solution\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        # Select two random edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0215952756280455,
            1.3822544813156128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0215952756280455,
            1.3822544813156128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node insertion with a guided segment relocation, prioritizing solutions with high edge diversity in the archive to explore less crowded regions while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high edge diversity\n    edge_diversity = []\n    for sol, _ in archive:\n        edges = set()\n        for i in range(len(sol)-1):\n            edges.add((sol[i], sol[i+1]))\n        edges.add((sol[-1], sol[0]))\n        edge_diversity.append(len(edges))\n    selected_idx = np.argmax(edge_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion + segment relocation\n    for _ in range(3):\n        # Node insertion\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation\n        if n > 4:\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            segment = new_solution[a:b]\n            new_solution = np.delete(new_solution, np.arange(a, b))\n            pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, pos, segment)\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.752343431502014,
            5.851126134395599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high edge diversity\n    edge_diversity = []\n    for sol, _ in archive:\n        edges = set()\n        for i in range(len(sol)-1):\n            edges.add((sol[i], sol[i+1]))\n        edges.add((sol[-1], sol[0]))\n        edge_diversity.append(len(edges))\n    selected_idx = np.argmax(edge_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: node insertion + segment relocation\n    for _ in range(3):\n        # Node insertion\n        if n > 3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Segment relocation\n        if n > 4:\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            segment = new_solution[a:b]\n            new_solution = np.delete(new_solution, np.arange(a, b))\n            pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, pos, segment)\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block rotation with a dynamic edge insertion, prioritizing solutions with high crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block rotation\n    if n > 3:\n        a = np.random.randint(0, n-2)\n        b = np.random.randint(a+1, n-1)\n        c = np.random.randint(b+1, n)\n        new_solution[a:c] = np.roll(new_solution[a:c], b-a)\n\n    # Step 2: Dynamic edge insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        if i < j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        else:\n            new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n            new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j-1:i-1:-1], new_solution[j:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], new_solution[i:j-1:-1], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8844870086371719,
            2.2463780641555786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block rotation\n    if n > 3:\n        a = np.random.randint(0, n-2)\n        b = np.random.randint(a+1, n-1)\n        c = np.random.randint(b+1, n)\n        new_solution[a:c] = np.roll(new_solution[a:c], b-a)\n\n    # Step 2: Dynamic edge insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        if i < j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        else:\n            new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n            new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j-1:i-1:-1], new_solution[j:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], new_solution[i:j-1:-1], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel hybrid local search algorithm that combines node insertions with guided edge swaps, prioritizing high-contribution edges in both objective spaces while maintaining feasibility through a dynamic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective (weighted sum)\n    weights = np.array([0.6, 0.4])  # Prioritize first objective\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)  # Lower is better\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: insert node with guided edge swaps\n    for _ in range(3):\n        # Select high-contribution edge to modify\n        edge_scores = []\n        for i in range(n-1):\n            node_a, node_b = new_solution[i], new_solution[i+1]\n            score = (weights[0] * distance_matrix_1[node_a, node_b] +\n                     weights[1] * distance_matrix_2[node_a, node_b])\n            edge_scores.append(score)\n\n        edge_scores = np.array(edge_scores)\n        target_edge = np.argmax(edge_scores)  # Most expensive edge\n\n        # Perform node insertion at target edge\n        if target_edge < n-2:\n            a, b, c = new_solution[target_edge], new_solution[target_edge+1], new_solution[target_edge+2]\n\n            # Try inserting node c between a and b\n            new_solution[target_edge+1:target_edge+3] = [c, b]\n\n            # Validate\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7904690326489735,
            7.968005657196045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective (weighted sum)\n    weights = np.array([0.6, 0.4])  # Prioritize first objective\n    objectives = np.array([obj for _, obj in archive])\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)  # Lower is better\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: insert node with guided edge swaps\n    for _ in range(3):\n        # Select high-contribution edge to modify\n        edge_scores = []\n        for i in range(n-1):\n            node_a, node_b = new_solution[i], new_solution[i+1]\n            score = (weights[0] * distance_matrix_1[node_a, node_b] +\n                     weights[1] * distance_matrix_2[node_a, node_b])\n            edge_scores.append(score)\n\n        edge_scores = np.array(edge_scores)\n        target_edge = np.argmax(edge_scores)  # Most expensive edge\n\n        # Perform node insertion at target edge\n        if target_edge < n-2:\n            a, b, c = new_solution[target_edge], new_solution[target_edge+1], new_solution[target_edge+2]\n\n            # Try inserting node c between a and b\n            new_solution[target_edge+1:target_edge+3] = [c, b]\n\n            # Validate\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm that combines edge swaps with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9533332619017396,
            0.9566066861152649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm that combines edge swaps with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9533332619017396,
            0.9566066861152649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A novel hybrid local search operator that combines a randomized k-opt move with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto non-dominated status to guide the search toward diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-opt move (k=3)\n    if n > 3:\n        k = 3\n        indices = sorted(np.random.choice(n, size=k, replace=False))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8613334731723591,
            2.021054685115814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-opt move (k=3)\n    if n > 3:\n        k = 3\n        indices = sorted(np.random.choice(n, size=k, replace=False))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic node swapping with guided edge reinsertion, prioritizing segments that show potential for cross-objective improvement while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        # Select a random segment and swap nodes within it\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Reinsert a randomly selected node to maintain feasibility\n        if len(np.unique(new_solution)) != n:\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Probabilistically accept the change if it improves at least one objective\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        if current_cost1 < objectives[selected_idx][0] or current_cost2 < objectives[selected_idx][1]:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6331309855491825,
            2.916098415851593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        # Select a random segment and swap nodes within it\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Reinsert a randomly selected node to maintain feasibility\n        if len(np.unique(new_solution)) != n:\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Probabilistically accept the change if it improves at least one objective\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        if current_cost1 < objectives[selected_idx][0] or current_cost2 < objectives[selected_idx][1]:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective-aware edge reversal, favoring solutions with high crowding distance or Pareto dominance to explore underrepresented regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Multi-objective aware edge reversal\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8137678253786764,
            2.243022620677948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Multi-objective aware edge reversal\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node insertion with a randomized segment rotation, prioritizing solutions with high Pareto dominance or low crowding distance to guide the search toward diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance or low crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i-1 or j == i+1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Randomized segment rotation\n    if n > 4:\n        a = np.random.randint(0, n-3)\n        b = np.random.randint(a+2, n-1)\n        k = np.random.randint(1, b-a)\n        new_solution[a:b] = np.roll(new_solution[a:b], k)\n\n    return new_solution\n\n",
        "score": [
            -0.8378803509833694,
            2.1312174797058105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance or low crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i-1 or j == i+1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Randomized segment rotation\n    if n > 4:\n        a = np.random.randint(0, n-3)\n        b = np.random.randint(a+2, n-1)\n        k = np.random.randint(1, b-a)\n        new_solution[a:b] = np.roll(new_solution[a:b], k)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, leveraging dominance and crowding distance to guide exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        if i != j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            # Accept insertion if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7082139846861758,
            2.4022626876831055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        if i != j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            # Accept insertion if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines node swaps and partial route reversals, guided by a multi-objective ranking metric that balances edge contributions in both objective spaces, while ensuring feasibility through a validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of objectives (diverse solutions)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine node swaps and partial reversals\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = np.random.choice(n, size=2, replace=False)\n        k, l = np.random.choice(n, size=2, replace=False)\n\n        # Perform a hybrid operation: swap nodes and reverse a partial segment\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search algorithm selects solutions based on their Pareto dominance and edge contribution balance, using a weighted sum of normalized objectives to guide node insertions and segment reversals, while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: weighted node insertion and segment reversal\n    for _ in range(3):  # Reduced iterations for efficiency\n        # Select nodes based on edge contribution\n        total_cost = np.zeros(n)\n        for i in range(n):\n            prev = base_solution[i-1]\n            curr = base_solution[i]\n            next_node = base_solution[(i+1)%n]\n            total_cost[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                            distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n        # Weighted selection of nodes to modify\n        prob = np.exp(-total_cost / total_cost.max())\n        prob /= prob.sum()\n        i, j = np.random.choice(n, size=2, replace=False, p=prob)\n\n        # Perform weighted operation: insert node with probability, reverse segment otherwise\n        if np.random.rand() < 0.7:  # Higher probability for insertion\n            # Node insertion\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, base_solution[i])\n        else:\n            # Segment reversal\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7964567724842917,
            3.3358874917030334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weight for first objective is higher\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: weighted node insertion and segment reversal\n    for _ in range(3):  # Reduced iterations for efficiency\n        # Select nodes based on edge contribution\n        total_cost = np.zeros(n)\n        for i in range(n):\n            prev = base_solution[i-1]\n            curr = base_solution[i]\n            next_node = base_solution[(i+1)%n]\n            total_cost[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                            distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n        # Weighted selection of nodes to modify\n        prob = np.exp(-total_cost / total_cost.max())\n        prob /= prob.sum()\n        i, j = np.random.choice(n, size=2, replace=False, p=prob)\n\n        # Perform weighted operation: insert node with probability, reverse segment otherwise\n        if np.random.rand() < 0.7:  # Higher probability for insertion\n            # Node insertion\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, base_solution[i])\n        else:\n            # Segment reversal\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm combines a multi-objective aware node insertion heuristic with a dynamic segment relocation strategy, prioritizing solutions with high crowding distance or Pareto dominance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node insertion + dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node insertion\n    if n > 2:\n        # Select a random node to remove\n        remove_pos = np.random.randint(0, n)\n        removed_node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for i in range(n-1):\n            # Calculate cost for inserting after position i\n            cost1 = distance_matrix_1[new_solution[i], removed_node] + distance_matrix_1[removed_node, new_solution[(i+1)%(n-1)]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[i], removed_node] + distance_matrix_2[removed_node, new_solution[(i+1)%(n-1)]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]]\n\n            # Combine objectives using a simple weighted sum (can be replaced with Pareto dominance)\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost1 + best_cost2:\n                best_pos = i + 1\n                best_cost1, best_cost2 = cost1, cost2\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 2: Dynamic segment relocation\n    if n > 3:\n        # Select a random segment to relocate\n        segment_length = np.random.randint(2, min(4, n-1))\n        start_pos = np.random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n        new_solution = np.delete(new_solution, np.s_[start_pos:start_pos+segment_length])\n\n        # Find the best insertion position for the segment\n        best_pos = 0\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for i in range(len(new_solution)):\n            # Calculate cost for inserting the segment after position i\n            if i == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[i-1]\n\n            next_node = new_solution[i]\n\n            cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine objectives\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost1 + best_cost2:\n                best_pos = i + 1\n                best_cost1, best_cost2 = cost1, cost2\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9692894380971513,
            3.608546197414398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: node insertion + dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node insertion\n    if n > 2:\n        # Select a random node to remove\n        remove_pos = np.random.randint(0, n)\n        removed_node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for i in range(n-1):\n            # Calculate cost for inserting after position i\n            cost1 = distance_matrix_1[new_solution[i], removed_node] + distance_matrix_1[removed_node, new_solution[(i+1)%(n-1)]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[i], removed_node] + distance_matrix_2[removed_node, new_solution[(i+1)%(n-1)]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]]\n\n            # Combine objectives using a simple weighted sum (can be replaced with Pareto dominance)\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost1 + best_cost2:\n                best_pos = i + 1\n                best_cost1, best_cost2 = cost1, cost2\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 2: Dynamic segment relocation\n    if n > 3:\n        # Select a random segment to relocate\n        segment_length = np.random.randint(2, min(4, n-1))\n        start_pos = np.random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos+segment_length]\n        new_solution = np.delete(new_solution, np.s_[start_pos:start_pos+segment_length])\n\n        # Find the best insertion position for the segment\n        best_pos = 0\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for i in range(len(new_solution)):\n            # Calculate cost for inserting the segment after position i\n            if i == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[i-1]\n\n            next_node = new_solution[i]\n\n            cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine objectives\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost1 + best_cost2:\n                best_pos = i + 1\n                best_cost1, best_cost2 = cost1, cost2\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware path reordering with a dynamic segment crossover, where it first identifies critical nodes based on their contribution to both objectives and then performs a guided crossover between segments from different solutions in the archive to generate a new, high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potentially for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical nodes based on their contribution to both objectives\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1) % n]\n\n        # Calculate the contribution of the node to both objectives\n        contribution1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        contribution2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        if contribution1 > np.mean(distance_matrix_1) or contribution2 > np.mean(distance_matrix_2):\n            critical_nodes.add(node)\n\n    # Perform dynamic segment crossover with another solution in the archive\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find segments in the other solution that are not critical in the base solution\n        non_critical_segments = []\n        current_segment = []\n        for node in other_solution:\n            if node not in critical_nodes:\n                current_segment.append(node)\n            else:\n                if current_segment:\n                    non_critical_segments.append(current_segment)\n                    current_segment = []\n        if current_segment:\n            non_critical_segments.append(current_segment)\n\n        if non_critical_segments:\n            selected_segment = np.random.choice(non_critical_segments)\n            insert_pos = np.random.randint(0, n - len(selected_segment) + 1)\n\n            # Insert the segment into the base solution\n            new_solution = np.concatenate([\n                base_solution[:insert_pos],\n                selected_segment,\n                base_solution[insert_pos + len(selected_segment):]\n            ])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in random positions\n        missing_nodes = list(set(range(n)) - set(new_solution))\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8961506179298315,
            4.336313784122467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potentially for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical nodes based on their contribution to both objectives\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1) % n]\n\n        # Calculate the contribution of the node to both objectives\n        contribution1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        contribution2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        if contribution1 > np.mean(distance_matrix_1) or contribution2 > np.mean(distance_matrix_2):\n            critical_nodes.add(node)\n\n    # Perform dynamic segment crossover with another solution in the archive\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find segments in the other solution that are not critical in the base solution\n        non_critical_segments = []\n        current_segment = []\n        for node in other_solution:\n            if node not in critical_nodes:\n                current_segment.append(node)\n            else:\n                if current_segment:\n                    non_critical_segments.append(current_segment)\n                    current_segment = []\n        if current_segment:\n            non_critical_segments.append(current_segment)\n\n        if non_critical_segments:\n            selected_segment = np.random.choice(non_critical_segments)\n            insert_pos = np.random.randint(0, n - len(selected_segment) + 1)\n\n            # Insert the segment into the base solution\n            new_solution = np.concatenate([\n                base_solution[:insert_pos],\n                selected_segment,\n                base_solution[insert_pos + len(selected_segment):]\n            ])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in random positions\n        missing_nodes = list(set(range(n)) - set(new_solution))\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm combines a multi-objective-aware segment relocation with a probabilistic edge reversal operator, guided by solution diversity and Pareto front proximity to explore high-potential regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on diversity and Pareto front position\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate insertion points considering both objectives\n        best_pos = start\n        best_score = float('inf')\n\n        for pos in range(0, n - segment_length + 1):\n            if pos == start:\n                continue\n\n            # Create temporary solution\n            temp = new_solution.copy()\n            segment = temp[start:end]\n            temp = np.concatenate([temp[:start], temp[end:]])\n            temp = np.insert(temp, pos, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n))\n\n            # Score based on combined objective improvement\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != start:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Probabilistic edge reversal with multi-objective consideration\n    if n > 4:\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if j - i > 1:\n                segment = new_solution[i:j]\n                reversed_segment = segment[::-1]\n\n                # Calculate cost before and after reversal\n                original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n                original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n                new_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n                new_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n                # Accept with probability based on improvement\n                if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                    new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.876928192533813,
            12.538636028766632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on diversity and Pareto front position\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Evaluate insertion points considering both objectives\n        best_pos = start\n        best_score = float('inf')\n\n        for pos in range(0, n - segment_length + 1):\n            if pos == start:\n                continue\n\n            # Create temporary solution\n            temp = new_solution.copy()\n            segment = temp[start:end]\n            temp = np.concatenate([temp[:start], temp[end:]])\n            temp = np.insert(temp, pos, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(n))\n\n            # Score based on combined objective improvement\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != start:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Probabilistic edge reversal with multi-objective consideration\n    if n > 4:\n        for _ in range(2):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            if j - i > 1:\n                segment = new_solution[i:j]\n                reversed_segment = segment[::-1]\n\n                # Calculate cost before and after reversal\n                original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n                original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n                new_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n                new_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n                # Accept with probability based on improvement\n                if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                    new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A novel adaptive local search algorithm combines multi-objective edge swapping with probabilistic segment reversals, dynamically balancing exploration and exploitation through adaptive neighborhood selection and feasibility-preserving operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive operation: multi-objective edge swapping with probabilistic segment reversal\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]] +\n                        distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]])\n        new_cost = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]])\n\n        if new_cost < current_cost:\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # With probability 0.3, reverse a segment between i and j\n            if np.random.random() < 0.3 and i != j:\n                segment = new_solution[min(i,j):max(i,j)+1]\n                new_solution[min(i,j):max(i,j)+1] = segment[::-1]\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.004941033179202,
            1.4385267496109009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive operation: multi-objective edge swapping with probabilistic segment reversal\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate potential improvement in both objectives\n        current_cost = (distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]] +\n                        distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]])\n        new_cost = (distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]] +\n                    distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]])\n\n        if new_cost < current_cost:\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # With probability 0.3, reverse a segment between i and j\n            if np.random.random() < 0.3 and i != j:\n                segment = new_solution[min(i,j):max(i,j)+1]\n                new_solution[min(i,j):max(i,j)+1] = segment[::-1]\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{The new algorithm combines a multi-objective-aware segment rotation with a randomized edge reversal, prioritizing solutions with high crowding distance to explore less crowded regions while ensuring feasibility through careful segment manipulation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment rotation\n    if n > 3:\n        a = np.random.randint(0, n-3)\n        b = np.random.randint(a+2, n-1)\n        c = np.random.randint(b+1, n)\n\n        # Rotate segment [a+1:b] to position between b and c\n        segment = new_solution[a+1:b]\n        new_solution = np.concatenate((new_solution[:a+1], new_solution[b:c], segment, new_solution[c:]))\n\n        # Calculate cost before and after rotation\n        original_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n        # Revert if rotation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Calculate cost before and after reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Revert if reversal worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7881244884401853,
            1.8094537854194641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment rotation\n    if n > 3:\n        a = np.random.randint(0, n-3)\n        b = np.random.randint(a+2, n-1)\n        c = np.random.randint(b+1, n)\n\n        # Rotate segment [a+1:b] to position between b and c\n        segment = new_solution[a+1:b]\n        new_solution = np.concatenate((new_solution[:a+1], new_solution[b:c], segment, new_solution[c:]))\n\n        # Calculate cost before and after rotation\n        original_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n        # Revert if rotation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Calculate cost before and after reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Revert if reversal worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swaps with multi-objective aware segment reversals, dynamically prioritizing critical edges based on their potential for improvement in both objectives while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with segment reversals\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_cost < old_cost:\n            # Perform swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # With probability, reverse a segment\n            if np.random.random() < 0.3:\n                c, d = np.random.choice(n, size=2, replace=False)\n                if c > d:\n                    c, d = d, c\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9151827909907871,
            2.163405954837799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with segment reversals\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_cost < old_cost:\n            # Perform swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # With probability, reverse a segment\n            if np.random.random() < 0.3:\n                c, d = np.random.choice(n, size=2, replace=False)\n                if c > d:\n                    c, d = d, c\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block relocation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized block relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n-1], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n-1], new_solution[(i+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    return new_solution\n\n",
        "score": [
            -0.9046287829971795,
            2.6109612584114075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized block relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[(i+1)%n-1], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[(i+1)%n-1], new_solution[(i+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{A novel hybrid local search operator that combines a randomized 3-opt move with a multi-objective aware node insertion, leveraging both dominance and diversity metrics to guide the search toward Pareto-optimal regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 3-opt move\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        best_pos = node_to_move\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move + 1) % n:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] + \\\n                             distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] + \\\n                             distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[node_to_move]] + \\\n                         distance_matrix_1[new_solution[node_to_move], new_solution[pos]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[node_to_move]] + \\\n                         distance_matrix_2[new_solution[node_to_move], new_solution[pos]]\n\n            # Calculate improvement in both objectives\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            # Accept if improves at least one objective\n            if (improvement1 > 0) or (improvement2 > 0):\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n        if best_pos != node_to_move:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9499735629158366,
            2.978997826576233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 3-opt move\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        best_pos = node_to_move\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move + 1) % n:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] + \\\n                             distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] + \\\n                             distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[node_to_move]] + \\\n                         distance_matrix_1[new_solution[node_to_move], new_solution[pos]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[node_to_move]] + \\\n                         distance_matrix_2[new_solution[node_to_move], new_solution[pos]]\n\n            # Calculate improvement in both objectives\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            # Accept if improves at least one objective\n            if (improvement1 > 0) or (improvement2 > 0):\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n        if best_pos != node_to_move:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap segments [a, b] and [b+1, c]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.878415663740447,
            1.0018594861030579
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap segments [a, b] and [b+1, c]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a multi-objective aware node insertion, prioritizing solutions with high crowding distance or Pareto dominance in the archive to guide the search toward diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n-1))\n        start_pos = np.random.randint(0, n-segment_length)\n        insert_pos = np.random.randint(0, n-segment_length)\n\n        segment = new_solution[start_pos:start_pos+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_solution[start_pos+segment_length:]\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        best_pos = -1\n        min_cost1, min_cost2 = float('inf'), float('inf')\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move - 1) % n:\n                continue\n\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            original_node = new_solution[node_to_move]\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n\n            # Calculate cost after insertion\n            new_cost1 = (distance_matrix_1[prev_node, original_node] +\n                         distance_matrix_1[original_node, next_node])\n            new_cost2 = (distance_matrix_2[prev_node, original_node] +\n                         distance_matrix_2[original_node, next_node])\n\n            # Check if insertion improves at least one objective\n            if (new_cost1 < min_cost1) or (new_cost2 < min_cost2):\n                min_cost1, min_cost2 = new_cost1, new_cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            node = new_solution[node_to_move]\n            new_solution = np.concatenate([\n                new_solution[:node_to_move],\n                new_solution[node_to_move+1:]\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8573916037319353,
            1.931026577949524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n-1))\n        start_pos = np.random.randint(0, n-segment_length)\n        insert_pos = np.random.randint(0, n-segment_length)\n\n        segment = new_solution[start_pos:start_pos+segment_length]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_solution[start_pos+segment_length:]\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        best_pos = -1\n        min_cost1, min_cost2 = float('inf'), float('inf')\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move - 1) % n:\n                continue\n\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n            original_node = new_solution[node_to_move]\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n\n            # Calculate cost after insertion\n            new_cost1 = (distance_matrix_1[prev_node, original_node] +\n                         distance_matrix_1[original_node, next_node])\n            new_cost2 = (distance_matrix_2[prev_node, original_node] +\n                         distance_matrix_2[original_node, next_node])\n\n            # Check if insertion improves at least one objective\n            if (new_cost1 < min_cost1) or (new_cost2 < min_cost2):\n                min_cost1, min_cost2 = new_cost1, new_cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            node = new_solution[node_to_move]\n            new_solution = np.concatenate([\n                new_solution[:node_to_move],\n                new_solution[node_to_move+1:]\n            ])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This new algorithm uses a combination of adaptive segment rotation and Pareto-optimal edge insertion, prioritizing solutions with high Pareto dominance while adaptively adjusting the segment size based on the current solution quality to explore diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        segment_size = max(2, min(n // 3, np.random.randint(2, n // 2)))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        rotated_segment = np.roll(new_solution[start:end], np.random.randint(1, segment_size))\n        new_solution[start:end] = rotated_segment\n\n    # Pareto-optimal edge insertion\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n        k = np.random.randint(j+1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                          distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                          distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        # Calculate cost after insertion\n        new_cost1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[k], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[k], new_solution[j+1]])\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8343682978141321,
            1.7853045463562012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        segment_size = max(2, min(n // 3, np.random.randint(2, n // 2)))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        rotated_segment = np.roll(new_solution[start:end], np.random.randint(1, segment_size))\n        new_solution[start:end] = rotated_segment\n\n    # Pareto-optimal edge insertion\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n        k = np.random.randint(j+1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                          distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                          distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                          distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        # Calculate cost after insertion\n        new_cost1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[k], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[k], new_solution[j+1]])\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment rotation with a guided node exchange, prioritizing segments with high potential for improvement in both objectives while dynamically balancing the search between exploration and exploitation through adaptive segment size and exchange probability.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine adaptive segment size based on solution quality\n    segment_size = max(2, min(5, int(n / (10 + np.random.randint(0, 5)))))\n\n    # Multi-objective aware segment rotation\n    if n > segment_size + 1:\n        a = np.random.randint(0, n - segment_size)\n        segment = new_solution[a:a+segment_size]\n        rotation = np.random.randint(1, segment_size)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:a+segment_size] = rotated_segment\n\n    # Guided node exchange with adaptive probability\n    exchange_prob = 0.3 + 0.7 * (1 - (objectives[selected_idx][0] + objectives[selected_idx][1]) / objectives.sum())\n\n    if np.random.random() < exchange_prob and n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        # Calculate cost before exchange\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after exchange\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept exchange if it improves at least one objective or with small probability\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or np.random.random() < 0.1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9579088798613313,
            2.2812822461128235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine adaptive segment size based on solution quality\n    segment_size = max(2, min(5, int(n / (10 + np.random.randint(0, 5)))))\n\n    # Multi-objective aware segment rotation\n    if n > segment_size + 1:\n        a = np.random.randint(0, n - segment_size)\n        segment = new_solution[a:a+segment_size]\n        rotation = np.random.randint(1, segment_size)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[a:a+segment_size] = rotated_segment\n\n    # Guided node exchange with adaptive probability\n    exchange_prob = 0.3 + 0.7 * (1 - (objectives[selected_idx][0] + objectives[selected_idx][1]) / objectives.sum())\n\n    if np.random.random() < exchange_prob and n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        # Calculate cost before exchange\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after exchange\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept exchange if it improves at least one objective or with small probability\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or np.random.random() < 0.1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block relocation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized block relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.delete(new_solution, np.arange(a, b))\n\n        insert_pos = np.random.randint(0, n - (b - a))\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.917202128240848,
            1.6802859902381897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized block relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.delete(new_solution, np.arange(a, b))\n\n        insert_pos = np.random.randint(0, n - (b - a))\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel adaptive local search operator that combines a multi-objective aware segment relocation with a dynamic edge inversion, prioritizing solutions with higher hypervolume contribution to guide the search toward Pareto-optimal regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    hypervolumes = [obj[0] * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost\n        segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b))\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(0, n):\n            if pos >= a and pos < b:\n                continue\n\n            # Calculate new cost\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif pos == n-1:\n                new_cost1 = distance_matrix_1[new_solution[-2], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-2], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n            # Calculate improvement\n            improvement = (segment_cost1 - new_cost1) + (segment_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            # Insert segment at best position\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_pos == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Dynamic edge inversion\n    if n > 2:\n        # Select edges based on objective costs\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n\n        if obj1 > obj2:\n            # Invert edges in first objective space\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Invert edges in second objective space\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.940950883970702,
            2.0753828287124634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    hypervolumes = [obj[0] * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost\n        segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b))\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(0, n):\n            if pos >= a and pos < b:\n                continue\n\n            # Calculate new cost\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif pos == n-1:\n                new_cost1 = distance_matrix_1[new_solution[-2], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-2], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n            # Calculate improvement\n            improvement = (segment_cost1 - new_cost1) + (segment_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            # Insert segment at best position\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_pos == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Dynamic edge inversion\n    if n > 2:\n        # Select edges based on objective costs\n        obj1 = archive[selected_idx][1][0]\n        obj2 = archive[selected_idx][1][1]\n\n        if obj1 > obj2:\n            # Invert edges in first objective space\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Invert edges in second objective space\n            i, j = np.random.choice(n, size=2, replace=False)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This novel algorithm combines a multi-objective aware node substitution mechanism with a guided segment rotation strategy, leveraging both distance matrices to prioritize substitutions that improve at least one objective while maintaining feasibility through a dynamic node reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node substitution with guided segment rotation\n    for _ in range(5):\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n\n        # Find a candidate node to substitute\n        candidate_pos = np.random.randint(0, n)\n        candidate_node = new_solution[candidate_pos]\n\n        # Calculate costs before substitution\n        original_cost1 = distance_matrix_1[new_solution[candidate_pos-1], candidate_node] + distance_matrix_1[candidate_node, new_solution[(candidate_pos+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[candidate_pos-1], candidate_node] + distance_matrix_2[candidate_node, new_solution[(candidate_pos+1)%n]]\n\n        # Try substituting with nodes from the rotated segment\n        for node in segment:\n            if node == candidate_node:\n                continue\n\n            # Calculate new costs\n            new_cost1 = distance_matrix_1[new_solution[candidate_pos-1], node] + distance_matrix_1[node, new_solution[(candidate_pos+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[candidate_pos-1], node] + distance_matrix_2[node, new_solution[(candidate_pos+1)%n]]\n\n            # Accept substitution if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[candidate_pos] = node\n                break\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9175254767200338,
            2.0647127628326416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node substitution with guided segment rotation\n    for _ in range(5):\n        # Select a random segment to rotate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Rotate the segment\n        rotation = np.random.randint(1, len(segment))\n        segment = np.roll(segment, rotation)\n\n        # Find a candidate node to substitute\n        candidate_pos = np.random.randint(0, n)\n        candidate_node = new_solution[candidate_pos]\n\n        # Calculate costs before substitution\n        original_cost1 = distance_matrix_1[new_solution[candidate_pos-1], candidate_node] + distance_matrix_1[candidate_node, new_solution[(candidate_pos+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[candidate_pos-1], candidate_node] + distance_matrix_2[candidate_node, new_solution[(candidate_pos+1)%n]]\n\n        # Try substituting with nodes from the rotated segment\n        for node in segment:\n            if node == candidate_node:\n                continue\n\n            # Calculate new costs\n            new_cost1 = distance_matrix_1[new_solution[candidate_pos-1], node] + distance_matrix_1[node, new_solution[(candidate_pos+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[candidate_pos-1], node] + distance_matrix_2[node, new_solution[(candidate_pos+1)%n]]\n\n            # Accept substitution if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[candidate_pos] = node\n                break\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The new algorithm combines a multi-objective aware node relocation strategy with a dynamic segment reversal mechanism, where nodes are selectively moved based on their potential to improve both objectives while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (exploration focus)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    for _ in range(3):\n        # Select nodes with high potential for improvement\n        node1, node2 = np.random.choice(n, size=2, replace=False)\n        pos1, pos2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n        old_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n        # Swap nodes\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n        new_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n        new_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < old_cost1) or (new_cost2 < old_cost2)):\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Dynamic segment reversal\n    if n > 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Probabilistic acceptance based on improvement\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        new_solution[a:b] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        if np.random.random() > 0.5 and not ((new_cost1 < old_cost1) or (new_cost2 < old_cost2)):\n            new_solution[a:b] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6602319980321698,
            3.2627135515213013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (exploration focus)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    for _ in range(3):\n        # Select nodes with high potential for improvement\n        node1, node2 = np.random.choice(n, size=2, replace=False)\n        pos1, pos2 = np.where(new_solution == node1)[0][0], np.where(new_solution == node2)[0][0]\n\n        # Calculate potential improvement\n        old_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n        old_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n        # Swap nodes\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n        new_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n        new_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < old_cost1) or (new_cost2 < old_cost2)):\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Dynamic segment reversal\n    if n > 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Probabilistic acceptance based on improvement\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        new_solution[a:b] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        if np.random.random() > 0.5 and not ((new_cost1 < old_cost1) or (new_cost2 < old_cost2)):\n            new_solution[a:b] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{An adaptive hybrid local search operator that combines a dynamic segment relocation with a Pareto-aware edge reversal, using a multi-criteria selection to balance exploration and exploitation in the archive, while ensuring solution feasibility through constrained neighborhood operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection based on objective diversity and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic segment relocation + Pareto-aware edge reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Step 2: Pareto-aware edge reversal\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before reversal\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        # Calculate cost after reversal\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        # Accept reversal if it's Pareto-improving\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5916292675283317,
            2.6675729155540466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection based on objective diversity and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic segment relocation + Pareto-aware edge reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Step 2: Pareto-aware edge reversal\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before reversal\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        # Calculate cost after reversal\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        # Accept reversal if it's Pareto-improving\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment reversal\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8759708211948339,
            1.7108873128890991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: dynamic segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment reversal\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{A novel hybrid local search operator that combines a randomized k-opt move with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized k-opt move + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-opt move (k=3)\n    if n > 3:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[i:j+1]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        new_solution[i:j+1] = segment\n        new_solution = np.roll(new_solution, -k)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 1:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8402051312349074,
            2.509214401245117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized k-opt move + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-opt move (k=3)\n    if n > 3:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[i:j+1]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        new_solution[i:j+1] = segment\n        new_solution = np.roll(new_solution, -k)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 1:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relinking with a randomized node insertion, prioritizing solutions with high crowding distance to explore the trade-off frontier while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relinking + randomized node insertion\n    if n > 3:\n        # Segment relinking\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        remaining = np.setdiff1d(new_solution, segment)\n        new_solution = np.concatenate([remaining, segment])\n\n        # Randomized node insertion\n        if n > 4:\n            i = np.random.randint(1, n-1)\n            j = np.random.randint(1, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7746263907882425,
            4.2201380133628845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relinking + randomized node insertion\n    if n > 3:\n        # Segment relinking\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        remaining = np.setdiff1d(new_solution, segment)\n        new_solution = np.concatenate([remaining, segment])\n\n        # Randomized node insertion\n        if n > 4:\n            i = np.random.randint(1, n-1)\n            j = np.random.randint(1, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel hybrid local search algorithm that combines a Pareto-aware node sequence shuffle with a multi-objective edge reversal operator, dynamically balancing exploration of high-potential regions while ensuring feasibility through a constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance rank (simplified)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Pareto-aware node sequence shuffle\n    if n > 2:\n        k = np.random.randint(2, min(5, n//2))\n        segment = np.random.choice(n, size=k, replace=False)\n        np.random.shuffle(new_solution[segment])\n\n    # Multi-objective edge reversal\n    if n > 3:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Constraint-aware repair\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9306772092197612,
            2.964849591255188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance rank (simplified)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Pareto-aware node sequence shuffle\n    if n > 2:\n        k = np.random.randint(2, min(5, n//2))\n        segment = np.random.choice(n, size=k, replace=False)\n        np.random.shuffle(new_solution[segment])\n\n    # Multi-objective edge reversal\n    if n > 3:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Constraint-aware repair\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The backbone idea in the provided algorithms is to combine randomized segment inversion with multi-objective aware edge swaps, prioritizing solutions with high crowding distance or Pareto dominance to guide the search toward less explored regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with adaptive size\n    if n > 3:\n        max_segment_size = min(10, n // 2)\n        segment_size = np.random.randint(2, max_segment_size + 1)\n        start = np.random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Step 2: Multi-objective aware edge swap with path relinking\n    if n > 4:\n        # Select two non-adjacent segments\n        split1 = np.random.randint(1, n-2)\n        split2 = np.random.randint(split1+1, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = (distance_matrix_1[new_solution[split1-1], new_solution[split1]] +\n                          distance_matrix_1[new_solution[split2-1], new_solution[split2]])\n        original_cost2 = (distance_matrix_2[new_solution[split1-1], new_solution[split1]] +\n                          distance_matrix_2[new_solution[split2-1], new_solution[split2]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[split1-1], new_solution[split2-1]] +\n                     distance_matrix_1[new_solution[split1], new_solution[split2]])\n        new_cost2 = (distance_matrix_2[new_solution[split1-1], new_solution[split2-1]] +\n                     distance_matrix_2[new_solution[split1], new_solution[split2]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Perform path relinking between the swapped segments\n            new_solution[split1:split2] = new_solution[split1:split2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8055596319536807,
            2.959190845489502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with adaptive size\n    if n > 3:\n        max_segment_size = min(10, n // 2)\n        segment_size = np.random.randint(2, max_segment_size + 1)\n        start = np.random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Step 2: Multi-objective aware edge swap with path relinking\n    if n > 4:\n        # Select two non-adjacent segments\n        split1 = np.random.randint(1, n-2)\n        split2 = np.random.randint(split1+1, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = (distance_matrix_1[new_solution[split1-1], new_solution[split1]] +\n                          distance_matrix_1[new_solution[split2-1], new_solution[split2]])\n        original_cost2 = (distance_matrix_2[new_solution[split1-1], new_solution[split1]] +\n                          distance_matrix_2[new_solution[split2-1], new_solution[split2]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[split1-1], new_solution[split2-1]] +\n                     distance_matrix_1[new_solution[split1], new_solution[split2]])\n        new_cost2 = (distance_matrix_2[new_solution[split1-1], new_solution[split2-1]] +\n                     distance_matrix_2[new_solution[split1], new_solution[split2]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Perform path relinking between the swapped segments\n            new_solution[split1:split2] = new_solution[split1:split2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{An adaptive segment-based local search algorithm that dynamically identifies and optimizes promising tour segments by combining multi-objective edge potential analysis with a novel segment relocation strategy that preserves feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for Pareto improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate multi-objective edge potential scores\n    def edge_potential(i, j):\n        # Combine distance improvements in both objectives\n        current_dist = distance_matrix_1[i,j] + distance_matrix_2[i,j]\n        potential_dist = distance_matrix_1[i,new_solution[(j+1)%n]] + distance_matrix_2[i,new_solution[(j+1)%n]]\n        return current_dist - potential_dist\n\n    # Identify segments with high potential\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            score = edge_potential(new_solution[i], new_solution[j])\n            segment_scores.append((score, i, j))\n\n    if not segment_scores:\n        return new_solution\n\n    # Sort segments by potential and select top 5\n    segment_scores.sort(reverse=True, key=lambda x: x[0])\n    selected_segments = segment_scores[:5]\n\n    # Apply adaptive segment relocation\n    for score, i, j in selected_segments:\n        segment = new_solution[i:j+1]\n        # Try different insertion points\n        for _ in range(3):\n            insert_pos = np.random.randint(0, n)\n            if insert_pos >= i and insert_pos <= j:\n                continue\n\n            temp_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n\n            # Probabilistic repair if invalid\n            if len(np.unique(temp_solution)) != n:\n                # Randomly swap two nodes to fix duplicates\n                dup_pos = np.where(np.bincount(temp_solution) > 1)[0]\n                if len(dup_pos) > 0:\n                    swap_pos = np.random.choice(np.where(temp_solution == dup_pos[0])[0], 2, replace=False)\n                    temp_solution[swap_pos[0]], temp_solution[swap_pos[1]] = temp_solution[swap_pos[1]], temp_solution[swap_pos[0]]\n\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9437374335035765,
            3.7571102380752563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for Pareto improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate multi-objective edge potential scores\n    def edge_potential(i, j):\n        # Combine distance improvements in both objectives\n        current_dist = distance_matrix_1[i,j] + distance_matrix_2[i,j]\n        potential_dist = distance_matrix_1[i,new_solution[(j+1)%n]] + distance_matrix_2[i,new_solution[(j+1)%n]]\n        return current_dist - potential_dist\n\n    # Identify segments with high potential\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            score = edge_potential(new_solution[i], new_solution[j])\n            segment_scores.append((score, i, j))\n\n    if not segment_scores:\n        return new_solution\n\n    # Sort segments by potential and select top 5\n    segment_scores.sort(reverse=True, key=lambda x: x[0])\n    selected_segments = segment_scores[:5]\n\n    # Apply adaptive segment relocation\n    for score, i, j in selected_segments:\n        segment = new_solution[i:j+1]\n        # Try different insertion points\n        for _ in range(3):\n            insert_pos = np.random.randint(0, n)\n            if insert_pos >= i and insert_pos <= j:\n                continue\n\n            temp_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n\n            # Probabilistic repair if invalid\n            if len(np.unique(temp_solution)) != n:\n                # Randomly swap two nodes to fix duplicates\n                dup_pos = np.where(np.bincount(temp_solution) > 1)[0]\n                if len(dup_pos) > 0:\n                    swap_pos = np.random.choice(np.where(temp_solution == dup_pos[0])[0], 2, replace=False)\n                    temp_solution[swap_pos[0]], temp_solution[swap_pos[1]] = temp_solution[swap_pos[1]], temp_solution[swap_pos[0]]\n\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm uses a novel hybrid approach combining randomized segment reversal and a multi-objective-aware edge swap, with a focus on solutions with high crowding distance or Pareto dominance, to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal with objective-aware selection\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost change for both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = reversed_segment\n\n    # Step 2: Multi-objective aware edge swap with probabilistic acceptance\n    if n > 4:\n        i = np.random.randint(1, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Probabilistic acceptance based on improvement in both objectives\n        if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or \\\n           (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7244584011786459,
            3.0914434790611267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal with objective-aware selection\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Calculate cost change for both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = reversed_segment\n\n    # Step 2: Multi-objective aware edge swap with probabilistic acceptance\n    if n > 4:\n        i = np.random.randint(1, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Probabilistic acceptance based on improvement in both objectives\n        if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or \\\n           (np.random.random() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment reversal with a multi-objective edge insertion, favoring solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while abs(i - j) <= 1:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            if i < j:\n                new_solution[i+1:j+1] = new_solution[i:j]\n            else:\n                new_solution[j:i] = new_solution[j+1:i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.7045589977907099,
            1.5142610669136047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while abs(i - j) <= 1:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            if i < j:\n                new_solution[i+1:j+1] = new_solution[i:j]\n            else:\n                new_solution[j:i] = new_solution[j+1:i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{An adaptive local search operator that combines a multi-objective guided segment relocation with a probabilistic edge insertion, leveraging both Pareto dominance and crowding distance to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective guided segment relocation\n    if n > 3:\n        # Select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion position that improves at least one objective\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.insert(new_solution, pos, segment)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Check if this position improves at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Probabilistic edge insertion\n    if n > 2:\n        # Select two random edges to potentially insert\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Probabilistically accept insertion if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Create new edges\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    return new_solution\n\n",
        "score": [
            -0.8256220589419033,
            9.876444578170776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective guided segment relocation\n    if n > 3:\n        # Select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion position that improves at least one objective\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.insert(new_solution, pos, segment)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(1, len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(1, len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Check if this position improves at least one objective\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Probabilistic edge insertion\n    if n > 2:\n        # Select two random edges to potentially insert\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Probabilistically accept insertion if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                # Create new edges\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware path relinking with a dynamic edge reversal operator, using a fitness-based selection to prioritize solutions with balanced objective improvements while ensuring feasibility through a constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    fitness = 1 / (1 + np.abs(normalized[:, 0] - normalized[:, 1]))\n    selected_idx = np.argmax(fitness)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: path relinking with dynamic edge reversal\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Path relinking: swap segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n\n        # Dynamic edge reversal\n        for i in range(n):\n            if np.random.rand() < 0.3:  # 30% chance to reverse edge\n                j = np.random.randint(0, n-1)\n                new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7245861392386541,
            2.715919554233551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective improvements\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    fitness = 1 / (1 + np.abs(normalized[:, 0] - normalized[:, 1]))\n    selected_idx = np.argmax(fitness)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: path relinking with dynamic edge reversal\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Path relinking: swap segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1])\n\n        # Dynamic edge reversal\n        for i in range(n):\n            if np.random.rand() < 0.3:  # 30% chance to reverse edge\n                j = np.random.randint(0, n-1)\n                new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This novel hybrid local search algorithm combines multi-objective edge swapping with adaptive segment reversal, dynamically prioritizing edges based on their potential for both objective improvements while ensuring feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = objectives.max(axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(objectives)):\n        dominated = (objectives <= objectives[i]).all(axis=1)\n        if dominated.sum() == 1:  # Only dominates itself\n            contribution = (ref_point[0] - objectives[i][0]) * (ref_point[1] - objectives[i][1])\n            hv_contributions.append(contribution)\n        else:\n            hv_contributions.append(0)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with multi-objective edge swapping\n    for _ in range(5):\n        # Select segment to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n        if reversed_cost < original_cost:\n            # Reverse the segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge swap with probabilistic acceptance\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        if np.random.random() < 0.3:  # 30% chance to swap edges\n            # Calculate potential improvement\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if swapped_cost < original_cost:\n                # Perform edge swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9056510825865686,
            5.748261272907257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = objectives.max(axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(objectives)):\n        dominated = (objectives <= objectives[i]).all(axis=1)\n        if dominated.sum() == 1:  # Only dominates itself\n            contribution = (ref_point[0] - objectives[i][0]) * (ref_point[1] - objectives[i][1])\n            hv_contributions.append(contribution)\n        else:\n            hv_contributions.append(0)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with multi-objective edge swapping\n    for _ in range(5):\n        # Select segment to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        original_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n        if reversed_cost < original_cost:\n            # Reverse the segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Edge swap with probabilistic acceptance\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        if np.random.random() < 0.3:  # 30% chance to swap edges\n            # Calculate potential improvement\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if swapped_cost < original_cost:\n                # Perform edge swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel multi-objective local search operator that combines a randomized k-opt move with a dominance-based edge insertion, prioritizing solutions with high crowding distance to explore less crowded regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = []\n    for sol, obj in archive:\n        # Calculate crowding distance (simplified)\n        cd = (obj[0] + obj[1]) / 2  # Placeholder for actual crowding distance calculation\n        crowding_distances.append(cd)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized k-opt move + dominance-based edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-opt move (k=3)\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n        new_solution[i:j+1] = new_segment\n\n    # Step 2: Dominance-based edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            # Calculate original and new costs\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Insert edge (i,j) and remove (i-1,i) and (j-1,j)\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:i], temp_solution[j:j+1], temp_solution[i:j], temp_solution[j+1:]])\n\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n\n            # Accept if it dominates or improves at least one objective\n            if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8284559925127957,
            2.012410342693329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = []\n    for sol, obj in archive:\n        # Calculate crowding distance (simplified)\n        cd = (obj[0] + obj[1]) / 2  # Placeholder for actual crowding distance calculation\n        crowding_distances.append(cd)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized k-opt move + dominance-based edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-opt move (k=3)\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[i:j+1]\n        new_segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n        new_solution[i:j+1] = new_segment\n\n    # Step 2: Dominance-based edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j:\n            # Calculate original and new costs\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Insert edge (i,j) and remove (i-1,i) and (j-1,j)\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:i], temp_solution[j:j+1], temp_solution[i:j], temp_solution[j+1:]])\n\n            new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n            new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n\n            # Accept if it dominates or improves at least one objective\n            if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node reinsertion with a guided edge reversal, prioritizing solutions with high crowding distance or Pareto dominance while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node reinsertion\n    for _ in range(3):\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Calculate potential positions for reinsertion\n        candidates = []\n        for j in range(n):\n            if j != i and j != i-1:\n                # Temporarily insert node at position j\n                temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                temp_sol = np.insert(temp_sol, j, node)\n\n                # Calculate cost change\n                cost1 = distance_matrix_1[temp_sol[j-1], node] + distance_matrix_1[node, temp_sol[(j+1)%n]]\n                cost2 = distance_matrix_2[temp_sol[j-1], node] + distance_matrix_2[node, temp_sol[(j+1)%n]]\n                candidates.append((j, cost1, cost2))\n\n        # Select best candidate that improves at least one objective\n        best_j = None\n        for j, cost1, cost2 in candidates:\n            original_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[(i+1)%n]]\n            if (cost1 < original_cost1) or (cost2 < original_cost2):\n                if best_j is None or (cost1 + cost2) < (original_cost1 + original_cost2):\n                    best_j = j\n\n        if best_j is not None:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, best_j, node)\n\n    # Step 2: Guided edge reversal\n    for _ in range(2):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Reverse segment between i and j\n        temp_sol = new_solution.copy()\n        temp_sol[i:j] = temp_sol[i:j][::-1]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_1[temp_sol[j-1], temp_sol[j]]\n        new_cost2 = distance_matrix_2[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[j-1], temp_sol[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = temp_sol\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0142034845832066,
            12.309917032718658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node reinsertion\n    for _ in range(3):\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n\n        # Calculate potential positions for reinsertion\n        candidates = []\n        for j in range(n):\n            if j != i and j != i-1:\n                # Temporarily insert node at position j\n                temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                temp_sol = np.insert(temp_sol, j, node)\n\n                # Calculate cost change\n                cost1 = distance_matrix_1[temp_sol[j-1], node] + distance_matrix_1[node, temp_sol[(j+1)%n]]\n                cost2 = distance_matrix_2[temp_sol[j-1], node] + distance_matrix_2[node, temp_sol[(j+1)%n]]\n                candidates.append((j, cost1, cost2))\n\n        # Select best candidate that improves at least one objective\n        best_j = None\n        for j, cost1, cost2 in candidates:\n            original_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[(i+1)%n]]\n            if (cost1 < original_cost1) or (cost2 < original_cost2):\n                if best_j is None or (cost1 + cost2) < (original_cost1 + original_cost2):\n                    best_j = j\n\n        if best_j is not None:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, best_j, node)\n\n    # Step 2: Guided edge reversal\n    for _ in range(2):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Reverse segment between i and j\n        temp_sol = new_solution.copy()\n        temp_sol[i:j] = temp_sol[i:j][::-1]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[temp_sol[i-1], temp_sol[i]] + distance_matrix_1[temp_sol[j-1], temp_sol[j]]\n        new_cost2 = distance_matrix_2[temp_sol[i-1], temp_sol[i]] + distance_matrix_2[temp_sol[j-1], temp_sol[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = temp_sol\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The new algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with high crowding distance for exploration of less crowded regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes the maximum of the two objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            max_cost = max(cost1, cost2)\n\n            if max_cost < best_cost:\n                best_cost = max_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.792737393254156,
            9.502610206604004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes the maximum of the two objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            max_cost = max(cost1, cost2)\n\n            if max_cost < best_cost:\n                best_cost = max_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swapping with multi-objective-aware segment inversions, dynamically prioritizing high-potential edges while using a constraint-preserving validation mechanism to maintain solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for trade-off improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swapping with segment inversion\n    for _ in range(5):\n        # Select edges based on multi-objective potential\n        i, j = np.random.choice(n, size=2, replace=False)\n        a, b = (i, j) if np.random.rand() < 0.5 else (j, i)\n\n        # Perform edge swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Randomly invert a segment\n        if np.random.rand() < 0.3:\n            start, end = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Constraint-preserving repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, n)\n            while new_solution[insert_pos] in missing:\n                insert_pos = (insert_pos + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9716012003981567,
            2.0768417716026306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for trade-off improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swapping with segment inversion\n    for _ in range(5):\n        # Select edges based on multi-objective potential\n        i, j = np.random.choice(n, size=2, replace=False)\n        a, b = (i, j) if np.random.rand() < 0.5 else (j, i)\n\n        # Perform edge swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Randomly invert a segment\n        if np.random.rand() < 0.3:\n            start, end = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Constraint-preserving repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, n)\n            while new_solution[insert_pos] in missing:\n                insert_pos = (insert_pos + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node reinsertion with a guided edge reversal, using a combination of dominance-based selection and adaptive segment manipulation to explore the solution space while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high dominance count (promising for improvement)\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node reinsertion with guided edge reversal\n    for _ in range(3):\n        # Select a node to reinsert\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost before insertion\n            old_cost1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                         distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]])\n            old_cost2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                         distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]])\n\n            # Calculate cost after insertion\n            if pos == 0:\n                new_cost1 = (distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]])\n                new_cost2 = (distance_matrix_2[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]])\n            else:\n                new_cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                             distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]])\n                new_cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                             distance_matrix_2[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]])\n\n            # Weighted cost considering both objectives\n            weighted_cost = 0.5 * (new_cost1 - old_cost1) + 0.5 * (new_cost2 - old_cost2)\n\n            if weighted_cost < best_cost:\n                best_cost = weighted_cost\n                best_pos = pos\n\n        # Perform reinsertion\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Guided edge reversal\n        if n > 2:\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            segment = new_solution[a:b+1]\n\n            # Calculate cost before reversal\n            cost1_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            cost2_before = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            # Calculate cost after reversal\n            cost1_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            cost2_after = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            # Accept reversal if it improves at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[a:b+1] = segment[::-1]\n\n    # Validate solution (repair if needed)\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7443049756325543,
            4.9160380363464355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high dominance count (promising for improvement)\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node reinsertion with guided edge reversal\n    for _ in range(3):\n        # Select a node to reinsert\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost before insertion\n            old_cost1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                         distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]])\n            old_cost2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                         distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]])\n\n            # Calculate cost after insertion\n            if pos == 0:\n                new_cost1 = (distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]])\n                new_cost2 = (distance_matrix_2[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]])\n            else:\n                new_cost1 = (distance_matrix_1[new_solution[pos-1], node] +\n                             distance_matrix_1[node, new_solution[pos]] +\n                             distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]])\n                new_cost2 = (distance_matrix_2[new_solution[pos-1], node] +\n                             distance_matrix_2[node, new_solution[pos]] +\n                             distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]])\n\n            # Weighted cost considering both objectives\n            weighted_cost = 0.5 * (new_cost1 - old_cost1) + 0.5 * (new_cost2 - old_cost2)\n\n            if weighted_cost < best_cost:\n                best_cost = weighted_cost\n                best_pos = pos\n\n        # Perform reinsertion\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Guided edge reversal\n        if n > 2:\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            segment = new_solution[a:b+1]\n\n            # Calculate cost before reversal\n            cost1_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            cost2_before = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            # Calculate cost after reversal\n            cost1_after = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n            cost2_after = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            # Accept reversal if it improves at least one objective\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[a:b+1] = segment[::-1]\n\n    # Validate solution (repair if needed)\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This novel hybrid local search operator combines a multi-objective-aware node insertion with a guided segment reordering, prioritizing solutions with high potential for improvement in both objectives while maintaining feasibility through a dynamic validation and repair mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective-aware node insertion\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find insertion position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = node_idx\n        for pos in range(n):\n            if pos == node_idx:\n                continue\n\n            # Calculate cost before and after insertion\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[1]\n            elif pos == n-1:\n                prev_node = new_solution[-2]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos+1]\n\n            # Original cost (excluding the node)\n            original_cost1 = distance_matrix_1[prev_node, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_node]\n            original_cost2 = distance_matrix_2[prev_node, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_node]\n\n            # New cost (with node inserted)\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_node]\n\n            # Total change in both objectives\n            total_change = new_cost1 + new_cost2 - original_cost1 - original_cost2\n\n            if total_change < min_cost:\n                min_cost = total_change\n                best_pos = pos\n\n        # Perform the insertion\n        if best_pos != node_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            if node_idx < best_pos:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Guided segment reordering\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate current cost of the segment\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try reversing the segment\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if it improves at least one objective\n        if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n            new_solution[a:b] = reversed_segment\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9282829144034971,
            4.05355966091156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective-aware node insertion\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find insertion position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = node_idx\n        for pos in range(n):\n            if pos == node_idx:\n                continue\n\n            # Calculate cost before and after insertion\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[1]\n            elif pos == n-1:\n                prev_node = new_solution[-2]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos+1]\n\n            # Original cost (excluding the node)\n            original_cost1 = distance_matrix_1[prev_node, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_node]\n            original_cost2 = distance_matrix_2[prev_node, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_node]\n\n            # New cost (with node inserted)\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_node]\n\n            # Total change in both objectives\n            total_change = new_cost1 + new_cost2 - original_cost1 - original_cost2\n\n            if total_change < min_cost:\n                min_cost = total_change\n                best_pos = pos\n\n        # Perform the insertion\n        if best_pos != node_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            if node_idx < best_pos:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Guided segment reordering\n    if n > 3:\n        # Select a random segment\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate current cost of the segment\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Try reversing the segment\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        # Accept if it improves at least one objective\n        if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n            new_solution[a:b] = reversed_segment\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A novel hybrid local search operator that combines a randomized 3-opt with a Pareto-dominance guided edge insertion, prioritizing solutions with high crowding distance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.random.choice(np.argsort(crowding_distances)[-max(1, len(crowding_distances)//2):])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 3-opt\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Step 2: Pareto-dominance guided edge insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(j+1)%n], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(j+1)%n], new_solution[(i+1)%n]]\n\n            # Accept insertion if it dominates or is non-dominated but better in at least one objective\n            if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n               (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8478755246769853,
            1.5822076201438904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.random.choice(np.argsort(crowding_distances)[-max(1, len(crowding_distances)//2):])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 3-opt\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Step 2: Pareto-dominance guided edge insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        if i != j and abs(i-j) > 1:\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(j+1)%n], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(j+1)%n], new_solution[(i+1)%n]]\n\n            # Accept insertion if it dominates or is non-dominated but better in at least one objective\n            if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n               (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment reversal with multi-objective aware node insertion, prioritizing solutions with high crowding distance while dynamically adjusting the search intensity based on the trade-off between exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_length = min(5, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware node insertion\n    if n > 4:\n        for _ in range(3):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n\n            if i == j:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            # Accept if dominates in at least one objective\n            if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = (i + 1) % n\n                new_solution = np.insert(new_solution, insert_pos, node)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.5532484768756822,
            1.731078028678894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_length = min(5, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware node insertion\n    if n > 4:\n        for _ in range(3):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n\n            if i == j:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n            # Accept if dominates in at least one objective\n            if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = (i + 1) % n\n                new_solution = np.insert(new_solution, insert_pos, node)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The backbone idea of the provided algorithms is a hybrid local search combining randomized segment inversion with multi-objective aware edge swaps, prioritizing solutions with high crowding distance or Pareto dominance. Our new algorithm will use a multi-objective guided path relinking strategy that selectively transfers high-quality segments between elite solutions while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two elite solutions based on crowding distance and Pareto dominance\n    crowding_distances = [np.random.random() for _ in archive]  # Placeholder for actual crowding distance calculation\n    selected_indices = np.random.choice(len(archive), size=2, replace=False, p=np.array(crowding_distances)/sum(crowding_distances))\n    solution1, solution2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Multi-objective guided path relinking\n    new_solution = np.zeros_like(solution1)\n    n = len(solution1)\n    start_pos = np.random.randint(0, n)\n\n    # Transfer segments between solutions\n    for i in range(n):\n        pos = (start_pos + i) % n\n        if np.random.random() < 0.7:  # Higher probability to keep original segment\n            new_solution[pos] = solution1[pos]\n        else:\n            # Select from solution2 but ensure no duplicates\n            candidate = solution2[pos]\n            if candidate not in new_solution[:pos]:\n                new_solution[pos] = candidate\n            else:\n                # Find first available node not in current solution\n                for node in solution2:\n                    if node not in new_solution:\n                        new_solution[pos] = node\n                        break\n\n    # Local refinement: selective edge optimization\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9957993477880157,
            0.9273908734321594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two elite solutions based on crowding distance and Pareto dominance\n    crowding_distances = [np.random.random() for _ in archive]  # Placeholder for actual crowding distance calculation\n    selected_indices = np.random.choice(len(archive), size=2, replace=False, p=np.array(crowding_distances)/sum(crowding_distances))\n    solution1, solution2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Multi-objective guided path relinking\n    new_solution = np.zeros_like(solution1)\n    n = len(solution1)\n    start_pos = np.random.randint(0, n)\n\n    # Transfer segments between solutions\n    for i in range(n):\n        pos = (start_pos + i) % n\n        if np.random.random() < 0.7:  # Higher probability to keep original segment\n            new_solution[pos] = solution1[pos]\n        else:\n            # Select from solution2 but ensure no duplicates\n            candidate = solution2[pos]\n            if candidate not in new_solution[:pos]:\n                new_solution[pos] = candidate\n            else:\n                # Find first available node not in current solution\n                for node in solution2:\n                    if node not in new_solution:\n                        new_solution[pos] = node\n                        break\n\n    # Local refinement: selective edge optimization\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{The backbone idea of the provided algorithms is a hybrid local search combining randomized segment inversion with multi-objective aware edge swaps, prioritizing solutions with high crowding distance or Pareto dominance. Our new algorithm will use a multi-objective guided path relinking strategy that selectively transfers high-quality segments between elite solutions while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two elite solutions based on crowding distance and Pareto dominance\n    crowding_distances = [np.random.random() for _ in archive]  # Placeholder for actual crowding distance calculation\n    selected_indices = np.random.choice(len(archive), size=2, replace=False, p=np.array(crowding_distances)/sum(crowding_distances))\n    solution1, solution2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Multi-objective guided path relinking\n    new_solution = np.zeros_like(solution1)\n    n = len(solution1)\n    start_pos = np.random.randint(0, n)\n\n    # Transfer segments between solutions\n    for i in range(n):\n        pos = (start_pos + i) % n\n        if np.random.random() < 0.7:  # Higher probability to keep original segment\n            new_solution[pos] = solution1[pos]\n        else:\n            # Select from solution2 but ensure no duplicates\n            candidate = solution2[pos]\n            if candidate not in new_solution[:pos]:\n                new_solution[pos] = candidate\n            else:\n                # Find first available node not in current solution\n                for node in solution2:\n                    if node not in new_solution:\n                        new_solution[pos] = node\n                        break\n\n    # Local refinement: selective edge optimization\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9957993477880157,
            0.9273908734321594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two elite solutions based on crowding distance and Pareto dominance\n    crowding_distances = [np.random.random() for _ in archive]  # Placeholder for actual crowding distance calculation\n    selected_indices = np.random.choice(len(archive), size=2, replace=False, p=np.array(crowding_distances)/sum(crowding_distances))\n    solution1, solution2 = archive[selected_indices[0]][0], archive[selected_indices[1]][0]\n\n    # Multi-objective guided path relinking\n    new_solution = np.zeros_like(solution1)\n    n = len(solution1)\n    start_pos = np.random.randint(0, n)\n\n    # Transfer segments between solutions\n    for i in range(n):\n        pos = (start_pos + i) % n\n        if np.random.random() < 0.7:  # Higher probability to keep original segment\n            new_solution[pos] = solution1[pos]\n        else:\n            # Select from solution2 but ensure no duplicates\n            candidate = solution2[pos]\n            if candidate not in new_solution[:pos]:\n                new_solution[pos] = candidate\n            else:\n                # Find first available node not in current solution\n                for node in solution2:\n                    if node not in new_solution:\n                        new_solution[pos] = node\n                        break\n\n    # Local refinement: selective edge optimization\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node relocation with a dynamic edge reversal, prioritizing solutions with high crowding distance while ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0] + objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos - 1) % n:\n                continue\n\n            # Calculate cost before relocation\n            prev_node = new_solution[node_pos - 1]\n            next_node = new_solution[(node_pos + 1) % n]\n            original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate cost after relocation\n            prev_new = new_solution[pos - 1]\n            next_new = new_solution[pos]\n            new_cost1 = distance_matrix_1[prev_new, node] + distance_matrix_1[node, next_new]\n            new_cost2 = distance_matrix_2[prev_new, node] + distance_matrix_2[node, next_new]\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if b - a > 1:\n            # Reverse the segment between a and b\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6755259968731955,
            2.234039545059204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0] + objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos - 1) % n:\n                continue\n\n            # Calculate cost before relocation\n            prev_node = new_solution[node_pos - 1]\n            next_node = new_solution[(node_pos + 1) % n]\n            original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate cost after relocation\n            prev_new = new_solution[pos - 1]\n            next_new = new_solution[pos]\n            new_cost1 = distance_matrix_1[prev_new, node] + distance_matrix_1[node, next_new]\n            new_cost2 = distance_matrix_2[prev_new, node] + distance_matrix_2[node, next_new]\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if b - a > 1:\n            # Reverse the segment between a and b\n            new_solution[a+1:b] = new_solution[a+1:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9302450689939747,
            1.4169285297393799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{A novel hybrid local search operator that combines a randomized 2-opt with a multi-objective aware node insertion, prioritizing solutions with lower cost in both objectives while introducing controlled randomness to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower cost in both objectives\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    scores = np.sum(normalized_costs, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 2-opt + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 2-opt\n    if n > 3:\n        a, b = sorted(np.random.choice(n-1, size=2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[b:] = new_solution[b:][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5847874117754246,
            1.6316302418708801
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower cost in both objectives\n    costs = np.array([obj for _, obj in archive])\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    scores = np.sum(normalized_costs, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized 2-opt + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 2-opt\n    if n > 3:\n        a, b = sorted(np.random.choice(n-1, size=2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[b:] = new_solution[b:][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel adaptive local search operator that combines a dynamic segment reversal with a Pareto-optimality guided edge insertion, leveraging both solution quality and diversity metrics to explore promising regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment reversal\n    if n > 3:\n        segment_size = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Step 2: Pareto-optimality guided edge insertion\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j+1]] + distance_matrix_1[new_solution[i+1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j]]\n\n        # Accept insertion if it dominates or improves at least one objective\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.7725317698105691,
            2.0588881969451904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment reversal\n    if n > 3:\n        segment_size = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Step 2: Pareto-optimality guided edge insertion\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j+1]] + distance_matrix_1[new_solution[i+1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j]]\n\n        # Accept insertion if it dominates or improves at least one objective\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware segment reversal, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.788638233505123,
            2.2926284670829773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node relocation with a multi-objective aware 3-opt move, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        # Calculate cost before 3-opt\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n        # Calculate cost after 3-opt\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[c-1]] + distance_matrix_1[new_solution[b], new_solution[c]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[c-1]] + distance_matrix_2[new_solution[b], new_solution[c]]\n\n        # Accept 3-opt if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8563496012146227,
            2.447997033596039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        # Calculate cost before 3-opt\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n\n        # Calculate cost after 3-opt\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[c-1]] + distance_matrix_1[new_solution[b], new_solution[c]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[c-1]] + distance_matrix_2[new_solution[b], new_solution[c]]\n\n        # Accept 3-opt if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective aware node insertion, prioritizing solutions with high crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            temp_solution = np.insert(new_solution, pos, node)\n            if pos == 0:\n                cost1 = distance_matrix_1[temp_solution[-1], node] + distance_matrix_1[node, temp_solution[1]]\n                cost2 = distance_matrix_2[temp_solution[-1], node] + distance_matrix_2[node, temp_solution[1]]\n            elif pos == len(temp_solution) - 1:\n                cost1 = distance_matrix_1[temp_solution[-2], node] + distance_matrix_1[node, temp_solution[0]]\n                cost2 = distance_matrix_2[temp_solution[-2], node] + distance_matrix_2[node, temp_solution[0]]\n            else:\n                cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[pos+1]]\n                cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[pos+1]]\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8262448089568666,
            4.219742059707642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            temp_solution = np.insert(new_solution, pos, node)\n            if pos == 0:\n                cost1 = distance_matrix_1[temp_solution[-1], node] + distance_matrix_1[node, temp_solution[1]]\n                cost2 = distance_matrix_2[temp_solution[-1], node] + distance_matrix_2[node, temp_solution[1]]\n            elif pos == len(temp_solution) - 1:\n                cost1 = distance_matrix_1[temp_solution[-2], node] + distance_matrix_1[node, temp_solution[0]]\n                cost2 = distance_matrix_2[temp_solution[-2], node] + distance_matrix_2[node, temp_solution[0]]\n            else:\n                cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[pos+1]]\n                cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[pos+1]]\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{A novel local search operator that combines a multi-objective aware segment relocation with a randomized edge reversal, favoring solutions with higher crowding distance or Pareto dominance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c = np.random.randint(0, n)\n        while c in range(a, b):\n            c = np.random.randint(0, n)\n\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8828368080729128,
            1.2801436185836792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c = np.random.randint(0, n)\n        while c in range(a, b):\n            c = np.random.randint(0, n)\n\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{An adaptive hybrid local search that combines multi-objective edge prioritization with dynamic segment shuffling, leveraging both distance matrices to identify and rearrange high-potential segments while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined edge potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax((objectives[:, 0] * objectives[:, 1]) / (objectives.sum(axis=1) + 1e-8))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge potentials using both distance matrices\n    edge_potentials = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        edge_potentials[i] = 1 / (distance_matrix_1[prev, curr] * distance_matrix_2[prev, curr] + 1e-8)\n\n    # Identify high-potential segments\n    sorted_indices = np.argsort(edge_potentials)[::-1]\n    segment_start = sorted_indices[0]\n    segment_end = segment_start + np.random.randint(2, min(5, n-segment_start))\n\n    # Dynamic segment shuffling\n    segment = new_solution[segment_start:segment_end]\n    np.random.shuffle(segment)\n    new_solution[segment_start:segment_end] = segment\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        for node in set(range(n)) - set(new_solution):\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = np.delete(new_solution, pos + (1 if pos < len(new_solution)-1 else -1))\n\n    return new_solution\n\n",
        "score": [
            -0.8095242788196246,
            1.9392669796943665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined edge potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax((objectives[:, 0] * objectives[:, 1]) / (objectives.sum(axis=1) + 1e-8))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge potentials using both distance matrices\n    edge_potentials = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        edge_potentials[i] = 1 / (distance_matrix_1[prev, curr] * distance_matrix_2[prev, curr] + 1e-8)\n\n    # Identify high-potential segments\n    sorted_indices = np.argsort(edge_potentials)[::-1]\n    segment_start = sorted_indices[0]\n    segment_end = segment_start + np.random.randint(2, min(5, n-segment_start))\n\n    # Dynamic segment shuffling\n    segment = new_solution[segment_start:segment_end]\n    np.random.shuffle(segment)\n    new_solution[segment_start:segment_end] = segment\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        for node in set(range(n)) - set(new_solution):\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = np.delete(new_solution, pos + (1 if pos < len(new_solution)-1 else -1))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel hybrid local search operator that combines multi-objective aware node clustering with guided edge reinsertion, prioritizing solutions with high crowding distance while ensuring feasibility through a dynamic segment merging and splitting mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node clustering\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate potential improvement if we split here\n        split_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] if i < n-1 else distance_matrix_1[new_solution[i-1], new_solution[i]]\n        split_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] if i < n-1 else distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        # Calculate potential improvement if we keep in same cluster\n        merge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] if i > 0 else 0\n        merge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] if i > 0 else 0\n\n        # Decide to split or merge based on multi-objective improvement\n        if (split_cost1 + split_cost2) > (merge_cost1 + merge_cost2 + 1e-8):\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n        else:\n            current_cluster.append(new_solution[i])\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Guided edge reinsertion\n    for _ in range(3):\n        # Select a random cluster and a random edge\n        cluster_idx = np.random.randint(len(clusters))\n        if len(clusters[cluster_idx]) < 2:\n            continue\n        edge_pos = np.random.randint(len(clusters[cluster_idx])-1)\n        node1, node2 = clusters[cluster_idx][edge_pos], clusters[cluster_idx][edge_pos+1]\n\n        # Find best insertion position in another cluster\n        best_pos = -1\n        best_improvement = 0\n        for i in range(len(clusters)):\n            if i == cluster_idx:\n                continue\n            for j in range(len(clusters[i])):\n                # Calculate potential improvement\n                original_cost1 = distance_matrix_1[clusters[i][j-1], clusters[i][j]] if j > 0 else 0\n                original_cost2 = distance_matrix_2[clusters[i][j-1], clusters[i][j]] if j > 0 else 0\n                new_cost1 = distance_matrix_1[clusters[i][j-1], node1] + distance_matrix_1[node2, clusters[i][j]] if j > 0 else distance_matrix_1[node2, clusters[i][j]]\n                new_cost2 = distance_matrix_2[clusters[i][j-1], node1] + distance_matrix_2[node2, clusters[i][j]] if j > 0 else distance_matrix_2[node2, clusters[i][j]]\n                improvement = (original_cost1 + original_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = (i, j)\n\n        # Perform the insertion if beneficial\n        if best_pos != -1 and best_improvement > 0:\n            i, j = best_pos\n            clusters[i].insert(j, node1)\n            clusters[i].insert(j+1, node2)\n            clusters[cluster_idx].pop(edge_pos+1)\n            clusters[cluster_idx].pop(edge_pos)\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8872916722020849,
            9.775043845176697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node clustering\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate potential improvement if we split here\n        split_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] if i < n-1 else distance_matrix_1[new_solution[i-1], new_solution[i]]\n        split_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] if i < n-1 else distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        # Calculate potential improvement if we keep in same cluster\n        merge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] if i > 0 else 0\n        merge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] if i > 0 else 0\n\n        # Decide to split or merge based on multi-objective improvement\n        if (split_cost1 + split_cost2) > (merge_cost1 + merge_cost2 + 1e-8):\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n        else:\n            current_cluster.append(new_solution[i])\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Guided edge reinsertion\n    for _ in range(3):\n        # Select a random cluster and a random edge\n        cluster_idx = np.random.randint(len(clusters))\n        if len(clusters[cluster_idx]) < 2:\n            continue\n        edge_pos = np.random.randint(len(clusters[cluster_idx])-1)\n        node1, node2 = clusters[cluster_idx][edge_pos], clusters[cluster_idx][edge_pos+1]\n\n        # Find best insertion position in another cluster\n        best_pos = -1\n        best_improvement = 0\n        for i in range(len(clusters)):\n            if i == cluster_idx:\n                continue\n            for j in range(len(clusters[i])):\n                # Calculate potential improvement\n                original_cost1 = distance_matrix_1[clusters[i][j-1], clusters[i][j]] if j > 0 else 0\n                original_cost2 = distance_matrix_2[clusters[i][j-1], clusters[i][j]] if j > 0 else 0\n                new_cost1 = distance_matrix_1[clusters[i][j-1], node1] + distance_matrix_1[node2, clusters[i][j]] if j > 0 else distance_matrix_1[node2, clusters[i][j]]\n                new_cost2 = distance_matrix_2[clusters[i][j-1], node1] + distance_matrix_2[node2, clusters[i][j]] if j > 0 else distance_matrix_2[node2, clusters[i][j]]\n                improvement = (original_cost1 + original_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = (i, j)\n\n        # Perform the insertion if beneficial\n        if best_pos != -1 and best_improvement > 0:\n            i, j = best_pos\n            clusters[i].insert(j, node1)\n            clusters[i].insert(j+1, node2)\n            clusters[cluster_idx].pop(edge_pos+1)\n            clusters[cluster_idx].pop(edge_pos)\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{The new algorithm combines a multi-objective aware segment relocation with a randomized edge insertion, prioritizing solutions with high crowding distance while ensuring feasibility by maintaining a valid tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = np.array([solution[1][0] + solution[1][1] for solution in archive])\n    selected_idx = np.random.choice(len(archive), p=crowding_distances/np.sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos < end:\n                continue\n\n            # Calculate cost before relocation\n            original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n            original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[end-1], new_solution[0]] + distance_matrix_1[new_solution[-1], new_solution[start]]\n                new_cost2 = distance_matrix_2[new_solution[end-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[start]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[pos]]\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_pos == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Randomized edge insertion\n    if n > 3:\n        node_to_insert = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_insert]\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            cost1 = distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[(pos+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[pos], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[(pos+1)%(n-1)]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos+1, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8282262288988702,
            3.381815552711487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = np.array([solution[1][0] + solution[1][1] for solution in archive])\n    selected_idx = np.random.choice(len(archive), p=crowding_distances/np.sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos < end:\n                continue\n\n            # Calculate cost before relocation\n            original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n            original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[end-1], new_solution[0]] + distance_matrix_1[new_solution[-1], new_solution[start]]\n                new_cost2 = distance_matrix_2[new_solution[end-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[start]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[pos]]\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            if best_pos == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_pos == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Randomized edge insertion\n    if n > 3:\n        node_to_insert = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_insert]\n\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            cost1 = distance_matrix_1[new_solution[pos], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[(pos+1)%(n-1)]]\n            cost2 = distance_matrix_2[new_solution[pos], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[(pos+1)%(n-1)]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos+1, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment reversals with multi-objective edge swapping, dynamically prioritizing critical edges based on their potential to improve both objectives while maintaining feasibility through a constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective edge swapping\n    for _ in range(3):\n        # Randomly select a segment to reverse\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-objective edge swapping\n        for i in range(n):\n            j = (i + 1) % n\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate potential improvement for both objectives\n            delta1 = distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[new_solution[(j+1)%n], node_j] - \\\n                    (distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_j, node_i] + distance_matrix_1[new_solution[(j+1)%n], node_j])\n            delta2 = distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[new_solution[(j+1)%n], node_j] - \\\n                    (distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_j, node_i] + distance_matrix_2[new_solution[(j+1)%n], node_j])\n\n            if (delta1 < 0 or delta2 < 0) and len(np.unique(new_solution)) == n:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8820850790408044,
            2.784104287624359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective edge swapping\n    for _ in range(3):\n        # Randomly select a segment to reverse\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-objective edge swapping\n        for i in range(n):\n            j = (i + 1) % n\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate potential improvement for both objectives\n            delta1 = distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[new_solution[(j+1)%n], node_j] - \\\n                    (distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_j, node_i] + distance_matrix_1[new_solution[(j+1)%n], node_j])\n            delta2 = distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[new_solution[(j+1)%n], node_j] - \\\n                    (distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_j, node_i] + distance_matrix_2[new_solution[(j+1)%n], node_j])\n\n            if (delta1 < 0 or delta2 < 0) and len(np.unique(new_solution)) == n:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, favoring solutions with high crowding distance or Pareto dominance to explore less crowded regions while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) == 1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion (move node at i to position j)\n        if i < j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        else:\n            new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[i-1]]\n            new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[i-1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8737976862140009,
            2.3136467933654785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while i == j or abs(i - j) == 1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion (move node at i to position j)\n        if i < j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        else:\n            new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[i-1]]\n            new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[i-1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block relocation with a multi-objective aware node insertion, leveraging both crowding distance and Pareto front ranking to guide the search toward diverse and high-quality solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        block_size = np.random.randint(2, min(4, n-1))\n        start = np.random.randint(0, n - block_size)\n        end = start + block_size\n        insert_pos = np.random.randint(0, n - block_size)\n\n        if insert_pos > start:\n            block = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:insert_pos], block, new_solution[insert_pos:]])\n        else:\n            block = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:start], new_solution[end:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n-1)\n        if i != j and i != (j+1) % n:\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept insertion if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, (j+1)%n, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8825075205731983,
            1.806122899055481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        block_size = np.random.randint(2, min(4, n-1))\n        start = np.random.randint(0, n - block_size)\n        end = start + block_size\n        insert_pos = np.random.randint(0, n - block_size)\n\n        if insert_pos > start:\n            block = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:insert_pos], block, new_solution[insert_pos:]])\n        else:\n            block = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:insert_pos], block, new_solution[insert_pos:start], new_solution[end:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n-1)\n        if i != j and i != (j+1) % n:\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept insertion if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, (j+1)%n, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while i == j:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8447612079121278,
            2.3248122930526733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while i == j:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment reversal with a multi-objective aware node insertion, prioritizing solutions with high crowding distance or Pareto dominance to guide the search toward diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3 and np.random.rand() < 0.5:\n        i = np.random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Check if insertion improves at least one objective\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[(pos+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[(pos+1)%n]]\n\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7683142967655016,
            2.0284101963043213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3 and np.random.rand() < 0.5:\n        i = np.random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        pos = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Check if insertion improves at least one objective\n        original_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[(pos+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[(pos+1)%n]]\n\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism, using a different scoring function for solution selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective product (diverse potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5906918454098318,
            0.8286817073822021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective product (diverse potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism, using a different scoring function for solution selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective product (diverse potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5906918454098318,
            0.8286817073822021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective product (diverse potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation with multi-objective aware edge replacement, where segments are rotated based on their potential for improving both objectives, while edge replacements prioritize nodes with the highest crowding distance in the Pareto front to ensure diversity and quality in the generated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding_distances[i] = float('inf')\n            continue\n\n        left = objectives[i-1]\n        right = objectives[i+1]\n        crowding_distances[i] = sum(abs(objectives[i][j] - left[j]) + abs(right[j] - objectives[i][j]) for j in range(2))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement for both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try rotating segment left\n        rotated_left = np.concatenate([segment[1:], segment[:1]])\n        temp_solution = np.concatenate([new_solution[:a], rotated_left, new_solution[b:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution = temp_solution\n            original_cost1, original_cost2 = new_cost1, new_cost2\n\n        # Try rotating segment right\n        rotated_right = np.concatenate([segment[-1:], segment[:-1]])\n        temp_solution = np.concatenate([new_solution[:a], rotated_right, new_solution[b:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution = temp_solution\n\n    # Multi-objective aware edge replacement\n    if n > 2:\n        # Find node with highest crowding distance in the current solution's objectives\n        solution_objectives = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev, current] + distance_matrix_1[current, next_node]\n            cost2 = distance_matrix_2[prev, current] + distance_matrix_2[current, next_node]\n            solution_objectives.append((cost1, cost2))\n\n        solution_objectives = np.array(solution_objectives)\n        node_crowding = np.zeros(n)\n\n        for i in range(n):\n            if i == 0 or i == n-1:\n                node_crowding[i] = float('inf')\n                continue\n\n            left = solution_objectives[i-1]\n            right = solution_objectives[i+1]\n            node_crowding[i] = sum(abs(solution_objectives[i][j] - left[j]) + abs(right[j] - solution_objectives[i][j]) for j in range(2))\n\n        target_node = np.argmax(node_crowding)\n\n        # Find replacement that improves at least one objective\n        candidates = list(range(n))\n        candidates.remove(new_solution[target_node])\n        np.random.shuffle(candidates)\n\n        for candidate in candidates[:5]:  # Try top 5 candidates\n            temp_solution = new_solution.copy()\n            temp_solution[target_node] = candidate\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6075626268929976,
            3.890915095806122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding_distances[i] = float('inf')\n            continue\n\n        left = objectives[i-1]\n        right = objectives[i+1]\n        crowding_distances[i] = sum(abs(objectives[i][j] - left[j]) + abs(right[j] - objectives[i][j]) for j in range(2))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement for both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try rotating segment left\n        rotated_left = np.concatenate([segment[1:], segment[:1]])\n        temp_solution = np.concatenate([new_solution[:a], rotated_left, new_solution[b:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution = temp_solution\n            original_cost1, original_cost2 = new_cost1, new_cost2\n\n        # Try rotating segment right\n        rotated_right = np.concatenate([segment[-1:], segment[:-1]])\n        temp_solution = np.concatenate([new_solution[:a], rotated_right, new_solution[b:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution = temp_solution\n\n    # Multi-objective aware edge replacement\n    if n > 2:\n        # Find node with highest crowding distance in the current solution's objectives\n        solution_objectives = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev, current] + distance_matrix_1[current, next_node]\n            cost2 = distance_matrix_2[prev, current] + distance_matrix_2[current, next_node]\n            solution_objectives.append((cost1, cost2))\n\n        solution_objectives = np.array(solution_objectives)\n        node_crowding = np.zeros(n)\n\n        for i in range(n):\n            if i == 0 or i == n-1:\n                node_crowding[i] = float('inf')\n                continue\n\n            left = solution_objectives[i-1]\n            right = solution_objectives[i+1]\n            node_crowding[i] = sum(abs(solution_objectives[i][j] - left[j]) + abs(right[j] - solution_objectives[i][j]) for j in range(2))\n\n        target_node = np.argmax(node_crowding)\n\n        # Find replacement that improves at least one objective\n        candidates = list(range(n))\n        candidates.remove(new_solution[target_node])\n        np.random.shuffle(candidates)\n\n        for candidate in candidates[:5]:  # Try top 5 candidates\n            temp_solution = new_solution.copy()\n            temp_solution[target_node] = candidate\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment rotation with a dynamic edge replacement mechanism, prioritizing edges that show potential for simultaneous improvement in both objectives while maintaining feasibility through a probabilistic validation scheme.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax((objectives[:, 0] + objectives[:, 1]) / (objectives[:, 0] * objectives[:, 1] + 1e-8))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware segment rotation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Calculate cost before rotation\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n        # Calculate cost after rotation\n        new_cost1 = distance_matrix_1[new_solution[a-1], rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_solution[b+1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_solution[b+1]]\n\n        # Accept rotation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = rotated_segment\n\n    # Dynamic edge replacement\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.5:\n            # Try replacing edge with better alternative\n            candidates = np.argsort(distance_matrix_1[new_solution[i]] + distance_matrix_2[new_solution[i]])[:3]\n            for candidate in candidates:\n                if candidate not in new_solution:\n                    new_solution[i] = candidate\n                    break\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # With 50% probability, repair by restoring order\n        if np.random.random() < 0.5:\n            missing = list(set(range(n)) - set(new_solution))\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4324408049356737,
            2.7069396376609802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax((objectives[:, 0] + objectives[:, 1]) / (objectives[:, 0] * objectives[:, 1] + 1e-8))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware segment rotation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n        # Calculate cost before rotation\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n        # Calculate cost after rotation\n        new_cost1 = distance_matrix_1[new_solution[a-1], rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], new_solution[b+1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], new_solution[b+1]]\n\n        # Accept rotation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b+1] = rotated_segment\n\n    # Dynamic edge replacement\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.5:\n            # Try replacing edge with better alternative\n            candidates = np.argsort(distance_matrix_1[new_solution[i]] + distance_matrix_2[new_solution[i]])[:3]\n            for candidate in candidates:\n                if candidate not in new_solution:\n                    new_solution[i] = candidate\n                    break\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # With 50% probability, repair by restoring order\n        if np.random.random() < 0.5:\n            missing = list(set(range(n)) - set(new_solution))\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node relocation with a dynamic segment crossover, prioritizing solutions with high hypervolume contribution while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.lexsort((objectives[:,1], objectives[:,0]))\n    selected_idx = ranks[-1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation\n    if n > 3:\n        # Select nodes with high potential for improvement\n        node_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            node_scores[i] = (distance_matrix_1[prev, i] + distance_matrix_1[i, next_node] +\n                            distance_matrix_2[prev, i] + distance_matrix_2[i, next_node])\n\n        worst_nodes = np.argsort(node_scores)[-2:]\n        a, b = worst_nodes\n\n        # Relocate nodes to better positions\n        for node in [a, b]:\n            best_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                    continue\n\n                # Calculate improvement\n                prev = new_solution[pos-1]\n                next_node = new_solution[pos]\n                current_cost = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev, node] + distance_matrix_2[node, next_node])\n                new_cost = (distance_matrix_1[prev, new_solution[node]] + distance_matrix_1[new_solution[node], next_node] +\n                          distance_matrix_2[prev, new_solution[node]] + distance_matrix_2[new_solution[node], next_node])\n                improvement = current_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Insert node at best position\n                node_val = new_solution[node]\n                new_solution = np.concatenate([new_solution[:best_pos], [node_val], new_solution[best_pos:node], new_solution[node+1:]])\n\n    # Dynamic segment crossover\n    if n > 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create two segments and combine them\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Combine segments with probabilistic validation\n        if np.random.rand() < 0.7:\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9697067185494429,
            2.1646226048469543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.lexsort((objectives[:,1], objectives[:,0]))\n    selected_idx = ranks[-1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation\n    if n > 3:\n        # Select nodes with high potential for improvement\n        node_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            node_scores[i] = (distance_matrix_1[prev, i] + distance_matrix_1[i, next_node] +\n                            distance_matrix_2[prev, i] + distance_matrix_2[i, next_node])\n\n        worst_nodes = np.argsort(node_scores)[-2:]\n        a, b = worst_nodes\n\n        # Relocate nodes to better positions\n        for node in [a, b]:\n            best_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node or pos == (node-1)%n or pos == (node+1)%n:\n                    continue\n\n                # Calculate improvement\n                prev = new_solution[pos-1]\n                next_node = new_solution[pos]\n                current_cost = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev, node] + distance_matrix_2[node, next_node])\n                new_cost = (distance_matrix_1[prev, new_solution[node]] + distance_matrix_1[new_solution[node], next_node] +\n                          distance_matrix_2[prev, new_solution[node]] + distance_matrix_2[new_solution[node], next_node])\n                improvement = current_cost - new_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Insert node at best position\n                node_val = new_solution[node]\n                new_solution = np.concatenate([new_solution[:best_pos], [node_val], new_solution[best_pos:node], new_solution[node+1:]])\n\n    # Dynamic segment crossover\n    if n > 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create two segments and combine them\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Combine segments with probabilistic validation\n        if np.random.rand() < 0.7:\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment inversions with multi-objective-aware edge swaps, dynamically prioritizing critical edges based on their potential for improvement in both objective spaces while ensuring feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment inversion with multi-objective edge swaps\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Invert segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-objective edge swap\n        if b - a > 1:\n            i = np.random.randint(a, b)\n            j = np.random.randint(a, b)\n            if i != j:\n                # Calculate potential improvement\n                old_edges = [(new_solution[i], new_solution[i+1]), (new_solution[j], new_solution[j+1])]\n                new_edges = [(new_solution[i], new_solution[j+1]), (new_solution[j], new_solution[i+1])]\n\n                old_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in old_edges)\n                new_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges)\n                old_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in old_edges)\n                new_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges)\n\n                # Accept if at least one objective improves\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8695125253720155,
            1.7609593272209167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment inversion with multi-objective edge swaps\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Invert segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-objective edge swap\n        if b - a > 1:\n            i = np.random.randint(a, b)\n            j = np.random.randint(a, b)\n            if i != j:\n                # Calculate potential improvement\n                old_edges = [(new_solution[i], new_solution[i+1]), (new_solution[j], new_solution[j+1])]\n                new_edges = [(new_solution[i], new_solution[j+1]), (new_solution[j], new_solution[i+1])]\n\n                old_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in old_edges)\n                new_cost1 = sum(distance_matrix_1[e[0], e[1]] for e in new_edges)\n                old_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in old_edges)\n                new_cost2 = sum(distance_matrix_2[e[0], e[1]] for e in new_edges)\n\n                # Accept if at least one objective improves\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i+1], new_solution[j+1] = new_solution[j+1], new_solution[i+1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0032585445016466,
            1.0063543915748596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This novel hybrid local search algorithm combines adaptive edge swaps with multi-objective-aware segment reversals, utilizing dynamic edge potential scoring to guide improvements while maintaining feasibility through a constraint-aware validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with multi-objective segment reversal\n    for _ in range(5):\n        # Calculate edge potential scores\n        edge_scores = []\n        for i in range(n):\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            # Score based on improvement potential in both objectives\n            score = (distance_matrix_1[current, new_solution[(i-1)%n]] + distance_matrix_1[next_node, new_solution[(i+2)%n]] -\n                    (distance_matrix_1[current, next_node] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+2)%n]])) / 2\n            score += (distance_matrix_2[current, new_solution[(i-1)%n]] + distance_matrix_2[next_node, new_solution[(i+2)%n]] -\n                     (distance_matrix_2[current, next_node] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+2)%n]])) / 2\n            edge_scores.append(score)\n\n        # Select edges with highest potential\n        top_edges = np.argsort(edge_scores)[-3:]\n\n        # Perform edge swap or segment reversal\n        if np.random.rand() < 0.7:\n            # Edge swap\n            i = np.random.choice(top_edges)\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal\n            i = np.random.choice(top_edges)\n            j = (i + np.random.randint(2, min(5, n//2))) % n\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9609890047287195,
            2.8728439807891846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with multi-objective segment reversal\n    for _ in range(5):\n        # Calculate edge potential scores\n        edge_scores = []\n        for i in range(n):\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            # Score based on improvement potential in both objectives\n            score = (distance_matrix_1[current, new_solution[(i-1)%n]] + distance_matrix_1[next_node, new_solution[(i+2)%n]] -\n                    (distance_matrix_1[current, next_node] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+2)%n]])) / 2\n            score += (distance_matrix_2[current, new_solution[(i-1)%n]] + distance_matrix_2[next_node, new_solution[(i+2)%n]] -\n                     (distance_matrix_2[current, next_node] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+2)%n]])) / 2\n            edge_scores.append(score)\n\n        # Select edges with highest potential\n        top_edges = np.argsort(edge_scores)[-3:]\n\n        # Perform edge swap or segment reversal\n        if np.random.rand() < 0.7:\n            # Edge swap\n            i = np.random.choice(top_edges)\n            j = (i + 1) % n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal\n            i = np.random.choice(top_edges)\n            j = (i + np.random.randint(2, min(5, n//2))) % n\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment shuffling with multi-objective edge reallocation, where segments are dynamically selected based on their potential for improving both objectives, while using a probabilistic acceptance criterion to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current total costs\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_total_cost(new_solution)\n\n    # Adaptive segment shuffling with multi-objective edge reallocation\n    for _ in range(3):\n        # Select segment based on potential improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for the segment\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length+1))\n\n        # Try different positions for the segment\n        best_pos = start\n        best_improvement = 0\n        for pos in range(start - segment_length, start + segment_length + 1):\n            if pos < 0 or pos + segment_length >= n or pos == start:\n                continue\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution[pos:pos+segment_length] = segment\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(pos, pos+segment_length+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(pos, pos+segment_length+1))\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Apply the best move with probability based on improvement\n        if best_improvement > 0 and np.random.random() < min(1.0, best_improvement / (current_cost1 + current_cost2)):\n            new_solution[best_pos:best_pos+segment_length] = segment\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8933085254811832,
            3.2256231904029846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate current total costs\n    def calculate_total_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_total_cost(new_solution)\n\n    # Adaptive segment shuffling with multi-objective edge reallocation\n    for _ in range(3):\n        # Select segment based on potential improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for the segment\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length+1))\n\n        # Try different positions for the segment\n        best_pos = start\n        best_improvement = 0\n        for pos in range(start - segment_length, start + segment_length + 1):\n            if pos < 0 or pos + segment_length >= n or pos == start:\n                continue\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution[pos:pos+segment_length] = segment\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(pos, pos+segment_length+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(pos, pos+segment_length+1))\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Apply the best move with probability based on improvement\n        if best_improvement > 0 and np.random.random() < min(1.0, best_improvement / (current_cost1 + current_cost2)):\n            new_solution[best_pos:best_pos+segment_length] = segment\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm combines a multi-objective aware edge swap with a dynamic segment inversion operator, using a hybrid selection criterion that balances objective improvement potential with structural diversity to explore the solution space efficiently while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and structural diversity\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = [len(np.unique(sol)) for sol in solutions]\n    combined_scores = normalized.sum(axis=1) + np.array(diversity_scores) * 0.2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware edge swap with segment inversion\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[b], new_solution[b-1]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[b], new_solution[b-1]])\n\n        if (delta1 < 0 or delta2 < 0) and np.random.random() < 0.7:  # Accept if improves at least one objective\n            # Perform edge swap\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n            # Optional segment inversion for additional exploration\n            if np.random.random() < 0.3:\n                c, d = np.random.choice(n, size=2, replace=False)\n                if c > d:\n                    c, d = d, c\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        if np.random.random() < 0.5:\n            # Repair by restoring missing nodes in random positions\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            # Revert to base solution if repair seems unlikely to help\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9415932692965217,
            4.432984828948975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and structural diversity\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = [len(np.unique(sol)) for sol in solutions]\n    combined_scores = normalized.sum(axis=1) + np.array(diversity_scores) * 0.2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware edge swap with segment inversion\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_1[new_solution[b], new_solution[b-1]])\n\n        delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                  distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                  distance_matrix_2[new_solution[b], new_solution[b-1]])\n\n        if (delta1 < 0 or delta2 < 0) and np.random.random() < 0.7:  # Accept if improves at least one objective\n            # Perform edge swap\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n            # Optional segment inversion for additional exploration\n            if np.random.random() < 0.3:\n                c, d = np.random.choice(n, size=2, replace=False)\n                if c > d:\n                    c, d = d, c\n                new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        if np.random.random() < 0.5:\n            # Repair by restoring missing nodes in random positions\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n        else:\n            # Revert to base solution if repair seems unlikely to help\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with adaptive length\n    if n > 3:\n        segment_length = max(2, min(5, np.random.randint(2, n//2)))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with dominance check\n    if n > 4:\n        i = np.random.randint(1, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept swap if it dominates or is non-dominated but better in at least one objective\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8663519743010619,
            1.3939258456230164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with adaptive length\n    if n > 3:\n        segment_length = max(2, min(5, np.random.randint(2, n//2)))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with dominance check\n    if n > 4:\n        i = np.random.randint(1, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept swap if it dominates or is non-dominated but better in at least one objective\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swaps with guided segment inversions, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    reference_point = objectives.max(axis=0) * 1.1\n    hypervolumes = np.prod(reference_point - objectives, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with guided segment inversion\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        candidates = []\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]]\n                cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]]\n                candidates.append((cost1 + cost2, i, j))\n\n        if not candidates:\n            break\n\n        _, a, b = min(candidates, key=lambda x: x[0])\n\n        # Perform edge swap and segment inversion\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7759690242217331,
            9.678303480148315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    reference_point = objectives.max(axis=0) * 1.1\n    hypervolumes = np.prod(reference_point - objectives, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with guided segment inversion\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        candidates = []\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]]\n                cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]]\n                candidates.append((cost1 + cost2, i, j))\n\n        if not candidates:\n            break\n\n        _, a, b = min(candidates, key=lambda x: x[0])\n\n        # Perform edge swap and segment inversion\n        if b - a > 1:\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a Pareto-dominance guided edge insertion, prioritizing solutions with high crowding distance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Pareto-dominance guided edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate original and new costs\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if Pareto-dominant or equally good\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6555638504392024,
            1.753572702407837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Pareto-dominance guided edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate original and new costs\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if Pareto-dominant or equally good\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective-aware node insertion, prioritizing solutions with high crowding distance or Pareto dominance while ensuring feasibility through a feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        segment_length = np.random.randint(1, min(4, n // 2))  # Random segment length (1-3 or up to half the tour)\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Calculate insertion points\n        possible_positions = [i for i in range(len(remaining) + 1) if i != start]\n\n        if possible_positions:\n            insert_pos = np.random.choice(possible_positions)\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        # Randomly select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion position that improves at least one objective\n        best_improvement = -1\n        best_pos = -1\n\n        for pos in range(n):\n            if pos == node_idx or pos == node_idx - 1 or pos == (node_idx + 1) % n:\n                continue  # Skip adjacent positions\n\n            # Calculate cost before insertion\n            if node_idx == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[node_idx - 1]\n            next_node = new_solution[(node_idx + 1) % n]\n\n            original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate cost after insertion\n            if pos == 0:\n                new_prev = new_solution[-1]\n            else:\n                new_prev = new_solution[pos - 1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            # Calculate improvement\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            # Accept if it improves at least one objective\n            if improvement1 > 0 or improvement2 > 0:\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n        # Perform the best insertion if found\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx + 1:]])\n\n            # Insert the node at the best position\n            if best_pos == len(new_solution):\n                new_solution = np.append(new_solution, node)\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9181079713444051,
            2.119092047214508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Initialize new solution\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        segment_length = np.random.randint(1, min(4, n // 2))  # Random segment length (1-3 or up to half the tour)\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start + segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Calculate insertion points\n        possible_positions = [i for i in range(len(remaining) + 1) if i != start]\n\n        if possible_positions:\n            insert_pos = np.random.choice(possible_positions)\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        # Randomly select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion position that improves at least one objective\n        best_improvement = -1\n        best_pos = -1\n\n        for pos in range(n):\n            if pos == node_idx or pos == node_idx - 1 or pos == (node_idx + 1) % n:\n                continue  # Skip adjacent positions\n\n            # Calculate cost before insertion\n            if node_idx == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[node_idx - 1]\n            next_node = new_solution[(node_idx + 1) % n]\n\n            original_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate cost after insertion\n            if pos == 0:\n                new_prev = new_solution[-1]\n            else:\n                new_prev = new_solution[pos - 1]\n            new_next = new_solution[pos]\n\n            new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n            new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n            # Calculate improvement\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            # Accept if it improves at least one objective\n            if improvement1 > 0 or improvement2 > 0:\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n        # Perform the best insertion if found\n        if best_pos != -1:\n            # Remove the node from its current position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx + 1:]])\n\n            # Insert the node at the best position\n            if best_pos == len(new_solution):\n                new_solution = np.append(new_solution, node)\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This novel hybrid local search algorithm combines a multi-objective aware segment relocation with a dynamic edge reconfiguration, prioritizing edges that show potential for simultaneous improvement in both objectives while using a probabilistic validation mechanism to maintain feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=1)\n    scores = normalized.sum(axis=1) * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation with dynamic edge reconfiguration\n    for _ in range(3):\n        # Select segment based on potential improvement\n        potential = []\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                segment = new_solution[i:j]\n                cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                potential.append((i, j, cost1 + cost2))\n\n        if not potential:\n            break\n\n        # Select segment with highest potential\n        i, j, _ = max(potential, key=lambda x: x[2])\n\n        # Relocate segment to best position\n        best_pos = -1\n        best_score = float('inf')\n        for pos in range(n):\n            if pos >= i and pos <= j:\n                continue\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]\n\n            if new_cost1 + new_cost2 < best_score:\n                best_score = new_cost1 + new_cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, slice(i, j))\n            ])\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() < 0.7:  # 70% chance to insert missing node\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.925215797700419,
            5.837337791919708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized, axis=1)\n    scores = normalized.sum(axis=1) * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation with dynamic edge reconfiguration\n    for _ in range(3):\n        # Select segment based on potential improvement\n        potential = []\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):\n                segment = new_solution[i:j]\n                cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                potential.append((i, j, cost1 + cost2))\n\n        if not potential:\n            break\n\n        # Select segment with highest potential\n        i, j, _ = max(potential, key=lambda x: x[2])\n\n        # Relocate segment to best position\n        best_pos = -1\n        best_score = float('inf')\n        for pos in range(n):\n            if pos >= i and pos <= j:\n                continue\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]\n\n            if new_cost1 + new_cost2 < best_score:\n                best_score = new_cost1 + new_cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, slice(i, j))\n            ])\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() < 0.7:  # 70% chance to insert missing node\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node sequence rotation with a dynamic edge selection mechanism, prioritizing edges that show potential for improvement in both objectives while maintaining feasibility through a comprehensive validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax((objectives[:, 0] + objectives[:, 1]) / (objectives[:, 0] * objectives[:, 1] + 1e-8))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node sequence rotation\n    for _ in range(3):\n        # Select a segment to rotate\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+2, n)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]]\n        current_cost2 = distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end]]\n\n        # Rotate the segment\n        rotated = np.roll(new_solution[seg_start:seg_end], np.random.randint(1, seg_end-seg_start))\n        new_solution[seg_start:seg_end] = rotated\n\n        # Calculate new costs\n        new_cost1 = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]]\n        new_cost2 = distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 <= current_cost1) or (new_cost2 <= current_cost2)):\n            new_solution[seg_start:seg_end] = np.roll(rotated, -np.random.randint(1, seg_end-seg_start))\n\n    # Dynamic edge selection mechanism\n    for _ in range(2):\n        # Find edges with potential for improvement\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append((cost1 + cost2) / (cost1 * cost2 + 1e-8))\n\n        # Select edges with highest scores\n        edges_to_improve = np.argsort(edge_scores)[-2:]\n\n        for edge in edges_to_improve:\n            # Try to replace the edge with a better one\n            i, j = new_solution[edge], new_solution[edge+1]\n            candidates = []\n            for k in range(n):\n                if k != edge and k != edge+1:\n                    new_cost1 = distance_matrix_1[new_solution[edge-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[edge+1]]\n                    new_cost2 = distance_matrix_2[new_solution[edge-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[edge+1]]\n                    candidates.append((new_cost1 + new_cost2, k))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[0])[1]\n                new_solution = np.insert(new_solution, edge+1, best_candidate)\n                new_solution = np.delete(new_solution, edge+2 if edge+2 < len(new_solution) else edge)\n\n    # Validate and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8625413959760672,
            3.8205676674842834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax((objectives[:, 0] + objectives[:, 1]) / (objectives[:, 0] * objectives[:, 1] + 1e-8))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node sequence rotation\n    for _ in range(3):\n        # Select a segment to rotate\n        seg_start = np.random.randint(0, n-2)\n        seg_end = np.random.randint(seg_start+2, n)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]]\n        current_cost2 = distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end]]\n\n        # Rotate the segment\n        rotated = np.roll(new_solution[seg_start:seg_end], np.random.randint(1, seg_end-seg_start))\n        new_solution[seg_start:seg_end] = rotated\n\n        # Calculate new costs\n        new_cost1 = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]]\n        new_cost2 = distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 <= current_cost1) or (new_cost2 <= current_cost2)):\n            new_solution[seg_start:seg_end] = np.roll(rotated, -np.random.randint(1, seg_end-seg_start))\n\n    # Dynamic edge selection mechanism\n    for _ in range(2):\n        # Find edges with potential for improvement\n        edge_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_scores.append((cost1 + cost2) / (cost1 * cost2 + 1e-8))\n\n        # Select edges with highest scores\n        edges_to_improve = np.argsort(edge_scores)[-2:]\n\n        for edge in edges_to_improve:\n            # Try to replace the edge with a better one\n            i, j = new_solution[edge], new_solution[edge+1]\n            candidates = []\n            for k in range(n):\n                if k != edge and k != edge+1:\n                    new_cost1 = distance_matrix_1[new_solution[edge-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[edge+1]]\n                    new_cost2 = distance_matrix_2[new_solution[edge-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[edge+1]]\n                    candidates.append((new_cost1 + new_cost2, k))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[0])[1]\n                new_solution = np.insert(new_solution, edge+1, best_candidate)\n                new_solution = np.delete(new_solution, edge+2 if edge+2 < len(new_solution) else edge)\n\n    # Validate and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This novel hybrid local search algorithm combines guided edge swaps with adaptive segment reversals, prioritizing high-potential edges while dynamically balancing improvements across both objectives through a multi-criteria edge selection mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with adaptive segment reversals\n    for _ in range(5):\n        # Select edges with potential for improvement in both objectives\n        candidates = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            # Calculate potential improvement for both objectives\n            improvement_1 = (distance_matrix_1[u][v] - distance_matrix_1[u][new_solution[(i+2)%n]]) + \\\n                           (distance_matrix_1[new_solution[(i-1)%n]][new_solution[i]] - distance_matrix_1[new_solution[(i-1)%n]][new_solution[(i+2)%n]])\n            improvement_2 = (distance_matrix_2[u][v] - distance_matrix_2[u][new_solution[(i+2)%n]]) + \\\n                           (distance_matrix_2[new_solution[(i-1)%n]][new_solution[i]] - distance_matrix_2[new_solution[(i-1)%n]][new_solution[(i+2)%n]])\n            candidates.append((improvement_1 + improvement_2, i))\n\n        # Select top 3 edges with highest potential improvement\n        candidates.sort(reverse=True, key=lambda x: x[0])\n        selected_edges = [i for _, i in candidates[:3]]\n\n        for i in selected_edges:\n            # Perform edge swap\n            j = (i + 2) % n\n            if i < j:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Adaptive repair: reverse segments to restore validity\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7946246670468761,
            3.472889482975006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with adaptive segment reversals\n    for _ in range(5):\n        # Select edges with potential for improvement in both objectives\n        candidates = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            # Calculate potential improvement for both objectives\n            improvement_1 = (distance_matrix_1[u][v] - distance_matrix_1[u][new_solution[(i+2)%n]]) + \\\n                           (distance_matrix_1[new_solution[(i-1)%n]][new_solution[i]] - distance_matrix_1[new_solution[(i-1)%n]][new_solution[(i+2)%n]])\n            improvement_2 = (distance_matrix_2[u][v] - distance_matrix_2[u][new_solution[(i+2)%n]]) + \\\n                           (distance_matrix_2[new_solution[(i-1)%n]][new_solution[i]] - distance_matrix_2[new_solution[(i-1)%n]][new_solution[(i+2)%n]])\n            candidates.append((improvement_1 + improvement_2, i))\n\n        # Select top 3 edges with highest potential improvement\n        candidates.sort(reverse=True, key=lambda x: x[0])\n        selected_edges = [i for _, i in candidates[:3]]\n\n        for i in selected_edges:\n            # Perform edge swap\n            j = (i + 2) % n\n            if i < j:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Adaptive repair: reverse segments to restore validity\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block relocation with a multi-objective aware node insertion, favoring solutions with high crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        block_size = np.random.randint(2, min(4, n-1))\n        start = np.random.randint(0, n - block_size)\n        end = start + block_size\n        block = new_solution[start:end]\n\n        # Remove the block\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        # Insert the block at a new random position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Calculate cost for insertion at this position\n            if pos == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[pos-1]\n\n            next_node = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Prefer positions that improve at least one objective\n            if (cost1 < 0) or (cost2 < 0):\n                best_pos = pos\n                break\n            elif (cost1 + cost2) < (best_cost1 + best_cost2):\n                best_pos = pos\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8768979869062146,
            2.5669166445732117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        block_size = np.random.randint(2, min(4, n-1))\n        start = np.random.randint(0, n - block_size)\n        end = start + block_size\n        block = new_solution[start:end]\n\n        # Remove the block\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        # Insert the block at a new random position\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Calculate cost for insertion at this position\n            if pos == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[pos-1]\n\n            next_node = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Prefer positions that improve at least one objective\n            if (cost1 < 0) or (cost2 < 0):\n                best_pos = pos\n                break\n            elif (cost1 + cost2) < (best_cost1 + best_cost2):\n                best_pos = pos\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This novel algorithm combines adaptive multi-objective edge swapping with probabilistic path inversion, utilizing both distance matrices to guide segment relocations while maintaining feasibility through a dynamic consistency check and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(3):\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        if i > j:\n            i, j = j, i\n\n        segment = new_solution[i:j+1]\n        if np.random.rand() > 0.5:\n            segment = segment[::-1]\n\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9488627205182304,
            2.3926340341567993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(3):\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        if i > j:\n            i, j = j, i\n\n        segment = new_solution[i:j+1]\n        if np.random.rand() > 0.5:\n            segment = segment[::-1]\n\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility, and uses a dynamic temperature-based acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with dynamic temperature\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        temp = 1.0 / (1 + archive[selected_idx][1][0] + archive[selected_idx][1][1])\n        if np.random.random() < temp:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with adaptive selection\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Adaptive acceptance criterion\n        delta1 = new_cost1 - original_cost1\n        delta2 = new_cost2 - original_cost2\n        if (delta1 < 0) or (delta2 < 0) or (np.random.random() < np.exp(-(delta1 + delta2) / (1 + archive[selected_idx][1][0] + archive[selected_idx][1][1]))):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8820017735916489,
            2.008858799934387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with dynamic temperature\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        temp = 1.0 / (1 + archive[selected_idx][1][0] + archive[selected_idx][1][1])\n        if np.random.random() < temp:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with adaptive selection\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Adaptive acceptance criterion\n        delta1 = new_cost1 - original_cost1\n        delta2 = new_cost2 - original_cost2\n        if (delta1 < 0) or (delta2 < 0) or (np.random.random() < np.exp(-(delta1 + delta2) / (1 + archive[selected_idx][1][0] + archive[selected_idx][1][1]))):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware edge insertion, guided by Pareto dominance and crowding distance to explore under-explored regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8388150500770937,
            1.617789387702942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with high Pareto dominance while ensuring feasibility by carefully preserving the tour structure and validating all moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest Pareto dominance (simplified by choosing the one with best combined score)\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n    combined_scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # Calculate cost change\n        original_cost1 = (distance_matrix_1[base_solution[a-1], base_solution[a]] +\n                          distance_matrix_1[base_solution[b-1], base_solution[b]] +\n                          distance_matrix_1[base_solution[c-1], base_solution[c]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        original_cost2 = (distance_matrix_2[base_solution[a-1], base_solution[a]] +\n                          distance_matrix_2[base_solution[b-1], base_solution[b]] +\n                          distance_matrix_2[base_solution[c-1], base_solution[c]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Revert if relocation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to reverse\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7360978413400762,
            2.0814477801322937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest Pareto dominance (simplified by choosing the one with best combined score)\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n    combined_scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # Calculate cost change\n        original_cost1 = (distance_matrix_1[base_solution[a-1], base_solution[a]] +\n                          distance_matrix_1[base_solution[b-1], base_solution[b]] +\n                          distance_matrix_1[base_solution[c-1], base_solution[c]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        original_cost2 = (distance_matrix_2[base_solution[a-1], base_solution[a]] +\n                          distance_matrix_2[base_solution[b-1], base_solution[b]] +\n                          distance_matrix_2[base_solution[c-1], base_solution[c]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Revert if relocation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.5:  # 50% chance to reverse\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm combines a multi-objective aware segment relocation with a guided edge insertion strategy, where segments are relocated based on their potential to improve both objectives while inserting edges that bridge promising regions in the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    for _ in range(3):\n        # Select a segment based on its potential to improve both objectives\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Find insertion position that improves both objectives\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue\n            if pos == a-1 or pos == b:\n                continue\n\n            new_cost1 = distance_matrix_1[new_solution[pos], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[pos+1 if pos < n-1 else 0]]\n            new_cost2 = distance_matrix_2[new_solution[pos], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[pos+1 if pos < n-1 else 0]]\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Move segment to new position\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[a:b], new_solution[best_pos:]])\n\n    # Guided edge insertion\n    for _ in range(3):\n        # Select edges that bridge promising regions\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j-1 if j > 0 else n-1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j-1 if j > 0 else n-1]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Perform edge insertion\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:j], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution if invalid\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n\n    return new_solution\n\n",
        "score": [
            -0.9738768414840542,
            2.2815216183662415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment relocation\n    for _ in range(3):\n        # Select a segment based on its potential to improve both objectives\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Find insertion position that improves both objectives\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue\n            if pos == a-1 or pos == b:\n                continue\n\n            new_cost1 = distance_matrix_1[new_solution[pos], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[pos+1 if pos < n-1 else 0]]\n            new_cost2 = distance_matrix_2[new_solution[pos], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[pos+1 if pos < n-1 else 0]]\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Move segment to new position\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[a:b], new_solution[best_pos:]])\n\n    # Guided edge insertion\n    for _ in range(3):\n        # Select edges that bridge promising regions\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j-1 if j > 0 else n-1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j-1 if j > 0 else n-1]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Perform edge insertion\n            segment = new_solution[i+1:j]\n            new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:j], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution if invalid\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node relocation with a dynamic segment crossover, prioritizing nodes that show potential for improvement in both objectives while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.prod(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 3:\n        # Identify nodes with potential for improvement\n        node_scores = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            score1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            score2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            node_scores.append(score1 * score2)\n\n        # Select node to relocate\n        node_scores = np.array(node_scores)\n        relocate_node = np.argsort(node_scores)[-1]  # Node with worst combined score\n\n        # Find best insertion position\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n):\n            if pos == relocate_node or pos == (relocate_node-1)%n or pos == (relocate_node+1)%n:\n                continue\n\n            # Calculate improvement\n            old_positions = [(relocate_node-1)%n, relocate_node, (relocate_node+1)%n]\n            new_positions = [(pos-1)%n, pos, (pos+1)%n]\n\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in old_positions)\n            new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in new_positions)\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in old_positions)\n            new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in new_positions)\n            improvement2 = old_cost2 - new_cost2\n\n            if improvement1 > 0 or improvement2 > 0:\n                if (improvement1 + improvement2) > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_improvement > 0:\n            # Remove node and insert at best position\n            node = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Dynamic segment crossover\n    if n > 4:\n        # Randomly select two segments\n        a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n        # Create new segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Create new solution by combining segments\n        temp_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n        temp_solution = np.unique(temp_solution)\n\n        # Probabilistic repair if needed\n        if len(temp_solution) != n:\n            missing_nodes = list(set(range(n)) - set(temp_solution))\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(temp_solution))\n                temp_solution = np.insert(temp_solution, insert_pos, node)\n\n        # Accept if it's better in at least one objective\n        if len(temp_solution) == n:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8208040901762508,
            5.064246714115143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.prod(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 3:\n        # Identify nodes with potential for improvement\n        node_scores = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            score1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            score2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            node_scores.append(score1 * score2)\n\n        # Select node to relocate\n        node_scores = np.array(node_scores)\n        relocate_node = np.argsort(node_scores)[-1]  # Node with worst combined score\n\n        # Find best insertion position\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n):\n            if pos == relocate_node or pos == (relocate_node-1)%n or pos == (relocate_node+1)%n:\n                continue\n\n            # Calculate improvement\n            old_positions = [(relocate_node-1)%n, relocate_node, (relocate_node+1)%n]\n            new_positions = [(pos-1)%n, pos, (pos+1)%n]\n\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in old_positions)\n            new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in new_positions)\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in old_positions)\n            new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in new_positions)\n            improvement2 = old_cost2 - new_cost2\n\n            if improvement1 > 0 or improvement2 > 0:\n                if (improvement1 + improvement2) > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_improvement > 0:\n            # Remove node and insert at best position\n            node = new_solution[relocate_node]\n            new_solution = np.delete(new_solution, relocate_node)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Dynamic segment crossover\n    if n > 4:\n        # Randomly select two segments\n        a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n        # Create new segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Create new solution by combining segments\n        temp_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n        temp_solution = np.unique(temp_solution)\n\n        # Probabilistic repair if needed\n        if len(temp_solution) != n:\n            missing_nodes = list(set(range(n)) - set(temp_solution))\n            for node in missing_nodes:\n                insert_pos = np.random.randint(0, len(temp_solution))\n                temp_solution = np.insert(temp_solution, insert_pos, node)\n\n        # Accept if it's better in at least one objective\n        if len(temp_solution) == n:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{A novel hybrid local search operator that combines a randomized partial reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized partial reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized partial reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8041750090162261,
            2.3350204825401306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized partial reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized partial reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9238188461412823,
            1.0247361660003662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search algorithm combines edge reversals with guided segment swaps, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge reversal with guided segment swap\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b] and swap with segment [b+1, c]\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7074491695148504,
            0.5996912121772766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge reversal with guided segment swap\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b] and swap with segment [b+1, c]\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search algorithm combines edge reversals with guided segment swaps, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge reversal with guided segment swap\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b] and swap with segment [b+1, c]\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7074491695148504,
            0.5996912121772766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge reversal with guided segment swap\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b] and swap with segment [b+1, c]\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{A novel local search operator that combines a multi-objective aware segment relocation with a randomized edge insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment relocation + randomized edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes the increase in both objectives\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(new_solution)):\n            # Calculate cost before insertion\n            if pos == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n            # Calculate cost after insertion\n            if pos == 0:\n                new_cost1 = distance_matrix_1[segment[-1], new_solution[0]] + distance_matrix_1[segment[0], new_solution[-1]]\n                new_cost2 = distance_matrix_2[segment[-1], new_solution[0]] + distance_matrix_2[segment[0], new_solution[-1]]\n            else:\n                new_cost1 = distance_matrix_1[segment[-1], new_solution[pos]] + distance_matrix_1[segment[0], new_solution[pos-1]]\n                new_cost2 = distance_matrix_2[segment[-1], new_solution[pos]] + distance_matrix_2[segment[0], new_solution[pos-1]]\n\n            cost_diff1 = new_cost1 - original_cost1\n            cost_diff2 = new_cost2 - original_cost2\n\n            # Use weighted sum of cost differences to balance objectives\n            total_diff = cost_diff1 + cost_diff2\n            if total_diff < min_cost:\n                min_cost = total_diff\n                best_pos = pos\n\n        # Insert the segment at the best position\n        if best_pos == 0:\n            new_solution = np.concatenate([segment, new_solution])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Randomized edge insertion\n    if n > 3:\n        # Select a random edge to remove\n        edge_idx = np.random.randint(0, n)\n        node1 = new_solution[edge_idx]\n        node2 = new_solution[(edge_idx + 1) % n]\n\n        # Remove the edge\n        new_solution = np.concatenate([new_solution[:edge_idx], new_solution[edge_idx+1:]])\n\n        # Find a random position to insert the edge\n        insert_pos = np.random.randint(0, len(new_solution))\n\n        # Insert the edge back\n        if insert_pos == 0:\n            new_solution = np.concatenate([[node1, node2], new_solution])\n        else:\n            new_solution = np.concatenate([new_solution[:insert_pos], [node1, node2], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9273168765048229,
            0.7509186267852783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment relocation + randomized edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes the increase in both objectives\n        min_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(new_solution)):\n            # Calculate cost before insertion\n            if pos == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n            # Calculate cost after insertion\n            if pos == 0:\n                new_cost1 = distance_matrix_1[segment[-1], new_solution[0]] + distance_matrix_1[segment[0], new_solution[-1]]\n                new_cost2 = distance_matrix_2[segment[-1], new_solution[0]] + distance_matrix_2[segment[0], new_solution[-1]]\n            else:\n                new_cost1 = distance_matrix_1[segment[-1], new_solution[pos]] + distance_matrix_1[segment[0], new_solution[pos-1]]\n                new_cost2 = distance_matrix_2[segment[-1], new_solution[pos]] + distance_matrix_2[segment[0], new_solution[pos-1]]\n\n            cost_diff1 = new_cost1 - original_cost1\n            cost_diff2 = new_cost2 - original_cost2\n\n            # Use weighted sum of cost differences to balance objectives\n            total_diff = cost_diff1 + cost_diff2\n            if total_diff < min_cost:\n                min_cost = total_diff\n                best_pos = pos\n\n        # Insert the segment at the best position\n        if best_pos == 0:\n            new_solution = np.concatenate([segment, new_solution])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Randomized edge insertion\n    if n > 3:\n        # Select a random edge to remove\n        edge_idx = np.random.randint(0, n)\n        node1 = new_solution[edge_idx]\n        node2 = new_solution[(edge_idx + 1) % n]\n\n        # Remove the edge\n        new_solution = np.concatenate([new_solution[:edge_idx], new_solution[edge_idx+1:]])\n\n        # Find a random position to insert the edge\n        insert_pos = np.random.randint(0, len(new_solution))\n\n        # Insert the edge back\n        if insert_pos == 0:\n            new_solution = np.concatenate([[node1, node2], new_solution])\n        else:\n            new_solution = np.concatenate([new_solution[:insert_pos], [node1, node2], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment reordering with a multi-objective aware edge insertion, prioritizing solutions with high potential for improvement by analyzing both objective spaces' distance matrices to guide the search toward Pareto-optimal regions while ensuring feasibility through a dynamic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest potential for improvement (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random weights for each objective\n    weighted_sum = (normalized * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_sum)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reordering\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))  # Random segment size\n        a = np.random.randint(0, n - k)\n        segment = new_solution[a:a+k]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+k:], segment])\n\n    # Multi-objective aware edge insertion\n    if n > 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost impact in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < 0.9 * original_cost1 and new_cost2 < 1.1 * original_cost2) or \\\n           (new_cost1 < 1.1 * original_cost1 and new_cost2 < 0.9 * original_cost2):\n            new_solution = np.insert(new_solution, j, new_solution[i])\n            new_solution = np.delete(new_solution, i + (1 if i > j else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution if invalid\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9045596244807954,
            2.463314414024353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the highest potential for improvement (weighted sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random weights for each objective\n    weighted_sum = (normalized * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_sum)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment reordering\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))  # Random segment size\n        a = np.random.randint(0, n - k)\n        segment = new_solution[a:a+k]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+k:], segment])\n\n    # Multi-objective aware edge insertion\n    if n > 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost impact in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < 0.9 * original_cost1 and new_cost2 < 1.1 * original_cost2) or \\\n           (new_cost1 < 1.1 * original_cost1 and new_cost2 < 0.9 * original_cost2):\n            new_solution = np.insert(new_solution, j, new_solution[i])\n            new_solution = np.delete(new_solution, i + (1 if i > j else 0))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution if invalid\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware k-opt move, favoring solutions with high crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 3:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a:\n            b = np.random.randint(0, n)\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    # Step 2: Multi-objective aware k-opt move (k=3)\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before move\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Calculate cost after move\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_1[new_solution[i], new_solution[k-1]] +\n                      distance_matrix_1[new_solution[j], new_solution[k]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_2[new_solution[i], new_solution[k-1]] +\n                      distance_matrix_2[new_solution[j], new_solution[k]])\n\n        # Accept move if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9028098597837514,
            2.5339545607566833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 3:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a:\n            b = np.random.randint(0, n)\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    # Step 2: Multi-objective aware k-opt move (k=3)\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before move\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Calculate cost after move\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_1[new_solution[i], new_solution[k-1]] +\n                      distance_matrix_1[new_solution[j], new_solution[k]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                      distance_matrix_2[new_solution[i], new_solution[k-1]] +\n                      distance_matrix_2[new_solution[j], new_solution[k]])\n\n        # Accept move if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel adaptive local search operator that combines a dynamic segment relocation with a Pareto-aware edge insertion, guided by both crowding distance and non-dominated sorting to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 2:\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Pareto-aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it dominates or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9211744327760589,
            1.5961734652519226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 2:\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Pareto-aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it dominates or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A hybrid local search algorithm that combines edge swaps with adaptive segment reversals, leveraging multi-objective edge potential scores to guide the search while dynamically balancing exploration and exploitation through probabilistic segment selection and feasibility-preserving repairs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(3):\n        # Calculate edge potential scores\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            prev_node = new_solution[i-1]\n\n            # Score based on average distance improvement potential\n            edge_scores[i] = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node] -\n                             distance_matrix_1[prev_node, current] - distance_matrix_2[prev_node, current]) / 2\n\n        # Select segment with highest potential\n        if np.max(edge_scores) > 0:\n            start = np.argmax(edge_scores)\n            length = np.random.randint(2, min(5, n//2))\n            end = (start + length) % n\n\n            # Reverse the selected segment\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[len(segment)-end:], new_solution[end:start], segment[:len(segment)-end]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in random positions\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8051338555879044,
            2.6613807678222656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(3):\n        # Calculate edge potential scores\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            prev_node = new_solution[i-1]\n\n            # Score based on average distance improvement potential\n            edge_scores[i] = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node] -\n                             distance_matrix_1[prev_node, current] - distance_matrix_2[prev_node, current]) / 2\n\n        # Select segment with highest potential\n        if np.max(edge_scores) > 0:\n            start = np.argmax(edge_scores)\n            length = np.random.randint(2, min(5, n//2))\n            end = (start + length) % n\n\n            # Reverse the selected segment\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[len(segment)-end:], new_solution[end:start], segment[:len(segment)-end]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in random positions\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel hybrid local search algorithm combines guided edge swaps with adaptive segment rotations, prioritizing edges with high potential for Pareto-front improvement while maintaining feasibility through a dynamic validation and repair mechanism that considers both objective spaces' geometric properties.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with adaptive segment rotations\n    for _ in range(5):\n        # Select a segment to rotate\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            rotated = np.roll(segment, np.random.randint(1, length))\n            new_solution[start:end] = rotated\n        else:\n            segment1 = new_solution[start:]\n            segment2 = new_solution[:end]\n            combined = np.concatenate([segment1, segment2])\n            rotated = np.roll(combined, np.random.randint(1, length))\n            new_solution[start:] = rotated[:len(segment1)]\n            new_solution[:end] = rotated[len(segment1):]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in order\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.951589559832771,
            2.529137909412384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with adaptive segment rotations\n    for _ in range(5):\n        # Select a segment to rotate\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            rotated = np.roll(segment, np.random.randint(1, length))\n            new_solution[start:end] = rotated\n        else:\n            segment1 = new_solution[start:]\n            segment2 = new_solution[:end]\n            combined = np.concatenate([segment1, segment2])\n            rotated = np.roll(combined, np.random.randint(1, length))\n            new_solution[start:] = rotated[:len(segment1)]\n            new_solution[:end] = rotated[len(segment1):]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in order\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{A novel hybrid local search algorithm combines segment reversals with adaptive edge swaps, prioritizing edges that show significant potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment reversal with adaptive edge swaps\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive edge swap based on distance improvement\n        for i in range(a, b):\n            j = (i + 1) % n\n            # Calculate potential improvement in both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or np.random.random() < 0.3:  # Accept if both objectives improve or with small probability\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8342693812150923,
            2.3899521827697754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment reversal with adaptive edge swaps\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive edge swap based on distance improvement\n        for i in range(a, b):\n            j = (i + 1) % n\n            # Calculate potential improvement in both objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (delta1 < 0 and delta2 < 0) or np.random.random() < 0.3:  # Accept if both objectives improve or with small probability\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware path rotation with a guided node relocation strategy, prioritizing edges that show potential for simultaneous improvement in both objectives while dynamically balancing exploration and exploitation through adaptive segment selection and feasibility-preserving operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware path rotation\n    if n > 3:\n        # Select a segment to rotate\n        seg_length = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Evaluate rotation options\n        best_rotation = 0\n        best_improvement = 0\n\n        for k in range(1, seg_length):\n            rotated = np.roll(segment, k)\n\n            # Calculate cost before and after rotation\n            original_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_1[new_solution[start+seg_length-1], new_solution[start+seg_length]])\n            original_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_2[new_solution[start+seg_length-1], new_solution[start+seg_length]])\n\n            new_cost1 = (distance_matrix_1[new_solution[start-1], rotated[0]] +\n                        distance_matrix_1[rotated[-1], new_solution[start+seg_length]])\n            new_cost2 = (distance_matrix_2[new_solution[start-1], rotated[0]] +\n                        distance_matrix_2[rotated[-1], new_solution[start+seg_length]])\n\n            # Calculate improvement (both objectives)\n            improvement = ((original_cost1 - new_cost1) + (original_cost2 - new_cost2)) / 2\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_rotation = k\n\n        # Apply best rotation\n        if best_rotation > 0:\n            new_solution[start:start+seg_length] = np.roll(segment, best_rotation)\n\n    # Guided node relocation\n    if n > 2:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion point considering both objectives\n        best_pos = node_idx\n        best_score = 0\n\n        for i in range(n):\n            if i == node_idx or i == node_idx - 1:\n                continue\n\n            # Calculate cost before and after relocation\n            original_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n            # Calculate score (both objectives)\n            score = ((original_cost1 - new_cost1) + (original_cost2 - new_cost2)) / 2\n\n            if score > best_score:\n                best_score = score\n                best_pos = i\n\n        # Apply relocation if beneficial\n        if best_pos != node_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, (best_pos+1)%n, node)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8516295151064089,
            2.6644444465637207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware path rotation\n    if n > 3:\n        # Select a segment to rotate\n        seg_length = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Evaluate rotation options\n        best_rotation = 0\n        best_improvement = 0\n\n        for k in range(1, seg_length):\n            rotated = np.roll(segment, k)\n\n            # Calculate cost before and after rotation\n            original_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_1[new_solution[start+seg_length-1], new_solution[start+seg_length]])\n            original_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                            distance_matrix_2[new_solution[start+seg_length-1], new_solution[start+seg_length]])\n\n            new_cost1 = (distance_matrix_1[new_solution[start-1], rotated[0]] +\n                        distance_matrix_1[rotated[-1], new_solution[start+seg_length]])\n            new_cost2 = (distance_matrix_2[new_solution[start-1], rotated[0]] +\n                        distance_matrix_2[rotated[-1], new_solution[start+seg_length]])\n\n            # Calculate improvement (both objectives)\n            improvement = ((original_cost1 - new_cost1) + (original_cost2 - new_cost2)) / 2\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_rotation = k\n\n        # Apply best rotation\n        if best_rotation > 0:\n            new_solution[start:start+seg_length] = np.roll(segment, best_rotation)\n\n    # Guided node relocation\n    if n > 2:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion point considering both objectives\n        best_pos = node_idx\n        best_score = 0\n\n        for i in range(n):\n            if i == node_idx or i == node_idx - 1:\n                continue\n\n            # Calculate cost before and after relocation\n            original_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i], node] +\n                        distance_matrix_1[node, new_solution[(i+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i], node] +\n                        distance_matrix_2[node, new_solution[(i+1)%n]])\n\n            # Calculate score (both objectives)\n            score = ((original_cost1 - new_cost1) + (original_cost2 - new_cost2)) / 2\n\n            if score > best_score:\n                best_score = score\n                best_pos = i\n\n        # Apply relocation if beneficial\n        if best_pos != node_idx:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, (best_pos+1)%n, node)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm implements a hybrid local search that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with high crowding distance or Pareto dominance to guide exploration toward less crowded regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with variable segment length\n    if n > 3:\n        segment_length = np.random.randint(2, min(6, n-1))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with probabilistic acceptance\n    if n > 4:\n        i = np.random.randint(1, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Probabilistic acceptance based on cost improvement\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9138806514915876,
            2.2634602785110474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with variable segment length\n    if n > 3:\n        segment_length = np.random.randint(2, min(6, n-1))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with probabilistic acceptance\n    if n > 4:\n        i = np.random.randint(1, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Probabilistic acceptance based on cost improvement\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 < original_cost1 or new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel adaptive hybrid local search algorithm that combines edge relocations with objective-aware segment swaps, guided by a dynamic multi-objective potential score, while ensuring feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest adaptive objective potential\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=objectives.shape[1])\n    weighted_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weighted_scores = weighted_scores * weights\n    selected_idx = np.argmax(weighted_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: objective-aware segment swaps\n    for _ in range(7):\n        # Select segments based on objective potential\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[(c+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[(c+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[(c+1)%n]]\n\n        # Accept if potential improvement is high\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.random() < 0.3:\n            segment = new_solution[b+1:c+1]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() < 0.7:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9099402825702473,
            1.5736473202705383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest adaptive objective potential\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=objectives.shape[1])\n    weighted_scores = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weighted_scores = weighted_scores * weights\n    selected_idx = np.argmax(weighted_scores.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: objective-aware segment swaps\n    for _ in range(7):\n        # Select segments based on objective potential\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[(c+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[(c+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[(c+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[(c+1)%n]]\n\n        # Accept if potential improvement is high\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.random() < 0.3:\n            segment = new_solution[b+1:c+1]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() < 0.7:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node relocation with a dynamic edge inversion, prioritizing solutions with high potential for improvement by analyzing both objective-specific edge contributions and their combined impact, while ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with dynamic edge inversion\n    for _ in range(3):\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate potential improvement for each possible insertion position\n        improvements = []\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                improvements.append((0, 0))\n                continue\n\n            # Calculate current and new edges\n            prev_node = new_solution[node_idx - 1]\n            next_node = new_solution[(node_idx + 1) % n]\n            new_prev = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            new_next = new_solution[pos]\n\n            # Calculate objective improvements\n            imp1 = (distance_matrix_1[prev_node, new_prev] + distance_matrix_1[next_node, new_next] -\n                    distance_matrix_1[prev_node, node] - distance_matrix_1[node, next_node] -\n                    distance_matrix_1[new_prev, new_next] + distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next])\n            imp2 = (distance_matrix_2[prev_node, new_prev] + distance_matrix_2[next_node, new_next] -\n                    distance_matrix_2[prev_node, node] - distance_matrix_2[node, next_node] -\n                    distance_matrix_2[new_prev, new_next] + distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next])\n\n            improvements.append((imp1, imp2))\n\n        # Select best insertion position\n        improvements = np.array(improvements)\n        weighted_improvements = improvements[:, 0] * improvements[:, 1]  # Combined improvement\n        best_pos = np.argmax(weighted_improvements)\n\n        if weighted_improvements[best_pos] > 0:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n            # Dynamic edge inversion for further improvement\n            if np.random.random() < 0.3:  # 30% chance to invert a segment\n                a, b = sorted(np.random.choice(n, size=2, replace=False))\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9252707480560731,
            5.720777809619904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with dynamic edge inversion\n    for _ in range(3):\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate potential improvement for each possible insertion position\n        improvements = []\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                improvements.append((0, 0))\n                continue\n\n            # Calculate current and new edges\n            prev_node = new_solution[node_idx - 1]\n            next_node = new_solution[(node_idx + 1) % n]\n            new_prev = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            new_next = new_solution[pos]\n\n            # Calculate objective improvements\n            imp1 = (distance_matrix_1[prev_node, new_prev] + distance_matrix_1[next_node, new_next] -\n                    distance_matrix_1[prev_node, node] - distance_matrix_1[node, next_node] -\n                    distance_matrix_1[new_prev, new_next] + distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next])\n            imp2 = (distance_matrix_2[prev_node, new_prev] + distance_matrix_2[next_node, new_next] -\n                    distance_matrix_2[prev_node, node] - distance_matrix_2[node, next_node] -\n                    distance_matrix_2[new_prev, new_next] + distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next])\n\n            improvements.append((imp1, imp2))\n\n        # Select best insertion position\n        improvements = np.array(improvements)\n        weighted_improvements = improvements[:, 0] * improvements[:, 1]  # Combined improvement\n        best_pos = np.argmax(weighted_improvements)\n\n        if weighted_improvements[best_pos] > 0:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n            # Dynamic edge inversion for further improvement\n            if np.random.random() < 0.3:  # 30% chance to invert a segment\n                a, b = sorted(np.random.choice(n, size=2, replace=False))\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This novel hybrid local search algorithm combines guided edge swaps with adaptive segment inversions, prioritizing multi-objective improvement by evaluating edge potential through a weighted combination of both objectives while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_sum = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmax(weighted_sum)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with adaptive segment inversions\n    for _ in range(5):\n        # Select edges based on multi-objective potential\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement\n        curr_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < curr_cost:\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Adaptive segment inversion\n            if np.random.rand() < 0.5:\n                k, l = np.random.choice(n, size=2, replace=False)\n                if k > l:\n                    k, l = l, k\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8939948667149219,
            1.5246109366416931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_sum = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmax(weighted_sum)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with adaptive segment inversions\n    for _ in range(5):\n        # Select edges based on multi-objective potential\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement\n        curr_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < curr_cost:\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Adaptive segment inversion\n            if np.random.rand() < 0.5:\n                k, l = np.random.choice(n, size=2, replace=False)\n                if k > l:\n                    k, l = l, k\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment shuffling with multi-objective edge prioritization, dynamically selecting and reordering segments based on their potential to reduce both objectives while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment shuffling with multi-objective prioritization\n    for _ in range(3):\n        # Select segments based on potential edge improvements\n        segment_lengths = np.random.choice([2, 3, 4], size=2, replace=False)\n        a = np.random.randint(0, n - sum(segment_lengths))\n        b = a + segment_lengths[0]\n        c = b + segment_lengths[1]\n\n        # Evaluate segment potential\n        current_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b]] +\n                       distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[c]])\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[a], new_solution[c]] +\n                    distance_matrix_1[new_solution[c], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[b]])\n\n        if new_cost < current_cost:\n            # Reverse the middle segment if it improves both objectives\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Probabilistic repair: swap nodes with low potential impact\n        for i in range(n):\n            if np.random.random() < 0.3:\n                j = np.random.randint(0, n)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9668022629190133,
            1.858830451965332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity in objectives (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment shuffling with multi-objective prioritization\n    for _ in range(3):\n        # Select segments based on potential edge improvements\n        segment_lengths = np.random.choice([2, 3, 4], size=2, replace=False)\n        a = np.random.randint(0, n - sum(segment_lengths))\n        b = a + segment_lengths[0]\n        c = b + segment_lengths[1]\n\n        # Evaluate segment potential\n        current_cost = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b]] +\n                       distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[c]])\n        new_cost = (distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[a], new_solution[c]] +\n                    distance_matrix_1[new_solution[c], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[b]])\n\n        if new_cost < current_cost:\n            # Reverse the middle segment if it improves both objectives\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Probabilistic repair: swap nodes with low potential impact\n        for i in range(n):\n            if np.random.random() < 0.3:\n                j = np.random.randint(0, n)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel hybrid local search algorithm combines multi-objective edge swapping with adaptive segment reversals, prioritizing edges with high potential for improvement in both objective spaces while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective edge swapping with adaptive segment reversals\n    for _ in range(5):\n        # Randomly select edges to swap based on multi-objective potential\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        delta2 = new_cost2 - old_cost2\n\n        # Perform swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Randomly select a segment to reverse for additional exploration\n        c, d = np.random.choice(n, size=2, replace=False)\n        if c > d:\n            c, d = d, c\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9558681889029181,
            1.948891520500183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective edge swapping with adaptive segment reversals\n    for _ in range(5):\n        # Randomly select edges to swap based on multi-objective potential\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n        delta2 = new_cost2 - old_cost2\n\n        # Perform swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Randomly select a segment to reverse for additional exploration\n        c, d = np.random.choice(n, size=2, replace=False)\n        if c > d:\n            c, d = d, c\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment reversals, prioritizing nodes with high potential for multi-objective improvement while dynamically balancing exploration and exploitation through weighted objective scoring.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with edge swaps\n    for _ in range(3):\n        # Select segments based on objective improvement potential\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Reverse segment or swap edges based on weighted random decision\n        if np.random.rand() < 0.6:\n            # Reverse segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Edge swap\n            if b - a > 1:\n                c = np.random.randint(a+1, b)\n                new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Dynamic repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct tour from scratch with remaining nodes\n        missing = set(range(n)) - set(new_solution)\n        remaining = np.array(list(missing))\n        np.random.shuffle(remaining)\n        new_solution = np.concatenate([new_solution, remaining])\n\n    return new_solution\n\n",
        "score": [
            -0.9199231315567631,
            1.6013779044151306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with edge swaps\n    for _ in range(3):\n        # Select segments based on objective improvement potential\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Reverse segment or swap edges based on weighted random decision\n        if np.random.rand() < 0.6:\n            # Reverse segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Edge swap\n            if b - a > 1:\n                c = np.random.randint(a+1, b)\n                new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Dynamic repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct tour from scratch with remaining nodes\n        missing = set(range(n)) - set(new_solution)\n        remaining = np.array(list(missing))\n        np.random.shuffle(remaining)\n        new_solution = np.concatenate([new_solution, remaining])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with multi-objective-aware segment relocations, prioritizing edges with high potential for improvement while maintaining feasibility through a dynamic validation and repair mechanism, using a novel scoring function that considers both objective improvements and structural diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (emphasizing balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective-aware segment relocation\n    for _ in range(5):\n        # Calculate edge potential for both objectives\n        edge_potential = np.zeros(n)\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            edge_potential[i] = (distance_matrix_1[u][v] + distance_matrix_2[u][v]) / (objectives[selected_idx][0] + objectives[selected_idx][1])\n\n        # Select segments based on potential\n        sorted_edges = np.argsort(edge_potential)[-3:]\n        a, b, c = sorted_edges[0], sorted_edges[1], sorted_edges[2]\n\n        # Relocate segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8864717290109156,
            0.7786745429039001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (emphasizing balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective-aware segment relocation\n    for _ in range(5):\n        # Calculate edge potential for both objectives\n        edge_potential = np.zeros(n)\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            edge_potential[i] = (distance_matrix_1[u][v] + distance_matrix_2[u][v]) / (objectives[selected_idx][0] + objectives[selected_idx][1])\n\n        # Select segments based on potential\n        sorted_edges = np.argsort(edge_potential)[-3:]\n        a, b, c = sorted_edges[0], sorted_edges[1], sorted_edges[2]\n\n        # Relocate segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a biased edge insertion, prioritizing solutions with high Pareto dominance while ensuring feasibility by carefully maintaining the tour structure through node reinsertion at positions that improve both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = np.random.choice(len(archive_solutions))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: segment relocation + biased edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find best insertion point that improves both objectives\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            temp_solution = np.insert(new_solution, pos, segment)\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Biased edge insertion\n    if n > 2:\n        # Select a random node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        temp_solution = np.delete(new_solution, node_idx)\n\n        # Find best insertion point that improves at least one objective\n        best_pos = -1\n        best_gain = -float('inf')\n\n        for pos in range(len(temp_solution)):\n            # Insert node at position pos\n            candidate_solution = np.insert(temp_solution, pos, node)\n\n            # Calculate cost change for both objectives\n            if pos == 0:\n                cost1_change = (distance_matrix_1[candidate_solution[-1], node] +\n                               distance_matrix_1[node, candidate_solution[1]] -\n                               distance_matrix_1[candidate_solution[-1], candidate_solution[1]])\n                cost2_change = (distance_matrix_2[candidate_solution[-1], node] +\n                               distance_matrix_2[node, candidate_solution[1]] -\n                               distance_matrix_2[candidate_solution[-1], candidate_solution[1]])\n            else:\n                cost1_change = (distance_matrix_1[candidate_solution[pos-1], node] +\n                               distance_matrix_1[node, candidate_solution[pos+1]] -\n                               distance_matrix_1[candidate_solution[pos-1], candidate_solution[pos+1]])\n                cost2_change = (distance_matrix_2[candidate_solution[pos-1], node] +\n                               distance_matrix_2[node, candidate_solution[pos+1]] -\n                               distance_matrix_2[candidate_solution[pos-1], candidate_solution[pos+1]])\n\n            # Calculate gain (improvement in at least one objective)\n            gain = max(cost1_change, cost2_change)\n\n            if gain > best_gain:\n                best_gain = gain\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9283914644107629,
            8.50913780927658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = np.random.choice(len(archive_solutions))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: segment relocation + biased edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find best insertion point that improves both objectives\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            temp_solution = np.insert(new_solution, pos, segment)\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Biased edge insertion\n    if n > 2:\n        # Select a random node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        temp_solution = np.delete(new_solution, node_idx)\n\n        # Find best insertion point that improves at least one objective\n        best_pos = -1\n        best_gain = -float('inf')\n\n        for pos in range(len(temp_solution)):\n            # Insert node at position pos\n            candidate_solution = np.insert(temp_solution, pos, node)\n\n            # Calculate cost change for both objectives\n            if pos == 0:\n                cost1_change = (distance_matrix_1[candidate_solution[-1], node] +\n                               distance_matrix_1[node, candidate_solution[1]] -\n                               distance_matrix_1[candidate_solution[-1], candidate_solution[1]])\n                cost2_change = (distance_matrix_2[candidate_solution[-1], node] +\n                               distance_matrix_2[node, candidate_solution[1]] -\n                               distance_matrix_2[candidate_solution[-1], candidate_solution[1]])\n            else:\n                cost1_change = (distance_matrix_1[candidate_solution[pos-1], node] +\n                               distance_matrix_1[node, candidate_solution[pos+1]] -\n                               distance_matrix_1[candidate_solution[pos-1], candidate_solution[pos+1]])\n                cost2_change = (distance_matrix_2[candidate_solution[pos-1], node] +\n                               distance_matrix_2[node, candidate_solution[pos+1]] -\n                               distance_matrix_2[candidate_solution[pos-1], candidate_solution[pos+1]])\n\n            # Calculate gain (improvement in at least one objective)\n            gain = max(cost1_change, cost2_change)\n\n            if gain > best_gain:\n                best_gain = gain\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, favoring solutions with higher crowding distance or Pareto dominance in the archive to guide exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1) % n or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], node]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], node]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.783528140701333,
            1.3398572206497192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1) % n or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], node]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], node]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel adaptive segment crossover algorithm combines multi-objective edge selection with dynamic segment relocations, prioritizing high-impact edges while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover operation\n    for _ in range(3):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b = sorted([a, b])\n        c, d = sorted([c, d])\n\n        # Extract and swap segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            if np.random.rand() < 0.7:  # 70% chance to insert\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final check and truncate if needed\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        missing = list(set(range(n)) - set(new_solution))\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n",
        "score": [
            -0.8396109586663834,
            0.6805434226989746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover operation\n    for _ in range(3):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b = sorted([a, b])\n        c, d = sorted([c, d])\n\n        # Extract and swap segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            if np.random.rand() < 0.7:  # 70% chance to insert\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final check and truncate if needed\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        missing = list(set(range(n)) - set(new_solution))\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node reinsertion with a multi-objective aware segment crossover, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node reinsertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Multi-objective aware segment crossover\n    if n > 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate cost before crossover\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after crossover\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[b]]\n\n        # Accept crossover if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_segment = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[a:c], new_solution[d+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.822534240593814,
            0.9888812899589539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node reinsertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Step 2: Multi-objective aware segment crossover\n    if n > 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate cost before crossover\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after crossover\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[b]]\n\n        # Accept crossover if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_segment = new_solution[c:d+1]\n            new_solution = np.concatenate([new_solution[:a], new_segment, new_solution[a:c], new_solution[d+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive edge swapping with multi-objective aware segment inversion, dynamically prioritizing critical edges based on their contribution to both objectives while preserving feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores for both objectives\n    def calculate_edge_scores(sol, dist_mat):\n        scores = np.zeros(n)\n        for i in range(n):\n            u, v = sol[i], sol[(i+1)%n]\n            scores[i] = dist_mat[u, v]\n        return scores\n\n    scores1 = calculate_edge_scores(new_solution, distance_matrix_1)\n    scores2 = calculate_edge_scores(new_solution, distance_matrix_2)\n    combined_scores = scores1 + scores2\n\n    # Adaptive edge swapping and segment inversion\n    for _ in range(3):\n        # Select critical edges based on combined scores\n        top_edges = np.argsort(combined_scores)[-3:]\n        if len(top_edges) == 0:\n            break\n\n        # Perform edge swapping\n        for edge in top_edges:\n            i = edge\n            j = (i + 1) % n\n            if np.random.rand() < 0.7:  # 70% chance to swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Perform segment inversion with probability based on edge scores\n        if np.random.rand() < 0.5:\n            start = np.random.randint(0, n)\n            length = np.random.randint(2, min(5, n))\n            end = (start + length) % n\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[-end:], new_solution[end:start], segment[:-end]])\n\n        # Validate solution\n        if len(np.unique(new_solution)) != n:\n            # Probabilistic repair: restore order with higher probability for critical nodes\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                repair_pos = np.random.choice(np.argsort(combined_scores)[:3])\n                new_solution = np.insert(new_solution, repair_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9433668291993651,
            2.6395383477211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores for both objectives\n    def calculate_edge_scores(sol, dist_mat):\n        scores = np.zeros(n)\n        for i in range(n):\n            u, v = sol[i], sol[(i+1)%n]\n            scores[i] = dist_mat[u, v]\n        return scores\n\n    scores1 = calculate_edge_scores(new_solution, distance_matrix_1)\n    scores2 = calculate_edge_scores(new_solution, distance_matrix_2)\n    combined_scores = scores1 + scores2\n\n    # Adaptive edge swapping and segment inversion\n    for _ in range(3):\n        # Select critical edges based on combined scores\n        top_edges = np.argsort(combined_scores)[-3:]\n        if len(top_edges) == 0:\n            break\n\n        # Perform edge swapping\n        for edge in top_edges:\n            i = edge\n            j = (i + 1) % n\n            if np.random.rand() < 0.7:  # 70% chance to swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Perform segment inversion with probability based on edge scores\n        if np.random.rand() < 0.5:\n            start = np.random.randint(0, n)\n            length = np.random.randint(2, min(5, n))\n            end = (start + length) % n\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                segment = segment[::-1]\n                new_solution = np.concatenate([segment[-end:], new_solution[end:start], segment[:-end]])\n\n        # Validate solution\n        if len(np.unique(new_solution)) != n:\n            # Probabilistic repair: restore order with higher probability for critical nodes\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                repair_pos = np.random.choice(np.argsort(combined_scores)[:3])\n                new_solution = np.insert(new_solution, repair_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search algorithm combines guided edge swaps with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (alternative to sum)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(3):\n        # Select edges based on potential improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Swap edges and reverse segment between them\n        segment = new_solution[i:j][::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes at random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9193058914672892,
            1.8033896088600159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (alternative to sum)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(3):\n        # Select edges based on potential improvement\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Swap edges and reverse segment between them\n        segment = new_solution[i:j][::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes at random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This novel algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with high crowding distance to explore less crowded regions while ensuring feasibility through a feasibility-preserving relocation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = [solution[1][0] + solution[1][1] for solution in archive]\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Find insertion point that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = start\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < end:\n                continue\n\n            # Calculate cost for this insertion\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos + segment_length]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos + segment_length]]\n            elif pos == n - segment_length:\n                cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos + segment_length]]\n                cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos + segment_length]]\n\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Perform relocation\n        if best_pos != start:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[end:]\n            ])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.5 and b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8285423410950481,
            1.9747772216796875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = [solution[1][0] + solution[1][1] for solution in archive]\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Find insertion point that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = start\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < end:\n                continue\n\n            # Calculate cost for this insertion\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos + segment_length]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos + segment_length]]\n            elif pos == n - segment_length:\n                cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos + segment_length]]\n                cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos + segment_length]]\n\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Perform relocation\n        if best_pos != start:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[end:]\n            ])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.5 and b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This novel hybrid local search operator combines a multi-objective aware node relocation with a dynamic edge reversal mechanism, prioritizing solutions with high potential for improvement in both objectives while maintaining feasibility through a probabilistic validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (combined normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select nodes with high potential for improvement\n        node_scores = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            node_scores[i] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                             distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) / 2\n\n        worst_nodes = np.argsort(node_scores)[-min(3, n//2):]\n        for node_idx in worst_nodes:\n            # Relocate the node to a position that improves both objectives\n            best_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node_idx or pos == (node_idx-1)%n or pos == (node_idx+1)%n:\n                    continue\n\n                # Calculate improvement if we move node to position pos\n                prev_prev = new_solution[(pos-1)%n]\n                prev = new_solution[pos]\n                next = new_solution[(pos+1)%n]\n                node = new_solution[node_idx]\n\n                original_cost1 = (distance_matrix_1[prev_prev, prev] + distance_matrix_1[prev, next] +\n                                 distance_matrix_1[node, new_solution[(node_idx-1)%n]] + distance_matrix_1[new_solution[(node_idx+1)%n], node])\n                new_cost1 = (distance_matrix_1[prev_prev, node] + distance_matrix_1[node, prev] +\n                            distance_matrix_1[prev, next] + distance_matrix_1[new_solution[(node_idx-1)%n], new_solution[(node_idx+1)%n]])\n\n                original_cost2 = (distance_matrix_2[prev_prev, prev] + distance_matrix_2[prev, next] +\n                                 distance_matrix_2[node, new_solution[(node_idx-1)%n]] + distance_matrix_2[new_solution[(node_idx+1)%n], node])\n                new_cost2 = (distance_matrix_2[prev_prev, node] + distance_matrix_2[node, prev] +\n                            distance_matrix_2[prev, next] + distance_matrix_2[new_solution[(node_idx-1)%n], new_solution[(node_idx+1)%n]])\n\n                improvement = (original_cost1 - new_cost1 + original_cost2 - new_cost2) / 2\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1 and best_improvement > 0:\n                # Perform the relocation\n                node = new_solution[node_idx]\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic edge reversal mechanism\n    if n > 2:\n        # Select edges with high potential for improvement\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            edge_scores[i] = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]) / 2\n\n        worst_edges = np.argsort(edge_scores)[-min(3, n//2):]\n        for edge_idx in worst_edges:\n            # Reverse the edge if it improves both objectives\n            prev_node = new_solution[edge_idx-1]\n            next_node = new_solution[edge_idx]\n\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n\n            new_cost1 = distance_matrix_1[next_node, prev_node]\n            new_cost2 = distance_matrix_2[next_node, prev_node]\n\n            if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n                new_solution[edge_idx-1], new_solution[edge_idx] = new_solution[edge_idx], new_solution[edge_idx-1]\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, randomly shuffle missing nodes and insert them\n        missing = list(set(range(n)) - set(new_solution))\n        np.random.shuffle(missing)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8486676382006177,
            4.721861720085144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (combined normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select nodes with high potential for improvement\n        node_scores = np.zeros(n)\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            node_scores[i] = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                             distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]) / 2\n\n        worst_nodes = np.argsort(node_scores)[-min(3, n//2):]\n        for node_idx in worst_nodes:\n            # Relocate the node to a position that improves both objectives\n            best_pos = -1\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node_idx or pos == (node_idx-1)%n or pos == (node_idx+1)%n:\n                    continue\n\n                # Calculate improvement if we move node to position pos\n                prev_prev = new_solution[(pos-1)%n]\n                prev = new_solution[pos]\n                next = new_solution[(pos+1)%n]\n                node = new_solution[node_idx]\n\n                original_cost1 = (distance_matrix_1[prev_prev, prev] + distance_matrix_1[prev, next] +\n                                 distance_matrix_1[node, new_solution[(node_idx-1)%n]] + distance_matrix_1[new_solution[(node_idx+1)%n], node])\n                new_cost1 = (distance_matrix_1[prev_prev, node] + distance_matrix_1[node, prev] +\n                            distance_matrix_1[prev, next] + distance_matrix_1[new_solution[(node_idx-1)%n], new_solution[(node_idx+1)%n]])\n\n                original_cost2 = (distance_matrix_2[prev_prev, prev] + distance_matrix_2[prev, next] +\n                                 distance_matrix_2[node, new_solution[(node_idx-1)%n]] + distance_matrix_2[new_solution[(node_idx+1)%n], node])\n                new_cost2 = (distance_matrix_2[prev_prev, node] + distance_matrix_2[node, prev] +\n                            distance_matrix_2[prev, next] + distance_matrix_2[new_solution[(node_idx-1)%n], new_solution[(node_idx+1)%n]])\n\n                improvement = (original_cost1 - new_cost1 + original_cost2 - new_cost2) / 2\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1 and best_improvement > 0:\n                # Perform the relocation\n                node = new_solution[node_idx]\n                new_solution = np.delete(new_solution, node_idx)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic edge reversal mechanism\n    if n > 2:\n        # Select edges with high potential for improvement\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            edge_scores[i] = (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]) / 2\n\n        worst_edges = np.argsort(edge_scores)[-min(3, n//2):]\n        for edge_idx in worst_edges:\n            # Reverse the edge if it improves both objectives\n            prev_node = new_solution[edge_idx-1]\n            next_node = new_solution[edge_idx]\n\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n\n            new_cost1 = distance_matrix_1[next_node, prev_node]\n            new_cost2 = distance_matrix_2[next_node, prev_node]\n\n            if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n                new_solution[edge_idx-1], new_solution[edge_idx] = new_solution[edge_idx], new_solution[edge_idx-1]\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, randomly shuffle missing nodes and insert them\n        missing = list(set(range(n)) - set(new_solution))\n        np.random.shuffle(missing)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{An adaptive hybrid local search operator that combines a multi-objective aware segment relocation with a randomized edge crossover, dynamically adjusting the search intensity based on the solution's position in the Pareto front and its crowding distance to explore both diverse and high-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that improves at least one objective\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n\n            # Calculate cost after insertion\n            new_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_1[segment[-1], new_solution[pos]] if pos < n else 0)\n            new_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_2[segment[-1], new_solution[pos]] if pos < n else 0)\n\n            # Total cost comparison\n            if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n                if new_cost1 + new_cost2 < min_cost:\n                    min_cost = new_cost1 + new_cost2\n                    best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate((new_solution[:best_pos], segment, new_solution[best_pos:]))\n            new_solution = np.delete(new_solution, np.s_[best_pos+len(segment):best_pos+2*len(segment)])\n\n    # Step 2: Randomized edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Randomly decide to cross edges\n        if np.random.random() < 0.3:\n            # Calculate cost before crossover\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after crossover\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5520502195891237,
            0.5174494981765747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that improves at least one objective\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n\n            # Calculate cost after insertion\n            new_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_1[segment[-1], new_solution[pos]] if pos < n else 0)\n            new_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_2[segment[-1], new_solution[pos]] if pos < n else 0)\n\n            # Total cost comparison\n            if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n                if new_cost1 + new_cost2 < min_cost:\n                    min_cost = new_cost1 + new_cost2\n                    best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate((new_solution[:best_pos], segment, new_solution[best_pos:]))\n            new_solution = np.delete(new_solution, np.s_[best_pos+len(segment):best_pos+2*len(segment)])\n\n    # Step 2: Randomized edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Randomly decide to cross edges\n        if np.random.random() < 0.3:\n            # Calculate cost before crossover\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after crossover\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{An adaptive hybrid local search operator that combines a multi-objective aware segment relocation with a randomized edge crossover, dynamically adjusting the search intensity based on the solution's position in the Pareto front and its crowding distance to explore both diverse and high-quality regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that improves at least one objective\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n\n            # Calculate cost after insertion\n            new_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_1[segment[-1], new_solution[pos]] if pos < n else 0)\n            new_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_2[segment[-1], new_solution[pos]] if pos < n else 0)\n\n            # Total cost comparison\n            if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n                if new_cost1 + new_cost2 < min_cost:\n                    min_cost = new_cost1 + new_cost2\n                    best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate((new_solution[:best_pos], segment, new_solution[best_pos:]))\n            new_solution = np.delete(new_solution, np.s_[best_pos+len(segment):best_pos+2*len(segment)])\n\n    # Step 2: Randomized edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Randomly decide to cross edges\n        if np.random.random() < 0.3:\n            # Calculate cost before crossover\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after crossover\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5520502195891237,
            0.5174494981765747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that improves at least one objective\n        min_cost = float('inf')\n        best_pos = -1\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] if pos > 0 else 0\n\n            # Calculate cost after insertion\n            new_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_1[segment[-1], new_solution[pos]] if pos < n else 0)\n            new_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] if pos > 0 else 0) + \\\n                        (distance_matrix_2[segment[-1], new_solution[pos]] if pos < n else 0)\n\n            # Total cost comparison\n            if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n                if new_cost1 + new_cost2 < min_cost:\n                    min_cost = new_cost1 + new_cost2\n                    best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate((new_solution[:best_pos], segment, new_solution[best_pos:]))\n            new_solution = np.delete(new_solution, np.s_[best_pos+len(segment):best_pos+2*len(segment)])\n\n    # Step 2: Randomized edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Randomly decide to cross edges\n        if np.random.random() < 0.3:\n            # Calculate cost before crossover\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after crossover\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel local search operator that combines a multi-objective aware node relocation with a dynamic edge reversal, prioritizing solutions with high crowding distance while maintaining feasibility by ensuring no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        # Calculate cost after relocation\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept relocation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate((new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]))\n\n    # Step 2: Dynamic edge reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution[a:b] = reversed_segment\n\n        # Calculate cost before and after reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b%n]]\n\n        # Revert if reversal worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution[a:b] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.9795023860166037,
            1.2291456460952759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        # Calculate cost after relocation\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept relocation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate((new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]))\n\n    # Step 2: Dynamic edge reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n        new_solution[a:b] = reversed_segment\n\n        # Calculate cost before and after reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b%n]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b%n]]\n\n        # Revert if reversal worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution[a:b] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7360257339381818,
            1.639225959777832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swaps with multi-objective-aware segment reversals, prioritizing edges with high potential for Pareto improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with segment reversal\n    for _ in range(5):\n        # Select two segments to swap\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_cost < current_cost:\n            # Perform swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Reverse segment between a and b with probability 0.5\n            if np.random.rand() < 0.5:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9531800147462437,
            2.0708290338516235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with segment reversal\n    for _ in range(5):\n        # Select two segments to swap\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if new_cost < current_cost:\n            # Perform swap\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # Reverse segment between a and b with probability 0.5\n            if np.random.rand() < 0.5:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment merging with multi-objective edge swapping, where segments are dynamically selected based on their potential improvement in both objectives, and edge swaps are guided by Pareto dominance relationships in the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging and edge swapping\n    for _ in range(5):\n        # Randomly select segments to merge\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Merge segments [a, b] and [b+1, c]\n        merged_segment = np.concatenate([new_solution[a:b+1], new_solution[b+1:c+1]])\n\n        # Find Pareto-dominant edges to swap\n        for i in range(len(merged_segment)-1):\n            for j in range(i+1, len(merged_segment)):\n                u, v = merged_segment[i], merged_segment[j]\n                if (distance_matrix_1[u, v] < distance_matrix_1[merged_segment[i], merged_segment[i+1]] and\n                    distance_matrix_2[u, v] < distance_matrix_2[merged_segment[i], merged_segment[i+1]]):\n                    merged_segment[i+1], merged_segment[j] = merged_segment[j], merged_segment[i+1]\n                    break\n\n        new_solution = np.concatenate([new_solution[:a], merged_segment, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8029596677837475,
            4.801461458206177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment merging and edge swapping\n    for _ in range(5):\n        # Randomly select segments to merge\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Merge segments [a, b] and [b+1, c]\n        merged_segment = np.concatenate([new_solution[a:b+1], new_solution[b+1:c+1]])\n\n        # Find Pareto-dominant edges to swap\n        for i in range(len(merged_segment)-1):\n            for j in range(i+1, len(merged_segment)):\n                u, v = merged_segment[i], merged_segment[j]\n                if (distance_matrix_1[u, v] < distance_matrix_1[merged_segment[i], merged_segment[i+1]] and\n                    distance_matrix_2[u, v] < distance_matrix_2[merged_segment[i], merged_segment[i+1]]):\n                    merged_segment[i+1], merged_segment[j] = merged_segment[j], merged_segment[i+1]\n                    break\n\n        new_solution = np.concatenate([new_solution[:a], merged_segment, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware segment relocation, favoring solutions with high crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Multi-objective aware segment relocation\n    if n > 4:\n        start = np.random.randint(0, n-3)\n        length = np.random.randint(2, min(4, n-start))\n        end = start + length\n\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, slice(start, end))\n\n        insert_pos = np.random.randint(0, n-length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Evaluate the change\n        original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n        original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n\n        new_cost1 = distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]] + distance_matrix_1[new_solution[insert_pos+length-1], new_solution[insert_pos+length]]\n        new_cost2 = distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]] + distance_matrix_2[new_solution[insert_pos+length-1], new_solution[insert_pos+length]]\n\n        # Revert if not improving at least one objective\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = np.delete(new_solution, slice(insert_pos, insert_pos+length))\n            new_solution = np.insert(new_solution, start, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8461630600101241,
            2.1047123670578003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Multi-objective aware segment relocation\n    if n > 4:\n        start = np.random.randint(0, n-3)\n        length = np.random.randint(2, min(4, n-start))\n        end = start + length\n\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, slice(start, end))\n\n        insert_pos = np.random.randint(0, n-length)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Evaluate the change\n        original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n        original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n\n        new_cost1 = distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]] + distance_matrix_1[new_solution[insert_pos+length-1], new_solution[insert_pos+length]]\n        new_cost2 = distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]] + distance_matrix_2[new_solution[insert_pos+length-1], new_solution[insert_pos+length]]\n\n        # Revert if not improving at least one objective\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = np.delete(new_solution, slice(insert_pos, insert_pos+length))\n            new_solution = np.insert(new_solution, start, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware path decomposition with a guided segment crossover, prioritizing segments with high potential for improvement while maintaining feasibility through a dynamic path validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware path decomposition\n    decomposition_points = sorted(np.random.choice(n, size=3, replace=False))\n    a, b, c = decomposition_points\n\n    # Guided segment crossover\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Calculate potential improvement for each objective\n    def segment_cost(seg, matrix):\n        cost = 0\n        for i in range(len(seg)-1):\n            cost += matrix[seg[i], seg[i+1]]\n        cost += matrix[seg[-1], seg[0]]  # closed loop\n        return cost\n\n    cost1_orig = segment_cost(segment1, distance_matrix_1) + segment_cost(segment2, distance_matrix_1)\n    cost2_orig = segment_cost(segment2, distance_matrix_2) + segment_cost(segment1, distance_matrix_2)\n\n    # Try swapping segments\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct the tour by removing duplicates and adding missing nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        missing = list(set(range(n)) - set(new_solution))\n\n        for dup in duplicates:\n            # Find and remove one occurrence of the duplicate\n            indices = np.where(new_solution == dup)[0][1:]\n            for idx in indices:\n                if missing:\n                    new_solution[idx] = missing.pop(0)\n                else:\n                    # If no missing nodes, swap with a random position\n                    swap_pos = np.random.randint(0, n)\n                    new_solution[idx], new_solution[swap_pos] = new_solution[swap_pos], new_solution[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8330777089717838,
            2.1506506204605103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware path decomposition\n    decomposition_points = sorted(np.random.choice(n, size=3, replace=False))\n    a, b, c = decomposition_points\n\n    # Guided segment crossover\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Calculate potential improvement for each objective\n    def segment_cost(seg, matrix):\n        cost = 0\n        for i in range(len(seg)-1):\n            cost += matrix[seg[i], seg[i+1]]\n        cost += matrix[seg[-1], seg[0]]  # closed loop\n        return cost\n\n    cost1_orig = segment_cost(segment1, distance_matrix_1) + segment_cost(segment2, distance_matrix_1)\n    cost2_orig = segment_cost(segment2, distance_matrix_2) + segment_cost(segment1, distance_matrix_2)\n\n    # Try swapping segments\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct the tour by removing duplicates and adding missing nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        missing = list(set(range(n)) - set(new_solution))\n\n        for dup in duplicates:\n            # Find and remove one occurrence of the duplicate\n            indices = np.where(new_solution == dup)[0][1:]\n            for idx in indices:\n                if missing:\n                    new_solution[idx] = missing.pop(0)\n                else:\n                    # If no missing nodes, swap with a random position\n                    swap_pos = np.random.randint(0, n)\n                    new_solution[idx], new_solution[swap_pos] = new_solution[swap_pos], new_solution[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{A novel hybrid local search algorithm combines edge rotations with adaptive segment inversions, prioritizing nodes with high potential for multi-objective improvement through a weighted objective score function, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score (alpha=0.7)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Higher weight for first objective\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge rotation with adaptive segment inversion\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Rotate segment [a, b] and invert segment [b+1, c]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1][::-1]\n        new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8254112958567674,
            0.7920272350311279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective score (alpha=0.7)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Higher weight for first objective\n    weighted_scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge rotation with adaptive segment inversion\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Rotate segment [a, b] and invert segment [b+1, c]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1][::-1]\n        new_solution = np.concatenate([new_solution[:a], segment1, segment2, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment reversal with a multi-objective edge insertion, weighted by the solution's dominance rank and crowding distance to guide exploration of high-potential regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank and crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment reversal\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(1, n-2)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-2)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Weighted acceptance based on dominance rank and crowding distance\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Insert node j between i and i+1\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:]])\n            new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    return new_solution\n\n",
        "score": [
            -0.8127327574794273,
            2.269538700580597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank and crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment reversal\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Multi-objective edge insertion\n    if n > 3:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(1, n-2)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-2)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Weighted acceptance based on dominance rank and crowding distance\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Insert node j between i and i+1\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:]])\n            new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{A novel hybrid local search algorithm combines a dynamic node clustering with guided path reconstruction, where nodes are grouped based on their multi-objective proximity and then reconstructed into paths that optimize both objectives simultaneously while maintaining tour feasibility through a probabilistic acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic node clustering based on multi-objective proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined distance to current cluster\n        d1 = np.mean([distance_matrix_1[new_solution[i], node] for node in current_cluster])\n        d2 = np.mean([distance_matrix_2[new_solution[i], node] for node in current_cluster])\n        combined_distance = d1 + d2\n\n        # Probabilistic acceptance for clustering\n        if combined_distance < np.random.uniform(0.5, 1.5) * np.mean([d1, d2]):\n            current_cluster.append(new_solution[i])\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reconstruct paths from clusters\n    reconstructed = []\n    for cluster in clusters:\n        # Sort nodes in cluster based on combined distance to first node\n        sorted_cluster = sorted(cluster, key=lambda x: distance_matrix_1[x, cluster[0]] + distance_matrix_2[x, cluster[0]])\n        reconstructed.extend(sorted_cluster)\n\n    # Ensure feasibility\n    if len(np.unique(reconstructed)) == n:\n        new_solution = np.array(reconstructed)\n    else:\n        # Fallback to simple repair if needed\n        missing = set(range(n)) - set(reconstructed)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(reconstructed))\n            reconstructed.insert(insert_pos, node)\n        new_solution = np.array(reconstructed)\n\n    return new_solution\n\n",
        "score": [
            -0.9172932847794313,
            5.9285653829574585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic node clustering based on multi-objective proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate combined distance to current cluster\n        d1 = np.mean([distance_matrix_1[new_solution[i], node] for node in current_cluster])\n        d2 = np.mean([distance_matrix_2[new_solution[i], node] for node in current_cluster])\n        combined_distance = d1 + d2\n\n        # Probabilistic acceptance for clustering\n        if combined_distance < np.random.uniform(0.5, 1.5) * np.mean([d1, d2]):\n            current_cluster.append(new_solution[i])\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Reconstruct paths from clusters\n    reconstructed = []\n    for cluster in clusters:\n        # Sort nodes in cluster based on combined distance to first node\n        sorted_cluster = sorted(cluster, key=lambda x: distance_matrix_1[x, cluster[0]] + distance_matrix_2[x, cluster[0]])\n        reconstructed.extend(sorted_cluster)\n\n    # Ensure feasibility\n    if len(np.unique(reconstructed)) == n:\n        new_solution = np.array(reconstructed)\n    else:\n        # Fallback to simple repair if needed\n        missing = set(range(n)) - set(reconstructed)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(reconstructed))\n            reconstructed.insert(insert_pos, node)\n        new_solution = np.array(reconstructed)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{A novel hybrid local search algorithm combines a multi-objective aware node relocation strategy with a dynamic segment reversal mechanism, leveraging both Pareto dominance and crowding distance to guide the search toward high-quality solutions while ensuring feasibility through a comprehensive validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        crowding_distances = np.zeros(len(pareto_front))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[pareto_front, m])\n            crowding_distances[sorted_idx[0]] = crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(pareto_front)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[pareto_front[sorted_idx[i+1]], m] -\n                                                     objectives[pareto_front[sorted_idx[i-1]], m])\n\n        selected_idx = pareto_front[np.argmax(crowding_distances)]\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with dynamic segment reversal\n    for _ in range(3):\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate potential insertion positions based on both objectives\n        insertion_costs = []\n        for pos in range(n):\n            if pos == node_idx or (pos == node_idx + 1) or (pos == node_idx - 1):\n                continue\n\n            # Calculate cost in both objectives\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n                cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n            elif pos == n-1:\n                cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos+1]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos+1]]\n\n            insertion_costs.append((cost1, cost2, pos))\n\n        # Sort by combined cost (weighted sum of objectives)\n        weights = np.random.dirichlet([1, 1])\n        weighted_costs = [c1*weights[0] + c2*weights[1] for c1, c2, _ in insertion_costs]\n        best_pos = insertion_costs[np.argmin(weighted_costs)][2]\n\n        # Relocate the node\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Dynamic segment reversal\n        if np.random.random() < 0.3:\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Create a valid tour by restoring missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7442886253148311,
            4.179706871509552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        crowding_distances = np.zeros(len(pareto_front))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[pareto_front, m])\n            crowding_distances[sorted_idx[0]] = crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(pareto_front)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[pareto_front[sorted_idx[i+1]], m] -\n                                                     objectives[pareto_front[sorted_idx[i-1]], m])\n\n        selected_idx = pareto_front[np.argmax(crowding_distances)]\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with dynamic segment reversal\n    for _ in range(3):\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate potential insertion positions based on both objectives\n        insertion_costs = []\n        for pos in range(n):\n            if pos == node_idx or (pos == node_idx + 1) or (pos == node_idx - 1):\n                continue\n\n            # Calculate cost in both objectives\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n                cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n            elif pos == n-1:\n                cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos+1]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos+1]]\n\n            insertion_costs.append((cost1, cost2, pos))\n\n        # Sort by combined cost (weighted sum of objectives)\n        weights = np.random.dirichlet([1, 1])\n        weighted_costs = [c1*weights[0] + c2*weights[1] for c1, c2, _ in insertion_costs]\n        best_pos = insertion_costs[np.argmin(weighted_costs)][2]\n\n        # Relocate the node\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Dynamic segment reversal\n        if np.random.random() < 0.3:\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Create a valid tour by restoring missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines guided edge swaps with dynamic segment inversions, prioritizing improvements in both objectives while maintaining feasibility through a probabilistic validation framework.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized[:, 0] * normalized[:, 1]  # Product for combined improvement\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: guided edge swaps with dynamic segment inversions\n    for _ in range(5):\n        # Select edges with high potential for improvement in both objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate improvement potential for both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.9 and new_cost2 < old_cost2 * 1.1) or \\\n           (new_cost2 < old_cost2 * 0.9 and new_cost1 < old_cost1 * 1.1):\n\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # With probability, invert a segment between the swapped edges\n            if np.random.random() < 0.3:\n                a, b = sorted([i, j])\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() < 0.7:  # 70% chance to insert at optimal position\n                # Find position that minimizes both objectives\n                min_cost = float('inf')\n                best_pos = 0\n                for pos in range(n):\n                    if pos > 0:\n                        cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                        cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                        if cost1 + cost2 < min_cost:\n                            min_cost = cost1 + cost2\n                            best_pos = pos\n                    else:\n                        cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n                        cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n                        if cost1 + cost2 < min_cost:\n                            min_cost = cost1 + cost2\n                            best_pos = 0\n                new_solution = np.insert(new_solution, best_pos, node)\n            else:\n                # Random insertion\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8873352481995012,
            2.533625841140747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized[:, 0] * normalized[:, 1]  # Product for combined improvement\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: guided edge swaps with dynamic segment inversions\n    for _ in range(5):\n        # Select edges with high potential for improvement in both objectives\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate improvement potential for both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.9 and new_cost2 < old_cost2 * 1.1) or \\\n           (new_cost2 < old_cost2 * 0.9 and new_cost1 < old_cost1 * 1.1):\n\n            # Perform edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # With probability, invert a segment between the swapped edges\n            if np.random.random() < 0.3:\n                a, b = sorted([i, j])\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() < 0.7:  # 70% chance to insert at optimal position\n                # Find position that minimizes both objectives\n                min_cost = float('inf')\n                best_pos = 0\n                for pos in range(n):\n                    if pos > 0:\n                        cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                        cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                        if cost1 + cost2 < min_cost:\n                            min_cost = cost1 + cost2\n                            best_pos = pos\n                    else:\n                        cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n                        cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n                        if cost1 + cost2 < min_cost:\n                            min_cost = cost1 + cost2\n                            best_pos = 0\n                new_solution = np.insert(new_solution, best_pos, node)\n            else:\n                # Random insertion\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block relocation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized block relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8580983587389475,
            2.5145936012268066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized block relocation + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, block)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, leveraging solution diversity and Pareto dominance to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        segment = np.roll(new_solution, -k)\n        new_solution = np.concatenate([segment[:k], new_solution[k:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1) % n or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n",
        "score": [
            -0.9609076594839556,
            0.3972446322441101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        segment = np.roll(new_solution, -k)\n        new_solution = np.concatenate([segment[:k], new_solution[k:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1) % n or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, leveraging solution diversity and Pareto dominance to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        segment = np.roll(new_solution, -k)\n        new_solution = np.concatenate([segment[:k], new_solution[k:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1) % n or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n",
        "score": [
            -0.9609076594839556,
            0.3972446322441101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        segment = np.roll(new_solution, -k)\n        new_solution = np.concatenate([segment[:k], new_solution[k:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1) % n or j == (i+1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{A novel hybrid local search operator that combines a randomized 3-opt move with a multi-objective aware node insertion, leveraging edge dominance and crowding distance to guide exploration toward high-quality regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 3-opt move\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate((segment2, segment1))\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7727074142194209,
            1.6454455256462097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized 3-opt move\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate((segment2, segment1))\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 4:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment shuffling with multi-objective-aware edge insertion, prioritizing segments that show potential for improvement in both objectives while maintaining feasibility through a dynamic segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment shuffling with multi-objective edge insertion\n    for _ in range(5):\n        # Identify segments with potential for improvement\n        segment_length = max(2, n // 5)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length - 1\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Shuffle the segment\n        segment = new_solution[a:b+1].copy()\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            break\n\n    # Edge insertion with multi-objective awareness\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i == j:\n            j = (j + 1) % (n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Perform insertion\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if no improvement\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            # Undo insertion\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9101097659779676,
            1.8188278675079346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment shuffling with multi-objective edge insertion\n    for _ in range(5):\n        # Identify segments with potential for improvement\n        segment_length = max(2, n // 5)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length - 1\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Shuffle the segment\n        segment = new_solution[a:b+1].copy()\n        np.random.shuffle(segment)\n        new_solution[a:b+1] = segment\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            break\n\n    # Edge insertion with multi-objective awareness\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i == j:\n            j = (j + 1) % (n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Perform insertion\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if no improvement\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            # Undo insertion\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{An adaptive segment-based local search algorithm that combines dynamic segment extraction with multi-objective aware edge flipping, using a hybrid selection criterion that balances objective improvement and solution diversity while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion: blend of objective improvement and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_scores = normalized.sum(axis=1)\n\n    # Calculate diversity scores (crowding distance approximation)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        diversity_scores[i] = np.mean(np.sort(distances)[:3])\n\n    # Combine scores with adaptive weighting\n    alpha = 0.7 if np.random.random() > 0.5 else 0.3  # Dynamic weighting\n    combined_scores = alpha * improvement_scores + (1 - alpha) * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment extraction\n    segment_length = max(2, min(5, np.random.randint(1, n//2)))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Multi-objective aware edge flipping\n    for i in range(len(segment)-1):\n        for j in range(i+1, len(segment)):\n            # Calculate cost before flip\n            orig_cost1 = (distance_matrix_1[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                         distance_matrix_1[segment[j-1], segment[j]] + \\\n                         (distance_matrix_1[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n            orig_cost2 = (distance_matrix_2[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                         distance_matrix_2[segment[j-1], segment[j]] + \\\n                         (distance_matrix_2[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n\n            # Flip edges\n            segment[i], segment[j] = segment[j], segment[i]\n\n            # Calculate cost after flip\n            new_cost1 = (distance_matrix_1[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                        distance_matrix_1[segment[j-1], segment[j]] + \\\n                        (distance_matrix_1[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n            new_cost2 = (distance_matrix_2[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                        distance_matrix_2[segment[j-1], segment[j]] + \\\n                        (distance_matrix_2[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n\n            # Accept flip if at least one objective improves\n            if not ((new_cost1 < orig_cost1) or (new_cost2 < orig_cost2)):\n                segment[i], segment[j] = segment[j], segment[i]  # Revert\n\n    # Update the solution with the modified segment\n    new_solution[start:start+segment_length] = segment\n\n    # Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() > 0.3:  # 70% chance to insert\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Create a new random tour if repair fails\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
        "score": [
            -0.9214783219860836,
            9.024657905101776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion: blend of objective improvement and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_scores = normalized.sum(axis=1)\n\n    # Calculate diversity scores (crowding distance approximation)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        diversity_scores[i] = np.mean(np.sort(distances)[:3])\n\n    # Combine scores with adaptive weighting\n    alpha = 0.7 if np.random.random() > 0.5 else 0.3  # Dynamic weighting\n    combined_scores = alpha * improvement_scores + (1 - alpha) * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment extraction\n    segment_length = max(2, min(5, np.random.randint(1, n//2)))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Multi-objective aware edge flipping\n    for i in range(len(segment)-1):\n        for j in range(i+1, len(segment)):\n            # Calculate cost before flip\n            orig_cost1 = (distance_matrix_1[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                         distance_matrix_1[segment[j-1], segment[j]] + \\\n                         (distance_matrix_1[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n            orig_cost2 = (distance_matrix_2[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                         distance_matrix_2[segment[j-1], segment[j]] + \\\n                         (distance_matrix_2[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n\n            # Flip edges\n            segment[i], segment[j] = segment[j], segment[i]\n\n            # Calculate cost after flip\n            new_cost1 = (distance_matrix_1[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                        distance_matrix_1[segment[j-1], segment[j]] + \\\n                        (distance_matrix_1[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n            new_cost2 = (distance_matrix_2[segment[i-1], segment[i]] if i > 0 else 0) + \\\n                        distance_matrix_2[segment[j-1], segment[j]] + \\\n                        (distance_matrix_2[segment[i], segment[i+1]] if i+1 < len(segment) else 0)\n\n            # Accept flip if at least one objective improves\n            if not ((new_cost1 < orig_cost1) or (new_cost2 < orig_cost2)):\n                segment[i], segment[j] = segment[j], segment[i]  # Revert\n\n    # Update the solution with the modified segment\n    new_solution[start:start+segment_length] = segment\n\n    # Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.random() > 0.3:  # 70% chance to insert\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # Create a new random tour if repair fails\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node reinsertion with a multi-objective aware 2-opt move, prioritizing solutions with high crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node reinsertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 2-opt move\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before 2-opt\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after 2-opt\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept 2-opt if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8624279843442186,
            1.608614444732666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node reinsertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 2-opt move\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before 2-opt\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after 2-opt\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept 2-opt if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This novel algorithm combines a multi-objective aware path decomposition with a guided node exchange mechanism, where the solution is split into segments based on Pareto dominance and then optimized through targeted node swaps that prioritize both objectives while maintaining feasibility through a dynamic segment validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path decomposition and guided node exchange\n    if n > 4:\n        # Split into segments based on objective improvement potential\n        segment_size = max(2, n // 4)\n        segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n        for seg_idx in range(len(segments)-1):\n            seg1 = segments[seg_idx]\n            seg2 = segments[seg_idx+1]\n\n            # Find nodes with potential for improvement\n            candidates1 = [i for i in range(len(seg1)) if np.random.rand() < 0.3]\n            candidates2 = [i for i in range(len(seg2)) if np.random.rand() < 0.3]\n\n            for i in candidates1:\n                for j in candidates2:\n                    # Calculate cost before swap\n                    pos1 = np.where(new_solution == seg1[i])[0][0]\n                    pos2 = np.where(new_solution == seg2[j])[0][0]\n\n                    original_cost1 = (distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] +\n                                     distance_matrix_1[new_solution[pos2-1], new_solution[pos2]])\n                    original_cost2 = (distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] +\n                                     distance_matrix_2[new_solution[pos2-1], new_solution[pos2]])\n\n                    # Calculate cost after swap\n                    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n                    new_cost1 = (distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] +\n                                distance_matrix_1[new_solution[pos2-1], new_solution[pos2]])\n                    new_cost2 = (distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] +\n                                distance_matrix_2[new_solution[pos2-1], new_solution[pos2]])\n\n                    # Accept if improves at least one objective\n                    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                        break\n                    else:\n                        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore missing nodes in order\n        missing = sorted(set(range(n)) - set(new_solution))\n        insert_pos = np.random.randint(0, n)\n        for node in missing:\n            new_solution = np.insert(new_solution, insert_pos, node)\n            insert_pos = np.random.randint(0, len(new_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.7022694100348831,
            2.360675096511841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path decomposition and guided node exchange\n    if n > 4:\n        # Split into segments based on objective improvement potential\n        segment_size = max(2, n // 4)\n        segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n        for seg_idx in range(len(segments)-1):\n            seg1 = segments[seg_idx]\n            seg2 = segments[seg_idx+1]\n\n            # Find nodes with potential for improvement\n            candidates1 = [i for i in range(len(seg1)) if np.random.rand() < 0.3]\n            candidates2 = [i for i in range(len(seg2)) if np.random.rand() < 0.3]\n\n            for i in candidates1:\n                for j in candidates2:\n                    # Calculate cost before swap\n                    pos1 = np.where(new_solution == seg1[i])[0][0]\n                    pos2 = np.where(new_solution == seg2[j])[0][0]\n\n                    original_cost1 = (distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] +\n                                     distance_matrix_1[new_solution[pos2-1], new_solution[pos2]])\n                    original_cost2 = (distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] +\n                                     distance_matrix_2[new_solution[pos2-1], new_solution[pos2]])\n\n                    # Calculate cost after swap\n                    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n                    new_cost1 = (distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] +\n                                distance_matrix_1[new_solution[pos2-1], new_solution[pos2]])\n                    new_cost2 = (distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] +\n                                distance_matrix_2[new_solution[pos2-1], new_solution[pos2]])\n\n                    # Accept if improves at least one objective\n                    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                        break\n                    else:\n                        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore missing nodes in order\n        missing = sorted(set(range(n)) - set(new_solution))\n        insert_pos = np.random.randint(0, n)\n        for node in missing:\n            new_solution = np.insert(new_solution, insert_pos, node)\n            insert_pos = np.random.randint(0, len(new_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node insertion with a dynamic edge reversal, prioritizing solutions with high hypervolume contribution while ensuring feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = objectives.max(axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and \\\n               (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        hv_contributions.append((ref_point[0] - objectives[i, 0]) * (ref_point[1] - objectives[i, 1]) / (dominated + 1))\n\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node insertion with dynamic edge reversal\n    if n > 3:\n        # Select a node to remove and reinsert\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n        new_solution = np.delete(new_solution, node_to_remove)\n\n        # Find best insertion position based on multi-objective criteria\n        best_pos = 0\n        best_score = -np.inf\n        for pos in range(n-1):\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[pos-1], removed_node] + distance_matrix_1[removed_node, new_solution[pos]] + \\\n                        distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], removed_node] + distance_matrix_2[removed_node, new_solution[pos]] + \\\n                        distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n\n            # Score based on improvement in both objectives\n            score = (original_cost1 - new_cost1) * (original_cost2 - new_cost2)\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the node at best position\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n        # Dynamic edge reversal\n        if np.random.random() < 0.3:  # 30% chance to reverse a segment\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            if b - a > 1:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4488153513610217,
            3.3637874722480774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = objectives.max(axis=0) * 1.1\n    hv_contributions = []\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and \\\n               (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        hv_contributions.append((ref_point[0] - objectives[i, 0]) * (ref_point[1] - objectives[i, 1]) / (dominated + 1))\n\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node insertion with dynamic edge reversal\n    if n > 3:\n        # Select a node to remove and reinsert\n        node_to_remove = np.random.randint(0, n)\n        removed_node = new_solution[node_to_remove]\n        new_solution = np.delete(new_solution, node_to_remove)\n\n        # Find best insertion position based on multi-objective criteria\n        best_pos = 0\n        best_score = -np.inf\n        for pos in range(n-1):\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[pos-1], removed_node] + distance_matrix_1[removed_node, new_solution[pos]] + \\\n                        distance_matrix_1[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], removed_node] + distance_matrix_2[removed_node, new_solution[pos]] + \\\n                        distance_matrix_2[new_solution[pos], new_solution[(pos+1)%(n-1)]]\n\n            # Score based on improvement in both objectives\n            score = (original_cost1 - new_cost1) * (original_cost2 - new_cost2)\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the node at best position\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n        # Dynamic edge reversal\n        if np.random.random() < 0.3:  # 30% chance to reverse a segment\n            a, b = sorted(np.random.choice(n, size=2, replace=False))\n            if b - a > 1:\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{An adaptive multi-objective local search operator that combines guided path reconstruction with dynamic segment fusion, prioritizing edges that show improvement potential across both objectives while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment fusion with guided path reconstruction\n    for _ in range(3):\n        # Select segments with potential for improvement\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate potential improvement in both objectives\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[c]]\n\n        # Try reversing segment between b and c\n        temp_solution = new_solution.copy()\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        new_cost1 = distance_matrix_1[temp_solution[a], temp_solution[b]] + distance_matrix_1[temp_solution[b], temp_solution[c]]\n        new_cost2 = distance_matrix_2[temp_solution[a], temp_solution[b]] + distance_matrix_2[temp_solution[b], temp_solution[c]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n            break\n\n    # Dynamic validation and repair with probabilistic acceptance\n    if len(np.unique(new_solution)) != n:\n        # Repair by inserting missing nodes at positions that minimize cost\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost in both objectives\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n\n                # Weighted cost for probabilistic selection\n                total_cost = 0.5 * (cost1 + cost2)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8986583808166402,
            2.305988073348999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment fusion with guided path reconstruction\n    for _ in range(3):\n        # Select segments with potential for improvement\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate potential improvement in both objectives\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[c]]\n\n        # Try reversing segment between b and c\n        temp_solution = new_solution.copy()\n        temp_solution[b:c] = temp_solution[b:c][::-1]\n\n        new_cost1 = distance_matrix_1[temp_solution[a], temp_solution[b]] + distance_matrix_1[temp_solution[b], temp_solution[c]]\n        new_cost2 = distance_matrix_2[temp_solution[a], temp_solution[b]] + distance_matrix_2[temp_solution[b], temp_solution[c]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n            break\n\n    # Dynamic validation and repair with probabilistic acceptance\n    if len(np.unique(new_solution)) != n:\n        # Repair by inserting missing nodes at positions that minimize cost\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost in both objectives\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n\n                # Weighted cost for probabilistic selection\n                total_cost = 0.5 * (cost1 + cost2)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node relocation with adaptive segment reversal, incorporating a dynamic priority mechanism that balances edge improvement potential with solution diversity, while ensuring feasibility through a probabilistic validation and repair scheme.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (avoiding crowded regions)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=0).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with node relocation\n    if n > 3:\n        # Determine segment to reverse based on edge improvement potential\n        segment_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            segment_scores.append(cost1 + cost2)\n\n        segment_scores = np.array(segment_scores)\n        threshold = np.percentile(segment_scores, 75)\n\n        # Identify segments above threshold for potential reversal\n        candidate_segments = np.where(segment_scores > threshold)[0]\n\n        if len(candidate_segments) > 0:\n            # Randomly select a segment to reverse\n            selected_segment = np.random.choice(candidate_segments)\n            a, b = selected_segment, selected_segment + 1\n\n            # Reverse the segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n            # Relocate a node to improve both objectives\n            if n > 4:\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(0, n)\n\n                # Calculate cost before relocation\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n                # Calculate cost after relocation\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n                # Accept relocation if it improves at least one objective\n                if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6935401364616027,
            2.167245030403137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (avoiding crowded regions)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=0).sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with node relocation\n    if n > 3:\n        # Determine segment to reverse based on edge improvement potential\n        segment_scores = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            segment_scores.append(cost1 + cost2)\n\n        segment_scores = np.array(segment_scores)\n        threshold = np.percentile(segment_scores, 75)\n\n        # Identify segments above threshold for potential reversal\n        candidate_segments = np.where(segment_scores > threshold)[0]\n\n        if len(candidate_segments) > 0:\n            # Randomly select a segment to reverse\n            selected_segment = np.random.choice(candidate_segments)\n            a, b = selected_segment, selected_segment + 1\n\n            # Reverse the segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n            # Relocate a node to improve both objectives\n            if n > 4:\n                i = np.random.randint(0, n-1)\n                j = np.random.randint(0, n)\n\n                # Calculate cost before relocation\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n                # Calculate cost after relocation\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n                # Accept relocation if it improves at least one objective\n                if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node reinsertion with a multi-objective aware 3-opt move, prioritizing solutions with high crowding distance or Pareto dominance in the archive to guide the search toward diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node reinsertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before move\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Consider all possible 3-opt rearrangements\n        options = [\n            (new_solution[a], new_solution[b], new_solution[c]),\n            (new_solution[a], new_solution[c], new_solution[b]),\n            (new_solution[b], new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[c], new_solution[a]),\n            (new_solution[c], new_solution[a], new_solution[b]),\n            (new_solution[c], new_solution[b], new_solution[a])\n        ]\n\n        best_option = None\n        best_cost1 = original_cost1\n        best_cost2 = original_cost2\n\n        for option in options:\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b], temp_solution[c] = option\n\n            cost1 = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] +\n                    distance_matrix_1[temp_solution[b-1], temp_solution[b]] +\n                    distance_matrix_1[temp_solution[c-1], temp_solution[c]])\n            cost2 = (distance_matrix_2[temp_solution[a-1], temp_solution[a]] +\n                    distance_matrix_2[temp_solution[b-1], temp_solution[b]] +\n                    distance_matrix_2[temp_solution[c-1], temp_solution[c]])\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_option = option\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_option is not None:\n            new_solution[a], new_solution[b], new_solution[c] = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.8837028626882514,
            1.9629982709884644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node reinsertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before move\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Consider all possible 3-opt rearrangements\n        options = [\n            (new_solution[a], new_solution[b], new_solution[c]),\n            (new_solution[a], new_solution[c], new_solution[b]),\n            (new_solution[b], new_solution[a], new_solution[c]),\n            (new_solution[b], new_solution[c], new_solution[a]),\n            (new_solution[c], new_solution[a], new_solution[b]),\n            (new_solution[c], new_solution[b], new_solution[a])\n        ]\n\n        best_option = None\n        best_cost1 = original_cost1\n        best_cost2 = original_cost2\n\n        for option in options:\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b], temp_solution[c] = option\n\n            cost1 = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] +\n                    distance_matrix_1[temp_solution[b-1], temp_solution[b]] +\n                    distance_matrix_1[temp_solution[c-1], temp_solution[c]])\n            cost2 = (distance_matrix_2[temp_solution[a-1], temp_solution[a]] +\n                    distance_matrix_2[temp_solution[b-1], temp_solution[b]] +\n                    distance_matrix_2[temp_solution[c-1], temp_solution[c]])\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_option = option\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_option is not None:\n            new_solution[a], new_solution[b], new_solution[c] = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines guided node clustering with probabilistic edge reallocation, prioritizing nodes with high potential for improving both objectives while maintaining feasibility through a dynamic neighborhood validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on adaptive weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])  # Random weights for each objective\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Guided node clustering and probabilistic edge reallocation\n    for _ in range(3):\n        # Identify clusters of nodes with similar improvement potential\n        cluster_size = max(2, min(5, np.random.randint(1, n//2)))\n        cluster_center = np.random.randint(0, n)\n        cluster_indices = [(cluster_center + i) % n for i in range(cluster_size)]\n\n        # Calculate potential improvement for each node in cluster\n        improvement_potential = []\n        for i in cluster_indices:\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate potential improvement if we move this node\n            original_cost = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n            # Try moving to a random position\n            new_pos = np.random.randint(0, n)\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost = distance_matrix_1[new_prev, curr] + distance_matrix_1[curr, new_next] + \\\n                      distance_matrix_2[new_prev, curr] + distance_matrix_2[curr, new_next]\n\n            improvement_potential.append(original_cost - new_cost)\n\n        # Move the node with highest improvement potential\n        if improvement_potential:\n            best_node_idx = cluster_indices[np.argmax(improvement_potential)]\n            best_node = new_solution[best_node_idx]\n\n            # Remove the node and insert at new position\n            new_solution = np.concatenate([new_solution[:best_node_idx], new_solution[best_node_idx+1:]])\n            new_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, new_pos, best_node)\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Create a valid tour by ensuring all nodes are present\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6140175025832443,
            2.4014848470687866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on adaptive weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet([1, 1])  # Random weights for each objective\n    weighted_scores = (objectives * weights).sum(axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Guided node clustering and probabilistic edge reallocation\n    for _ in range(3):\n        # Identify clusters of nodes with similar improvement potential\n        cluster_size = max(2, min(5, np.random.randint(1, n//2)))\n        cluster_center = np.random.randint(0, n)\n        cluster_indices = [(cluster_center + i) % n for i in range(cluster_size)]\n\n        # Calculate potential improvement for each node in cluster\n        improvement_potential = []\n        for i in cluster_indices:\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate potential improvement if we move this node\n            original_cost = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + \\\n                           distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n            # Try moving to a random position\n            new_pos = np.random.randint(0, n)\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n\n            new_cost = distance_matrix_1[new_prev, curr] + distance_matrix_1[curr, new_next] + \\\n                      distance_matrix_2[new_prev, curr] + distance_matrix_2[curr, new_next]\n\n            improvement_potential.append(original_cost - new_cost)\n\n        # Move the node with highest improvement potential\n        if improvement_potential:\n            best_node_idx = cluster_indices[np.argmax(improvement_potential)]\n            best_node = new_solution[best_node_idx]\n\n            # Remove the node and insert at new position\n            new_solution = np.concatenate([new_solution[:best_node_idx], new_solution[best_node_idx+1:]])\n            new_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, new_pos, best_node)\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Create a valid tour by ensuring all nodes are present\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j-1])\n            new_solution = np.delete(new_solution, j)\n\n    return new_solution\n\n",
        "score": [
            -0.9108447907716638,
            1.6123661398887634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j-1])\n            new_solution = np.delete(new_solution, j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with high crowding distance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that minimizes the maximum increase in either objective\n        best_pos = -1\n        min_max_cost = float('inf')\n\n        for i in range(n):\n            if i >= a and i < b:\n                continue\n\n            # Calculate cost of inserting segment at position i\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif i == n:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n\n            max_cost = max(cost1, cost2)\n            if max_cost < min_max_cost:\n                min_max_cost = max_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            new_solution = np.delete(new_solution, np.s_[best_pos+len(segment):best_pos+2*len(segment)])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7900290137113328,
            0.652310311794281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that minimizes the maximum increase in either objective\n        best_pos = -1\n        min_max_cost = float('inf')\n\n        for i in range(n):\n            if i >= a and i < b:\n                continue\n\n            # Calculate cost of inserting segment at position i\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif i == n:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n\n            max_cost = max(cost1, cost2)\n            if max_cost < min_max_cost:\n                min_max_cost = max_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            new_solution = np.delete(new_solution, np.s_[best_pos+len(segment):best_pos+2*len(segment)])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The new algorithm combines a multi-objective aware segment relocation with a randomized edge inversion, prioritizing solutions with high crowding distance or Pareto dominance to guide the search toward unexplored regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Step 2: Randomized edge inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8615046821603947,
            1.7577173709869385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Step 2: Randomized edge inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block relocation with a multi-objective aware k-opt move, favoring solutions with higher hypervolume contribution or niche count to guide exploration toward diverse Pareto regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high hypervolume contribution or niche count\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - k)\n        b = np.random.randint(0, n - k)\n        block = new_solution[a:a+k]\n        new_solution = np.concatenate((new_solution[:a], new_solution[a+k:b], block, new_solution[b:]))\n\n    # Step 2: Multi-objective aware k-opt move (k=3)\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n        k = np.random.randint(j+1, n)\n\n        # Calculate cost before move\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Calculate cost after move\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k-1], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[i]])\n\n        # Accept move if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.885055509751322,
            1.1592299342155457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high hypervolume contribution or niche count\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block relocation\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - k)\n        b = np.random.randint(0, n - k)\n        block = new_solution[a:a+k]\n        new_solution = np.concatenate((new_solution[:a], new_solution[a+k:b], block, new_solution[b:]))\n\n    # Step 2: Multi-objective aware k-opt move (k=3)\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n        k = np.random.randint(j+1, n)\n\n        # Calculate cost before move\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Calculate cost after move\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[k-1], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[k-1], new_solution[i]])\n\n        # Accept move if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a probabilistic edge insertion, prioritizing solutions with high Pareto dominance while ensuring feasibility by dynamically adjusting the segment length based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (simplified by random selection)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Determine segment length based on solution quality (simplified)\n        segment_length = max(2, min(5, n // 4))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n\n        # Calculate cost before relocation\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Relocate segment\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        # Calculate cost after relocation\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()  # Revert if no improvement\n\n    # Step 2: Probabilistic edge insertion\n    if n > 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Insert node probabilistically\n        if np.random.rand() < 0.3:  # 30% chance\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n            # Accept if at least one objective improves\n            if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n                new_solution = new_solution[np.arange(len(new_solution)) != j]  # Revert if no improvement\n\n    return new_solution\n\n",
        "score": [
            -0.711554013979121,
            2.0957449078559875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance (simplified by random selection)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Determine segment length based on solution quality (simplified)\n        segment_length = max(2, min(5, n // 4))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n\n        # Calculate cost before relocation\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Relocate segment\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        # Calculate cost after relocation\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()  # Revert if no improvement\n\n    # Step 2: Probabilistic edge insertion\n    if n > 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Insert node probabilistically\n        if np.random.rand() < 0.3:  # 30% chance\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n            # Accept if at least one objective improves\n            if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n                new_solution = new_solution[np.arange(len(new_solution)) != j]  # Revert if no improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            j = (j + 1) % n\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9005847469468247,
            2.0845031142234802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            j = (j + 1) % n\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{A novel multi-objective local search algorithm that combines adaptive segment inversion with distance-aware node swapping, prioritizing improvements in both objectives while ensuring feasibility through a dynamic conflict resolution mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto dominance)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(5):\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Distance-aware node swapping\n        i, j = np.random.choice(n, size=2, replace=False)\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5392378708761987,
            1.2156079411506653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto dominance)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(5):\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Distance-aware node swapping\n        i, j = np.random.choice(n, size=2, replace=False)\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel local search operator that combines a multi-objective aware node insertion with a dynamic edge reversal strategy, prioritizing solutions with high potential for improvement by analyzing both objective costs and their relative dominance in the archive to guide the search toward high-quality regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        # Select a random node to remove\n        remove_pos = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_pos]\n\n        # Find the best insertion position for the removed node\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(1, n):\n            if i == remove_pos or i == remove_pos + 1:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], removed_node] + distance_matrix_1[removed_node, new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], removed_node] + distance_matrix_2[removed_node, new_solution[i]]\n\n            # Check if insertion improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                    best_pos = i\n                    best_cost1 = new_cost1\n                    best_cost2 = new_cost2\n\n        if best_pos != -1:\n            # Remove the node\n            new_solution = np.delete(new_solution, remove_pos)\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 3: Dynamic edge reversal strategy\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7798797196837547,
            1.6625880599021912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        # Select a random node to remove\n        remove_pos = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_pos]\n\n        # Find the best insertion position for the removed node\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(1, n):\n            if i == remove_pos or i == remove_pos + 1:\n                continue\n\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[new_solution[i-1], removed_node] + distance_matrix_1[removed_node, new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], removed_node] + distance_matrix_2[removed_node, new_solution[i]]\n\n            # Check if insertion improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                    best_pos = i\n                    best_cost1 = new_cost1\n                    best_cost2 = new_cost2\n\n        if best_pos != -1:\n            # Remove the node\n            new_solution = np.delete(new_solution, remove_pos)\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 3: Dynamic edge reversal strategy\n    if n > 3:\n        # Select a random segment to reverse\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with probability\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap with probability based on improvement\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            if np.random.rand() < 0.7:  # Higher probability to accept beneficial swaps\n                new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8933385842472836,
            1.283625841140747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with probability\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap with probability based on improvement\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            if np.random.rand() < 0.7:  # Higher probability to accept beneficial swaps\n                new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8647220584930703,
            0.8096097707748413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node relocation with a Pareto-optimal edge insertion, favoring solutions with higher crowding distance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Pareto-optimal edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.9178636518172977,
            1.8334697484970093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        pos = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Pareto-optimal edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This novel algorithm combines adaptive k-opt moves with multi-objective edge prioritization, dynamically selecting segments based on their potential to improve both objectives while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt with multi-objective prioritization\n    k = np.random.randint(3, 6)  # Random k between 3 and 5\n    for _ in range(3):  # Repeat operation 3 times\n        # Select k random positions\n        positions = np.random.choice(n, size=k, replace=False)\n        positions.sort()\n\n        # Calculate edge quality scores for both objectives\n        scores = np.zeros(k)\n        for i in range(k):\n            prev = positions[i-1] if i > 0 else positions[-1]\n            curr = positions[i]\n            next_pos = positions[(i+1)%k]\n            scores[i] = (distance_matrix_1[new_solution[prev], new_solution[curr]] +\n                         distance_matrix_2[new_solution[prev], new_solution[curr]]) * 0.5\n\n        # Sort positions by quality scores (descending)\n        sorted_pos = positions[np.argsort(-scores)]\n\n        # Perform cyclic permutation of selected segments\n        segment = new_solution[sorted_pos]\n        np.random.shuffle(segment)\n        new_solution[sorted_pos] = segment\n\n        # Probabilistic validation and repair\n        if np.random.random() < 0.3 or len(np.unique(new_solution)) != n:\n            # Repair by inserting missing nodes at random positions\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6642481536967755,
            2.3005903363227844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt with multi-objective prioritization\n    k = np.random.randint(3, 6)  # Random k between 3 and 5\n    for _ in range(3):  # Repeat operation 3 times\n        # Select k random positions\n        positions = np.random.choice(n, size=k, replace=False)\n        positions.sort()\n\n        # Calculate edge quality scores for both objectives\n        scores = np.zeros(k)\n        for i in range(k):\n            prev = positions[i-1] if i > 0 else positions[-1]\n            curr = positions[i]\n            next_pos = positions[(i+1)%k]\n            scores[i] = (distance_matrix_1[new_solution[prev], new_solution[curr]] +\n                         distance_matrix_2[new_solution[prev], new_solution[curr]]) * 0.5\n\n        # Sort positions by quality scores (descending)\n        sorted_pos = positions[np.argsort(-scores)]\n\n        # Perform cyclic permutation of selected segments\n        segment = new_solution[sorted_pos]\n        np.random.shuffle(segment)\n        new_solution[sorted_pos] = segment\n\n        # Probabilistic validation and repair\n        if np.random.random() < 0.3 or len(np.unique(new_solution)) != n:\n            # Repair by inserting missing nodes at random positions\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment inversions, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment inversion\n    for _ in range(5):\n        # Randomly select edges to swap\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        # Swap nodes at positions i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment inversion\n        if np.random.rand() < 0.5:\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7643176093867263,
            2.664817214012146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment inversion\n    for _ in range(5):\n        # Randomly select edges to swap\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        # Swap nodes at positions i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment inversion\n        if np.random.rand() < 0.5:\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{The new algorithm combines a multi-objective-aware node insertion with a guided segment relocation, prioritizing solutions with high crowding distance or Pareto dominance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node insertion\n    if n > 2:\n        # Select a random node to remove and reinsert\n        remove_pos = np.random.randint(0, n)\n        node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find the best insertion position that minimizes both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(n-1):\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[node, new_solution[pos]]\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[node, new_solution[pos]]\n\n            if (original_cost1 < best_cost1) or (original_cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = original_cost1\n                best_cost2 = original_cost2\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Guided segment relocation\n    if n > 3:\n        # Select a random segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(a, b))\n\n        # Find the best position to reinsert the segment\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Calculate cost before insertion\n            if pos == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n            if (original_cost1 < best_cost1) or (original_cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = original_cost1\n                best_cost2 = original_cost2\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9217002190926844,
            3.2304038405418396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node insertion\n    if n > 2:\n        # Select a random node to remove and reinsert\n        remove_pos = np.random.randint(0, n)\n        node = new_solution[remove_pos]\n        new_solution = np.delete(new_solution, remove_pos)\n\n        # Find the best insertion position that minimizes both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(n-1):\n            # Calculate cost before insertion\n            original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[node, new_solution[pos]]\n            original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[node, new_solution[pos]]\n\n            if (original_cost1 < best_cost1) or (original_cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = original_cost1\n                best_cost2 = original_cost2\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Guided segment relocation\n    if n > 3:\n        # Select a random segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(a, b))\n\n        # Find the best position to reinsert the segment\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Calculate cost before insertion\n            if pos == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n            if (original_cost1 < best_cost1) or (original_cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = original_cost1\n                best_cost2 = original_cost2\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{A novel hybrid local search algorithm combines a multi-objective aware node relocation with a dynamic edge crossover operator, where nodes are relocated based on their potential to improve both objectives simultaneously while the crossover operator exchanges segments between promising solutions to create diverse high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate potential cost change\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Dynamic edge crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find crossover points\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = other_solution[a:b+1]\n\n        # Create new solution by replacing segment\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n        # Remove duplicates\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n\n        # Insert missing nodes\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8582477155505264,
            1.0740065574645996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        # Calculate potential cost change\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Dynamic edge crossover with another solution\n    if len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find crossover points\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = other_solution[a:b+1]\n\n        # Create new solution by replacing segment\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n        # Remove duplicates\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n\n        # Insert missing nodes\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{The new algorithm combines a multi-objective aware segment relocation with a randomized edge insertion, prioritizing solutions with high crowding distance to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = np.array([sol[1][0] + sol[1][1] for sol in archive])\n    selected_idx = np.random.choice(len(archive), p=crowding_distances/np.sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment relocation + randomized edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_sol = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n\n            if (cost1 < best_cost1 and cost2 < best_cost2) or \\\n               (cost1 <= best_cost1 and cost2 < best_cost2) or \\\n               (cost1 < best_cost1 and cost2 <= best_cost2):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Randomized edge insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n",
        "score": [
            -0.9148920675571538,
            8.181479156017303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = np.array([sol[1][0] + sol[1][1] for sol in archive])\n    selected_idx = np.random.choice(len(archive), p=crowding_distances/np.sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment relocation + randomized edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_sol = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n\n            if (cost1 < best_cost1 and cost2 < best_cost2) or \\\n               (cost1 <= best_cost1 and cost2 < best_cost2) or \\\n               (cost1 < best_cost1 and cost2 <= best_cost2):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Randomized edge insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i-1)%n or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{A novel multi-objective local search algorithm combines adaptive edge swaps with Pareto-dominance guided segment reversals, dynamically balancing improvements across both objectives while ensuring feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive operation: edge swap with Pareto-dominance guided reversal\n    for _ in range(3):\n        # Select two random segments\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Perform swap if Pareto-dominant\n        if (potential_cost1 <= current_cost1 and potential_cost2 < current_cost2) or \\\n           (potential_cost1 < current_cost1 and potential_cost2 <= current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Optionally reverse segment if beneficial\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        rev_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]]\n        rev_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b]]\n\n        if (rev_cost1 < current_cost1 and rev_cost2 <= current_cost2) or \\\n           (rev_cost1 <= current_cost1 and rev_cost2 < current_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Randomly reinsert missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        np.random.shuffle(missing)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.918041590121603,
            2.4134581685066223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4  # Weighted combination\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive operation: edge swap with Pareto-dominance guided reversal\n    for _ in range(3):\n        # Select two random segments\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Perform swap if Pareto-dominant\n        if (potential_cost1 <= current_cost1 and potential_cost2 < current_cost2) or \\\n           (potential_cost1 < current_cost1 and potential_cost2 <= current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Optionally reverse segment if beneficial\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        rev_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]]\n        rev_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b]]\n\n        if (rev_cost1 < current_cost1 and rev_cost2 <= current_cost2) or \\\n           (rev_cost1 <= current_cost1 and rev_cost2 < current_cost2):\n            new_solution[a:b+1] = reversed_segment\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Randomly reinsert missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        np.random.shuffle(missing)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel hybrid local search algorithm combines guided edge swaps with adaptive segment inversions, prioritizing edges that show potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8715522831133626,
            2.3526220321655273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{An adaptive hybrid local search operator that combines multi-objective aware path relinking with dynamic segment fusion, prioritizing solutions with high potential for Pareto front improvement while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for Pareto improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.prod(objectives, axis=1) / (objectives[:, 0] * objectives[:, 1] + 1e-8)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path relinking with segment fusion\n    for _ in range(3):\n        # Select two distinct segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Relink segments with probability based on multi-objective improvement\n        cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        prob = 0.5 + 0.5 * (1 - (cost1 * cost2) / (np.prod(objectives[selected_idx]) + 1e-8))\n\n        if np.random.rand() < prob:\n            # Dynamic segment fusion\n            segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:c], new_solution[d:]])\n\n            # Probabilistic repair\n            if len(np.unique(new_solution)) != n:\n                missing = set(range(n)) - set(new_solution)\n                for node in missing:\n                    if np.random.rand() < 0.7:\n                        insert_pos = np.random.randint(0, len(new_solution))\n                        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9447218572322396,
            1.1875943541526794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for Pareto improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential = np.prod(objectives, axis=1) / (objectives[:, 0] * objectives[:, 1] + 1e-8)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path relinking with segment fusion\n    for _ in range(3):\n        # Select two distinct segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Relink segments with probability based on multi-objective improvement\n        cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        prob = 0.5 + 0.5 * (1 - (cost1 * cost2) / (np.prod(objectives[selected_idx]) + 1e-8))\n\n        if np.random.rand() < prob:\n            # Dynamic segment fusion\n            segment = np.concatenate([new_solution[a:b], new_solution[c:d]])\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:c], new_solution[d:]])\n\n            # Probabilistic repair\n            if len(np.unique(new_solution)) != n:\n                missing = set(range(n)) - set(new_solution)\n                for node in missing:\n                    if np.random.rand() < 0.7:\n                        insert_pos = np.random.randint(0, len(new_solution))\n                        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:b] = rotated_segment\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9152582496188975,
            2.366941452026367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:b] = rotated_segment\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swaps with multi-objective aware segment reversals, leveraging both distance matrices to guide improvements while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with segment reversals\n    for _ in range(5):\n        # Select random segments\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Reverse segment [a, b] with probability based on potential improvement\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[segment1[-1], segment1[0]] +\n                    distance_matrix_2[segment1[-1], segment1[0]] +\n                    distance_matrix_1[segment2[-1], segment2[0]] +\n                    distance_matrix_2[segment2[-1], segment2[0]])\n\n        new_segment1 = segment1[::-1]\n        new_segment2 = segment2[::-1]\n\n        new_cost = (distance_matrix_1[new_segment1[-1], new_segment1[0]] +\n                   distance_matrix_2[new_segment1[-1], new_segment1[0]] +\n                   distance_matrix_1[new_segment2[-1], new_segment2[0]] +\n                   distance_matrix_2[new_segment2[-1], new_segment2[0]])\n\n        if new_cost < old_cost and np.random.rand() < 0.7:\n            new_solution[a:b+1] = new_segment1\n            new_solution[b+1:c+1] = new_segment2\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.rand() < 0.5:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9479017748024461,
            2.473266065120697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives[:, 0] + objectives[:, 1])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with segment reversals\n    for _ in range(5):\n        # Select random segments\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Reverse segment [a, b] with probability based on potential improvement\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n\n        # Calculate potential improvement\n        old_cost = (distance_matrix_1[segment1[-1], segment1[0]] +\n                    distance_matrix_2[segment1[-1], segment1[0]] +\n                    distance_matrix_1[segment2[-1], segment2[0]] +\n                    distance_matrix_2[segment2[-1], segment2[0]])\n\n        new_segment1 = segment1[::-1]\n        new_segment2 = segment2[::-1]\n\n        new_cost = (distance_matrix_1[new_segment1[-1], new_segment1[0]] +\n                   distance_matrix_2[new_segment1[-1], new_segment1[0]] +\n                   distance_matrix_1[new_segment2[-1], new_segment2[0]] +\n                   distance_matrix_2[new_segment2[-1], new_segment2[0]])\n\n        if new_cost < old_cost and np.random.rand() < 0.7:\n            new_solution[a:b+1] = new_segment1\n            new_solution[b+1:c+1] = new_segment2\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.rand() < 0.5:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive edge swapping with multi-objective-aware segment reversal, dynamically balancing improvements in both objective spaces while maintaining feasibility through a constraint-aware validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swapping with segment reversal\n    for _ in range(5):\n        # Select segments based on potential multi-objective improvement\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement in both objectives\n        current_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        # Reverse segment and calculate new cost\n        segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[new_solution[(a-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[(a-1)%n], segment[0]] + distance_matrix_2[segment[-1], new_solution[(b+1)%n]]\n\n        # Apply if improvement in at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a:b+1] = segment\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reordering missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8335043815193945,
            2.7212307453155518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swapping with segment reversal\n    for _ in range(5):\n        # Select segments based on potential multi-objective improvement\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement in both objectives\n        current_cost1 = distance_matrix_1[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[(a-1)%n], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n        # Reverse segment and calculate new cost\n        segment = new_solution[a:b+1][::-1]\n        new_cost1 = distance_matrix_1[new_solution[(a-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[(a-1)%n], segment[0]] + distance_matrix_2[segment[-1], new_solution[(b+1)%n]]\n\n        # Apply if improvement in at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a:b+1] = segment\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reordering missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{A novel adaptive multi-objective local search that combines a dynamic segment rotation with a Pareto-aware edge crossover, where segments are rotated based on their historical improvement potential and edges are crossed over while preserving non-dominated relationships in the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment rotation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment based on historical improvement\n        rotation = np.random.randint(1, segment_length)\n        new_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = new_segment\n\n    # Step 2: Pareto-aware edge crossover\n    if n > 4:\n        # Select two random edges to cross\n        i1, i2 = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n        # Check if crossing improves Pareto front\n        original_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[i2-1], new_solution[i2]]\n        original_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[i2-1], new_solution[i2]]\n\n        new_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i2]] + distance_matrix_1[new_solution[i2-1], new_solution[i1]]\n        new_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i2]] + distance_matrix_2[new_solution[i2-1], new_solution[i1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    return new_solution\n\n",
        "score": [
            -0.8377275744178949,
            1.7338774800300598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment rotation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment based on historical improvement\n        rotation = np.random.randint(1, segment_length)\n        new_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = new_segment\n\n    # Step 2: Pareto-aware edge crossover\n    if n > 4:\n        # Select two random edges to cross\n        i1, i2 = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n        # Check if crossing improves Pareto front\n        original_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[i2-1], new_solution[i2]]\n        original_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[i2-1], new_solution[i2]]\n\n        new_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i2]] + distance_matrix_1[new_solution[i2-1], new_solution[i1]]\n        new_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i2]] + distance_matrix_2[new_solution[i2-1], new_solution[i1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1) % n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.710970239723206,
            2.125203788280487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1) % n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment rotation with a dominance-based edge insertion, favoring solutions with high crowding distance or Pareto non-dominated status to explore underrepresented regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment rotation\n    if n > 3:\n        a = np.random.randint(0, n-2)\n        b = np.random.randint(a+2, n)\n        k = np.random.randint(1, b-a+1)\n        segment = new_solution[a:b]\n        new_solution[a:b] = np.roll(segment, k)\n\n    # Step 2: Dominance-based edge insertion\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j+1]] + distance_matrix_1[new_solution[i+1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j]]\n\n        # Accept insertion if it improves both objectives\n        if (new_cost1 <= original_cost1) and (new_cost2 <= original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.85627726983346,
            1.928822100162506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment rotation\n    if n > 3:\n        a = np.random.randint(0, n-2)\n        b = np.random.randint(a+2, n)\n        k = np.random.randint(1, b-a+1)\n        segment = new_solution[a:b]\n        new_solution[a:b] = np.roll(segment, k)\n\n    # Step 2: Dominance-based edge insertion\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j+1]] + distance_matrix_1[new_solution[i+1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j+1]] + distance_matrix_2[new_solution[i+1], new_solution[j]]\n\n        # Accept insertion if it improves both objectives\n        if (new_cost1 <= original_cost1) and (new_cost2 <= original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{The new algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with high diversity in the archive to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (least crowded)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.delete(new_solution, np.arange(a, b))\n        pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, pos, segment)\n\n        # Calculate cost before and after relocation\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Revert if relocation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7161581290436381,
            1.9773009419441223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (least crowded)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.delete(new_solution, np.arange(a, b))\n        pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, pos, segment)\n\n        # Calculate cost before and after relocation\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Revert if relocation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment inversion with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: probabilistic segment inversion + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment inversion\n    if n > 2 and np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8624835657873735,
            1.8483881950378418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: probabilistic segment inversion + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment inversion\n    if n > 2 and np.random.rand() < 0.5:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment relocations, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through dynamic validation and repair, and using a custom scoring function to guide selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Custom scoring function: weighted combination of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weighting first objective more heavily\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(7):  # Increased iterations\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Validate and repair if needed\n        if len(np.unique(new_solution)) != n:\n            # Repair by restoring original order for missing nodes\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Early termination if valid\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8250946931670405,
            0.8498551845550537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Custom scoring function: weighted combination of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.array([0.6, 0.4])  # Weighting first objective more heavily\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(7):  # Increased iterations\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Validate and repair if needed\n        if len(np.unique(new_solution)) != n:\n            # Repair by restoring original order for missing nodes\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Early termination if valid\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This new algorithm combines a multi-objective aware segment relocation with a dynamic edge insertion, prioritizing solutions with high crowding distance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find best insertion point for the segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Dynamic edge insertion\n    if n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Remove edges between i and i+1, and between j and j+1\n        # Insert new edges between i and j, and between i+1 and j+1\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:j+1],\n            new_solution[i+1:j],\n            new_solution[i:i+1],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9151935339693031,
            6.415987014770508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find best insertion point for the segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Dynamic edge insertion\n    if n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Remove edges between i and i+1, and between j and j+1\n        # Insert new edges between i and j, and between i+1 and j+1\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j:j+1],\n            new_solution[i+1:j],\n            new_solution[i:i+1],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive node clustering with cross-dimensional edge swaps, prioritizing high-potential edges in both objective spaces while maintaining feasibility through a dynamic constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive clustering and cross-dimensional edge swaps\n    for _ in range(5):\n        # Cluster nodes based on both objective spaces\n        cluster_size = max(2, n // 5)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n        # Select two random clusters\n        if len(clusters) < 2:\n            break\n        c1, c2 = np.random.choice(len(clusters), size=2, replace=False)\n\n        # Find edges with high potential in both spaces\n        def edge_potential(u, v):\n            return (distance_matrix_1[u, v] + distance_matrix_1[v, u]) * (distance_matrix_2[u, v] + distance_matrix_2[v, u])\n\n        # Find best edge in each cluster\n        best_edge1 = max([(edge_potential(u, v), (u, v)) for u in clusters[c1] for v in clusters[c1] if u != v])[1]\n        best_edge2 = max([(edge_potential(u, v), (u, v)) for u in clusters[c2] for v in clusters[c2] if u != v])[1]\n\n        # Perform cross-cluster edge swap\n        pos1 = np.where(new_solution == best_edge1[0])[0][0]\n        pos2 = np.where(new_solution == best_edge2[0])[0][0]\n\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Dynamic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8979865679559208,
            3.0929572582244873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive clustering and cross-dimensional edge swaps\n    for _ in range(5):\n        # Cluster nodes based on both objective spaces\n        cluster_size = max(2, n // 5)\n        clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n        # Select two random clusters\n        if len(clusters) < 2:\n            break\n        c1, c2 = np.random.choice(len(clusters), size=2, replace=False)\n\n        # Find edges with high potential in both spaces\n        def edge_potential(u, v):\n            return (distance_matrix_1[u, v] + distance_matrix_1[v, u]) * (distance_matrix_2[u, v] + distance_matrix_2[v, u])\n\n        # Find best edge in each cluster\n        best_edge1 = max([(edge_potential(u, v), (u, v)) for u in clusters[c1] for v in clusters[c1] if u != v])[1]\n        best_edge2 = max([(edge_potential(u, v), (u, v)) for u in clusters[c2] for v in clusters[c2] if u != v])[1]\n\n        # Perform cross-cluster edge swap\n        pos1 = np.where(new_solution == best_edge1[0])[0][0]\n        pos2 = np.where(new_solution == best_edge2[0])[0][0]\n\n        new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Dynamic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware segment relocation, favoring solutions with higher crowding distance or Pareto dominance to guide exploration toward diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8283954226024584,
            1.2889309525489807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        if a != b:\n            node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, node)\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A novel adaptive multi-objective local search operator that combines a probabilistic segment rotation with a Pareto-optimal edge crossover, dynamically adjusting exploration/exploitation based on solution quality and diversity in the archive to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Calculate crowding distance for each objective\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solution with highest crowding distance (good diversity)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        k = np.random.randint(2, min(5, n-1))\n        a = np.random.randint(0, n-k)\n        segment = new_solution[a:a+k]\n\n        # Rotate segment with probability based on solution quality\n        quality = np.exp(-(objectives[selected_idx][0] + objectives[selected_idx][1]) / np.sum(objectives))\n        if np.random.rand() < quality:\n            rotate_amount = np.random.randint(1, k)\n            segment = np.roll(segment, rotate_amount)\n\n        new_solution[a:a+k] = segment\n\n    # Pareto-optimal edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Find Pareto-optimal edges in the segment\n        segment = new_solution[i:j+1]\n        pareto_edges = []\n\n        for k in range(len(segment)-1):\n            edge1 = (segment[k], segment[k+1])\n            for l in range(k+1, len(segment)-1):\n                edge2 = (segment[l], segment[l+1])\n\n                # Check if edges are Pareto-optimal\n                cost1a = distance_matrix_1[edge1[0], edge1[1]]\n                cost2a = distance_matrix_2[edge1[0], edge1[1]]\n                cost1b = distance_matrix_1[edge2[0], edge2[1]]\n                cost2b = distance_matrix_2[edge2[0], edge2[1]]\n\n                if (cost1a <= cost1b and cost2a < cost2b) or (cost1a < cost1b and cost2a <= cost2b):\n                    pareto_edges.append((edge1, edge2))\n\n        # Apply crossover if Pareto-optimal edges found\n        if pareto_edges:\n            edge1, edge2 = pareto_edges[np.random.randint(0, len(pareto_edges))]\n            pos1 = np.where(new_solution == edge1[0])[0][0]\n            pos2 = np.where(new_solution == edge2[0])[0][0]\n\n            if pos1 < pos2:\n                new_solution[pos1+1:pos2] = new_solution[pos1+1:pos2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5749327290107915,
            2.9926822185516357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    # Calculate crowding distance for each objective\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    # Select solution with highest crowding distance (good diversity)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        k = np.random.randint(2, min(5, n-1))\n        a = np.random.randint(0, n-k)\n        segment = new_solution[a:a+k]\n\n        # Rotate segment with probability based on solution quality\n        quality = np.exp(-(objectives[selected_idx][0] + objectives[selected_idx][1]) / np.sum(objectives))\n        if np.random.rand() < quality:\n            rotate_amount = np.random.randint(1, k)\n            segment = np.roll(segment, rotate_amount)\n\n        new_solution[a:a+k] = segment\n\n    # Pareto-optimal edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Find Pareto-optimal edges in the segment\n        segment = new_solution[i:j+1]\n        pareto_edges = []\n\n        for k in range(len(segment)-1):\n            edge1 = (segment[k], segment[k+1])\n            for l in range(k+1, len(segment)-1):\n                edge2 = (segment[l], segment[l+1])\n\n                # Check if edges are Pareto-optimal\n                cost1a = distance_matrix_1[edge1[0], edge1[1]]\n                cost2a = distance_matrix_2[edge1[0], edge1[1]]\n                cost1b = distance_matrix_1[edge2[0], edge2[1]]\n                cost2b = distance_matrix_2[edge2[0], edge2[1]]\n\n                if (cost1a <= cost1b and cost2a < cost2b) or (cost1a < cost1b and cost2a <= cost2b):\n                    pareto_edges.append((edge1, edge2))\n\n        # Apply crossover if Pareto-optimal edges found\n        if pareto_edges:\n            edge1, edge2 = pareto_edges[np.random.randint(0, len(pareto_edges))]\n            pos1 = np.where(new_solution == edge1[0])[0][0]\n            pos2 = np.where(new_solution == edge2[0])[0][0]\n\n            if pos1 < pos2:\n                new_solution[pos1+1:pos2] = new_solution[pos1+1:pos2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment reversal with a multi-objective aware node insertion, favoring solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3 and np.random.rand() < 0.5:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n",
        "score": [
            -0.8009517856479181,
            2.1442465782165527
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3 and np.random.rand() < 0.5:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{A novel hybrid local search algorithm combines edge crossovers with adaptive segment reversals, prioritizing segments with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge crossover with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Cross segments [b+1, c] with [a, b]\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing, reverse=True):\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8884489532378688,
            1.2588510513305664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge crossover with adaptive segment reversal\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Cross segments [b+1, c] with [a, b]\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing, reverse=True):\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective aware 2-opt*, leveraging both Pareto dominance and crowding distance to guide exploration while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Multi-objective aware 2-opt*\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8501632097122589,
            1.6412175297737122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Multi-objective aware 2-opt*\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a randomized edge crossover, prioritizing solutions with higher crowding distance or Pareto dominance to guide the search toward unexplored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment relocation + randomized edge crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes at least one objective\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(len(new_solution)):\n            # Calculate cost for inserting segment at position i\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif i == len(new_solution):\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_pos = i\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Randomized edge crossover\n    if n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:\n            # Calculate cost before crossover\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after crossover\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Accept crossover if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.869156089732802,
            1.9903222918510437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment relocation + randomized edge crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Find insertion point that minimizes at least one objective\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(len(new_solution)):\n            # Calculate cost for inserting segment at position i\n            if i == 0:\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif i == len(new_solution):\n                cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i]]\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_pos = i\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Step 2: Randomized edge crossover\n    if n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if abs(i - j) > 1:\n            # Calculate cost before crossover\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Calculate cost after crossover\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Accept crossover if it improves at least one objective\n            if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This novel algorithm combines a multi-objective edge selection mechanism with a probabilistic path inversion operator, where edges are prioritized based on their potential to improve both objectives, and path segments are inverted with adaptive probability to explore the solution space while maintaining feasibility through a dynamic feasibility checker.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge selection\n    edge_scores = np.zeros(n)\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        edge_scores[i] = 0.5 * distance_matrix_1[u, v] + 0.5 * distance_matrix_2[u, v]\n\n    # Find edges with highest potential for improvement\n    top_edges = np.argsort(edge_scores)[-max(2, n//5):]\n\n    # Probabilistic path inversion\n    for edge in top_edges:\n        if np.random.random() < 0.7:  # Adaptive probability\n            a, b = edge, edge + 1\n            if a > b:\n                a, b = b, a\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]  # Invert the segment\n\n    # Dynamic feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9070852830332613,
            2.8954816460609436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective edge selection\n    edge_scores = np.zeros(n)\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        edge_scores[i] = 0.5 * distance_matrix_1[u, v] + 0.5 * distance_matrix_2[u, v]\n\n    # Find edges with highest potential for improvement\n    top_edges = np.argsort(edge_scores)[-max(2, n//5):]\n\n    # Probabilistic path inversion\n    for edge in top_edges:\n        if np.random.random() < 0.7:  # Adaptive probability\n            a, b = edge, edge + 1\n            if a > b:\n                a, b = b, a\n            segment = new_solution[a:b+1]\n            new_solution[a:b+1] = segment[::-1]  # Invert the segment\n\n    # Dynamic feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This novel algorithm combines adaptive edge swapping with multi-objective-aware segment reversal, dynamically prioritizing operations that improve both objectives while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = normalized.sum(axis=1) + np.random.normal(0, 0.1, len(archive))\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(3):\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        if i > j:\n            i, j = j, i\n\n        segment = new_solution[i:j+1]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.955014059616468,
            2.846483588218689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = normalized.sum(axis=1) + np.random.normal(0, 0.1, len(archive))\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(3):\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        if i > j:\n            i, j = j, i\n\n        segment = new_solution[i:j+1]\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{A novel hybrid local search algorithm that combines guided segment relocations with adaptive edge swaps, prioritizing multi-objective improvement through dynamic edge selection and feasibility-preserving operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with guided segment relocations\n    for _ in range(5):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate potential improvement score\n            score = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                     distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n            edge_scores.append(score)\n\n        # Select worst edge to improve\n        worst_edge = np.argmax(edge_scores)\n        a, b = worst_edge, (worst_edge + 1) % n\n\n        # Perform guided segment relocation\n        c = np.random.randint(0, n)\n        if a > c:\n            a, c = c, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8385552115098256,
            1.3265473246574402
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(objectives.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with guided segment relocations\n    for _ in range(5):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate potential improvement score\n            score = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                     distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n            edge_scores.append(score)\n\n        # Select worst edge to improve\n        worst_edge = np.argmax(edge_scores)\n        a, b = worst_edge, (worst_edge + 1) % n\n\n        # Perform guided segment relocation\n        c = np.random.randint(0, n)\n        if a > c:\n            a, c = c, a\n\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The new algorithm combines a multi-objective aware node relocation with a probabilistic segment reversal, prioritizing solutions with high crowding distance or Pareto dominance to explore less crowded regions while ensuring feasibility through feasibility-preserving operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion point considering both objectives\n        best_pos = -1\n        min_total_cost = float('inf')\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost of inserting node between i and i+1\n            cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n            cost1 -= distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] if i != (node_idx - 1) % n else 0\n\n            cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%n]]\n            cost2 -= distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] if i != (node_idx - 1) % n else 0\n\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            # Perform the relocation\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8545269452887174,
            2.147868275642395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find the best insertion point considering both objectives\n        best_pos = -1\n        min_total_cost = float('inf')\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx - 1) % n:\n                continue\n\n            # Calculate cost of inserting node between i and i+1\n            cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%n]]\n            cost1 -= distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] if i != (node_idx - 1) % n else 0\n\n            cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%n]]\n            cost2 -= distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] if i != (node_idx - 1) % n else 0\n\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = i\n\n        if best_pos != -1:\n            # Perform the relocation\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware segment reversal, favoring solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        new_position = np.random.randint(0, n)\n        if node_to_move != new_position:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, new_position, node)\n\n    # Step 2: Multi-objective aware segment reversal\n    if n > 3:\n        a = np.random.randint(0, n-2)\n        b = np.random.randint(a+2, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8982979188875649,
            2.3416717648506165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        node_to_move = np.random.randint(0, n)\n        new_position = np.random.randint(0, n)\n        if node_to_move != new_position:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, new_position, node)\n\n    # Step 2: Multi-objective aware segment reversal\n    if n > 3:\n        a = np.random.randint(0, n-2)\n        b = np.random.randint(a+2, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive node swapping with multi-objective aware segment inversion, dynamically prioritizing nodes based on their potential improvement in both objective spaces while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate potential improvement for each node in both objectives\n    node_improvement = np.zeros(n)\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n        current_cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n        current_cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n\n        # Try swapping with next node\n        swap_cost1 = distance_matrix_1[prev_node, next_node] + distance_matrix_1[next_node, new_solution[i]]\n        swap_cost2 = distance_matrix_2[prev_node, next_node] + distance_matrix_2[next_node, new_solution[i]]\n\n        # Calculate potential improvement (simplified)\n        node_improvement[i] = (current_cost1 - swap_cost1) + (current_cost2 - swap_cost2)\n\n    # Select nodes with top improvement potential\n    k = max(2, n // 10)  # Number of nodes to consider for swapping\n    top_nodes = np.argsort(node_improvement)[-k:]\n\n    # Perform adaptive node swaps and segment inversions\n    for _ in range(5):\n        if len(top_nodes) >= 2:\n            # Perform node swap\n            a, b = np.random.choice(top_nodes, size=2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # With probability 0.3, perform segment inversion\n            if np.random.random() < 0.3:\n                segment_start = min(a, b)\n                segment_end = max(a, b)\n                new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution by sorting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9604401034936282,
            2.390957534313202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate potential improvement for each node in both objectives\n    node_improvement = np.zeros(n)\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n        current_cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n        current_cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n\n        # Try swapping with next node\n        swap_cost1 = distance_matrix_1[prev_node, next_node] + distance_matrix_1[next_node, new_solution[i]]\n        swap_cost2 = distance_matrix_2[prev_node, next_node] + distance_matrix_2[next_node, new_solution[i]]\n\n        # Calculate potential improvement (simplified)\n        node_improvement[i] = (current_cost1 - swap_cost1) + (current_cost2 - swap_cost2)\n\n    # Select nodes with top improvement potential\n    k = max(2, n // 10)  # Number of nodes to consider for swapping\n    top_nodes = np.argsort(node_improvement)[-k:]\n\n    # Perform adaptive node swaps and segment inversions\n    for _ in range(5):\n        if len(top_nodes) >= 2:\n            # Perform node swap\n            a, b = np.random.choice(top_nodes, size=2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            # With probability 0.3, perform segment inversion\n            if np.random.random() < 0.3:\n                segment_start = min(a, b)\n                segment_end = max(a, b)\n                new_solution[segment_start:segment_end+1] = new_solution[segment_start:segment_end+1][::-1]\n\n        # Validate solution\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution by sorting missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{A novel hybrid local search algorithm combines multi-objective edge swaps with adaptive segment reversals, prioritizing edges with high potential for Pareto improvement while maintaining feasibility through a dynamic validation and repair mechanism using Chebyshev distance-based selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Chebyshev distance to ideal point (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    ideal = objectives.min(axis=0)\n    chebyshev_distances = np.max(objectives - ideal, axis=1)\n    selected_idx = np.argmax(chebyshev_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            j = (i + 1) % n\n            a, b = new_solution[i], new_solution[j]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            # Score based on both objectives and their relative improvement potential\n            score = (cost1 + cost2) * (1 + abs(cost1 - cost2))\n            edge_scores.append(score)\n\n        # Select top 3 edges to manipulate\n        top_edges = np.argsort(edge_scores)[-3:]\n        for i in top_edges:\n            j = (i + 1) % n\n            # Reverse a random segment between these edges\n            a = np.random.randint(i, j) if j > i else np.random.randint(j, i)\n            b = np.random.randint(i, j) if j > i else np.random.randint(j, i)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8912302890725864,
            2.12295925617218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Chebyshev distance to ideal point (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    ideal = objectives.min(axis=0)\n    chebyshev_distances = np.max(objectives - ideal, axis=1)\n    selected_idx = np.argmax(chebyshev_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective edge swap with adaptive segment reversal\n    for _ in range(5):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            j = (i + 1) % n\n            a, b = new_solution[i], new_solution[j]\n            cost1 = distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, b]\n            # Score based on both objectives and their relative improvement potential\n            score = (cost1 + cost2) * (1 + abs(cost1 - cost2))\n            edge_scores.append(score)\n\n        # Select top 3 edges to manipulate\n        top_edges = np.argsort(edge_scores)[-3:]\n        for i in top_edges:\n            j = (i + 1) % n\n            # Reverse a random segment between these edges\n            a = np.random.randint(i, j) if j > i else np.random.randint(j, i)\n            b = np.random.randint(i, j) if j > i else np.random.randint(j, i)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment relinking with multi-objective aware node relocations, dynamically balancing exploration and exploitation by prioritizing segments with high potential for cross-objective improvement while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.prod(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relinking with multi-objective awareness\n    for _ in range(3):\n        # Select segments based on their potential for improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment's current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length))\n\n        # Find relocation point with potential for improvement\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate potential cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[start+segment_length]] + sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[start+segment_length]] + sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]] + sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]] + sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n\n            # Calculate improvement potential\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Relocate segment\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9090256513997679,
            13.582365989685059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.prod(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relinking with multi-objective awareness\n    for _ in range(3):\n        # Select segments based on their potential for improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment's current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, start+segment_length))\n\n        # Find relocation point with potential for improvement\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate potential cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[start+segment_length]] + sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[start+segment_length]] + sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]] + sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]] + sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start+segment_length, n) if i != start)\n\n            # Calculate improvement potential\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Relocate segment\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This novel algorithm combines a multi-objective aware node relocation strategy with a guided edge inversion mechanism, prioritizing solutions with high crowding distance while ensuring feasibility through a dynamic segment validation and repair process, and leveraging adaptive neighborhood exploration to balance exploration and exploitation in the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_idx or (pos == node_idx - 1) or (pos == node_idx + 1):\n                continue\n\n            # Calculate cost before relocation\n            if node_idx == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[0], new_solution[1]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[0], new_solution[1]]\n            elif node_idx == n-1:\n                original_cost1 = distance_matrix_1[new_solution[-2], new_solution[-1]] + distance_matrix_1[new_solution[-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-2], new_solution[-1]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], new_solution[node_idx+1]]\n                original_cost2 = distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], new_solution[node_idx+1]]\n\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n                new_cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n            elif pos == n-1:\n                new_cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Guided edge inversion\n    if n > 4:\n        # Select two edges to invert\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate cost before inversion\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after inversion\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept inversion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.40710803429000864,
            4.128625750541687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_idx or (pos == node_idx - 1) or (pos == node_idx + 1):\n                continue\n\n            # Calculate cost before relocation\n            if node_idx == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[0], new_solution[1]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[0], new_solution[1]]\n            elif node_idx == n-1:\n                original_cost1 = distance_matrix_1[new_solution[-2], new_solution[-1]] + distance_matrix_1[new_solution[-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-2], new_solution[-1]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], new_solution[node_idx+1]]\n                original_cost2 = distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], new_solution[node_idx+1]]\n\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n                new_cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n            elif pos == n-1:\n                new_cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n\n            # Calculate improvement\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Guided edge inversion\n    if n > 4:\n        # Select two edges to invert\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate cost before inversion\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after inversion\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept inversion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment shuffling with multi-objective aware node insertion, leveraging both spatial and objective-based neighborhood structures to explore promising regions while maintaining feasibility through dynamic constraint validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    if n > 3:\n        segment_size = min(3, n // 4)\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Shuffle the selected segment\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n    # Multi-objective aware node insertion\n    if n > 4:\n        # Find the worst node in both objectives\n        total_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1) % n]\n            total_costs[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        worst_node_idx = np.argmax(total_costs)\n        worst_node = new_solution[worst_node_idx]\n\n        # Remove the worst node\n        new_solution = np.delete(new_solution, worst_node_idx)\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            # Calculate cost for insertion at position pos\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost1 = distance_matrix_1[prev, worst_node] + distance_matrix_1[worst_node, next_node]\n            cost2 = distance_matrix_2[prev, worst_node] + distance_matrix_2[worst_node, next_node]\n\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        # Insert the worst node at best position\n        new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6906978664062055,
            4.115312933921814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment shuffling\n    if n > 3:\n        segment_size = min(3, n // 4)\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Shuffle the selected segment\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n    # Multi-objective aware node insertion\n    if n > 4:\n        # Find the worst node in both objectives\n        total_costs = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1) % n]\n            total_costs[i] = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] + distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n        worst_node_idx = np.argmax(total_costs)\n        worst_node = new_solution[worst_node_idx]\n\n        # Remove the worst node\n        new_solution = np.delete(new_solution, worst_node_idx)\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            # Calculate cost for insertion at position pos\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n            cost1 = distance_matrix_1[prev, worst_node] + distance_matrix_1[worst_node, next_node]\n            cost2 = distance_matrix_2[prev, worst_node] + distance_matrix_2[worst_node, next_node]\n\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        # Insert the worst node at best position\n        new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node relocation with a Pareto-optimality guided segment crossover, prioritizing solutions with high crowding distance to explore diverse regions while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after relocation\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, base_solution[i])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept relocation if it improves both objectives\n        if not ((new_cost1 < original_cost1) and (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()\n\n    # Step 2: Pareto-optimality guided segment crossover\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create a new solution by combining segments from two random positions\n        segment1 = base_solution[a:b]\n        remaining_nodes = np.setdiff1d(base_solution, segment1)\n        np.random.shuffle(remaining_nodes)\n\n        new_solution = np.concatenate([segment1, remaining_nodes])\n\n        # Calculate Pareto dominance\n        original_obj = archive[selected_idx][1]\n        new_obj = (sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]),\n                   sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]))\n\n        # Accept if it's Pareto-dominant or non-dominated\n        if not ((original_obj[0] < new_obj[0] and original_obj[1] <= new_obj[1]) or\n                (original_obj[0] <= new_obj[0] and original_obj[1] < new_obj[1])):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8182355994122712,
            6.6806705594062805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after relocation\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, base_solution[i])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept relocation if it improves both objectives\n        if not ((new_cost1 < original_cost1) and (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()\n\n    # Step 2: Pareto-optimality guided segment crossover\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create a new solution by combining segments from two random positions\n        segment1 = base_solution[a:b]\n        remaining_nodes = np.setdiff1d(base_solution, segment1)\n        np.random.shuffle(remaining_nodes)\n\n        new_solution = np.concatenate([segment1, remaining_nodes])\n\n        # Calculate Pareto dominance\n        original_obj = archive[selected_idx][1]\n        new_obj = (sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]),\n                   sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]))\n\n        # Accept if it's Pareto-dominant or non-dominated\n        if not ((original_obj[0] < new_obj[0] and original_obj[1] <= new_obj[1]) or\n                (original_obj[0] <= new_obj[0] and original_obj[1] < new_obj[1])):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{A novel hybrid local search algorithm combines guided edge swaps with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism using a combination of probabilistic selection and deterministic checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with guided edge swaps\n    for _ in range(5):\n        # Select a random segment to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Perform guided edge swap if beneficial\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate current and potential costs\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if potential_cost < current_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.904137550167659,
            1.647900402545929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with guided edge swaps\n    for _ in range(5):\n        # Select a random segment to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Perform guided edge swap if beneficial\n        if np.random.rand() < 0.5:\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate current and potential costs\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]])\n            potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if potential_cost < current_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8506764179186405,
            2.3558781147003174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{The backbone idea is combining different local search operators while prioritizing solutions with high potential for improvement, balancing exploration and exploitation. A novel hybrid local search algorithm combines multi-objective aware node relocations with adaptive segment reversals, leveraging both objective-specific distance matrices to guide the search toward Pareto-optimal regions while maintaining feasibility through dynamic validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance or Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with adaptive segment reversal\n    for _ in range(3):\n        # Select node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate potential relocation positions based on both objectives\n        potential_positions = []\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                continue\n            # Calculate cost difference for both objectives\n            old_cost1 = distance_matrix_1[new_solution[node_idx-1], node] + distance_matrix_1[node, new_solution[(node_idx+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[node_idx-1], node] + distance_matrix_2[node, new_solution[(node_idx+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            delta2 = new_cost2 - old_cost2\n\n            # Accept if at least one objective improves\n            if delta1 < 0 or delta2 < 0:\n                potential_positions.append(pos)\n\n        if potential_positions:\n            new_pos = np.random.choice(potential_positions)\n            # Relocate node\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n\n            # Adaptive segment reversal\n            if np.random.random() < 0.3:\n                a, b = sorted(np.random.choice(n-1, size=2, replace=False))\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n            # Validate and repair if needed\n            if len(np.unique(new_solution)) != n:\n                missing = set(range(n)) - set(new_solution)\n                for m_node in missing:\n                    insert_pos = np.random.randint(0, n)\n                    new_solution = np.insert(new_solution, insert_pos, m_node)\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6996632151063885,
            5.115626811981201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance or Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with adaptive segment reversal\n    for _ in range(3):\n        # Select node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate potential relocation positions based on both objectives\n        potential_positions = []\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                continue\n            # Calculate cost difference for both objectives\n            old_cost1 = distance_matrix_1[new_solution[node_idx-1], node] + distance_matrix_1[node, new_solution[(node_idx+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[node_idx-1], node] + distance_matrix_2[node, new_solution[(node_idx+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            delta2 = new_cost2 - old_cost2\n\n            # Accept if at least one objective improves\n            if delta1 < 0 or delta2 < 0:\n                potential_positions.append(pos)\n\n        if potential_positions:\n            new_pos = np.random.choice(potential_positions)\n            # Relocate node\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n\n            # Adaptive segment reversal\n            if np.random.random() < 0.3:\n                a, b = sorted(np.random.choice(n-1, size=2, replace=False))\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n            # Validate and repair if needed\n            if len(np.unique(new_solution)) != n:\n                missing = set(range(n)) - set(new_solution)\n                for m_node in missing:\n                    insert_pos = np.random.randint(0, n)\n                    new_solution = np.insert(new_solution, insert_pos, m_node)\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{An adaptive hybrid local search operator that combines a multi-objective aware segment relocation with a dynamic edge insertion strategy, guided by both crowding distance and Pareto dominance to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances and Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[:, i].max() - objectives[:, i].min() + 1e-8)\n\n    # Select solution with high crowding distance (exploration) or Pareto dominance (exploitation)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: multi-objective aware segment relocation + dynamic edge insertion\n    for _ in range(3):\n        # Select segment based on multi-objective potential\n        segment_length = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - segment_length)\n        segment = new_solution[a:a+segment_length]\n\n        # Calculate segment cost in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n        # Find insertion point with highest potential improvement\n        best_insert = a\n        best_improvement = 0\n\n        for insert_pos in range(n):\n            if insert_pos >= a and insert_pos < a + segment_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n            next_node = new_solution[insert_pos] if insert_pos < n else new_solution[0]\n\n            current_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            current_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n            improvement1 = segment_cost1 - current_cost1\n            improvement2 = segment_cost2 - current_cost2\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_insert = insert_pos\n\n        # Perform segment relocation\n        if best_insert != a:\n            new_solution = np.concatenate([\n                new_solution[:best_insert],\n                segment,\n                np.delete(new_solution, np.arange(a, a+segment_length))\n            ])\n\n        # Dynamic edge insertion\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Insert node j after node i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                [new_solution[j]],\n                new_solution[i+1:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.778435129753461,
            6.469183921813965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances and Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[:, i].max() - objectives[:, i].min() + 1e-8)\n\n    # Select solution with high crowding distance (exploration) or Pareto dominance (exploitation)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: multi-objective aware segment relocation + dynamic edge insertion\n    for _ in range(3):\n        # Select segment based on multi-objective potential\n        segment_length = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - segment_length)\n        segment = new_solution[a:a+segment_length]\n\n        # Calculate segment cost in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n        # Find insertion point with highest potential improvement\n        best_insert = a\n        best_improvement = 0\n\n        for insert_pos in range(n):\n            if insert_pos >= a and insert_pos < a + segment_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n            next_node = new_solution[insert_pos] if insert_pos < n else new_solution[0]\n\n            current_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            current_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n            improvement1 = segment_cost1 - current_cost1\n            improvement2 = segment_cost2 - current_cost2\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_insert = insert_pos\n\n        # Perform segment relocation\n        if best_insert != a:\n            new_solution = np.concatenate([\n                new_solution[:best_insert],\n                segment,\n                np.delete(new_solution, np.arange(a, a+segment_length))\n            ])\n\n        # Dynamic edge insertion\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Insert node j after node i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                [new_solution[j]],\n                new_solution[i+1:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment rotation with a multi-objective aware node insertion, prioritizing solutions with high potential for improvement by analyzing the angle between objectives and applying a dynamic selection pressure based on the current archive diversity while ensuring feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective angle (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    angles = np.arctan2(objectives[:,1], objectives[:,0])\n    selected_idx = np.argmax(angles)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        segment = new_solution[k:]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:] = np.roll(segment, rotation)\n\n    # Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Comprehensive validation\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.807177317084601,
            2.062056541442871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective angle (indicating potential for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    angles = np.arctan2(objectives[:,1], objectives[:,0])\n    selected_idx = np.argmax(angles)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        k = np.random.randint(1, n-2)\n        segment = new_solution[k:]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[k:] = np.roll(segment, rotation)\n\n    # Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Comprehensive validation\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment reversals with multi-objective edge swapping, dynamically prioritizing critical edges based on their potential to improve both objectives while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized\n    selected_idx = np.argmax(improvement_potential.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with multi-objective edge swapping\n    for _ in range(3):\n        # Randomly select segments to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-objective edge swapping\n        if np.random.rand() < 0.7:\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6442011173707135,
            1.7180119156837463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = 1 - normalized\n    selected_idx = np.argmax(improvement_potential.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive segment reversal with multi-objective edge swapping\n    for _ in range(3):\n        # Randomly select segments to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-objective edge swapping\n        if np.random.rand() < 0.7:\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The algorithm combines a multi-objective-aware segment relocation with a randomized edge reversal, prioritizing solutions with high crowding distance or Pareto dominance to explore less crowded regions while maintaining feasibility through careful edge selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue  # Skip current segment\n\n            # Calculate cost before relocation\n            if pos == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            elif pos == n:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[0]] + distance_matrix_1[new_solution[b-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[0]] + distance_matrix_2[new_solution[b-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif pos == n:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            if (improvement1 > 0) or (improvement2 > 0):\n                if (improvement1 + improvement2) > (best_improvement[0] + best_improvement[1]):\n                    best_pos = pos\n                    best_improvement = (improvement1, improvement2)\n\n        if best_pos != -1:\n            # Remove segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:],\n                segment\n            ])\n            if best_pos < a:\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8045771850418604,
            1.3191584348678589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue  # Skip current segment\n\n            # Calculate cost before relocation\n            if pos == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            elif pos == n:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[0]] + distance_matrix_1[new_solution[b-1], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[0]] + distance_matrix_2[new_solution[b-1], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n                original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n            # Calculate cost after relocation\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            elif pos == n:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            if (improvement1 > 0) or (improvement2 > 0):\n                if (improvement1 + improvement2) > (best_improvement[0] + best_improvement[1]):\n                    best_pos = pos\n                    best_improvement = (improvement1, improvement2)\n\n        if best_pos != -1:\n            # Remove segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:],\n                segment\n            ])\n            if best_pos < a:\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{An adaptive hybrid local search algorithm combines multi-objective edge swapping with dynamic segment relocations, prioritizing high-potential edges while using a probabilistic validation mechanism to maintain feasibility and explore diverse solution spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: multi-objective edge swapping with segment relocation\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            current = new_solution[i]\n            prev = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate potential improvement score\n            score = (distance_matrix_1[prev, next_node] + distance_matrix_2[prev, next_node] -\n                    distance_matrix_1[prev, current] - distance_matrix_2[prev, current])\n            edge_scores.append(score)\n\n        # Select top edges for modification\n        top_edges = np.argsort(edge_scores)[-3:]\n        for i in top_edges:\n            # Relocate the segment between the selected edges\n            a = i\n            b = (i + 2) % n\n            if a > b:\n                a, b = b, a\n\n            # Insert segment [a+1, b-1] after position b\n            segment = new_solution[a+1:b]\n            new_solution = np.concatenate([new_solution[:a+1], new_solution[b:], segment])\n\n            # Validate and repair if needed\n            if len(np.unique(new_solution)) != n:\n                # Probabilistic repair: swap conflicting nodes\n                duplicates = np.where(np.diff(new_solution) == 0)[0]\n                for d in duplicates:\n                    swap_pos = np.random.randint(0, n)\n                    new_solution[d], new_solution[swap_pos] = new_solution[swap_pos], new_solution[d]\n\n    return new_solution\n\n",
        "score": [
            -0.9287280072212187,
            3.4190192818641663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] * 0.6 + objectives[:, 1] * 0.4\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive hybrid operation: multi-objective edge swapping with segment relocation\n    for _ in range(3):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            current = new_solution[i]\n            prev = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate potential improvement score\n            score = (distance_matrix_1[prev, next_node] + distance_matrix_2[prev, next_node] -\n                    distance_matrix_1[prev, current] - distance_matrix_2[prev, current])\n            edge_scores.append(score)\n\n        # Select top edges for modification\n        top_edges = np.argsort(edge_scores)[-3:]\n        for i in top_edges:\n            # Relocate the segment between the selected edges\n            a = i\n            b = (i + 2) % n\n            if a > b:\n                a, b = b, a\n\n            # Insert segment [a+1, b-1] after position b\n            segment = new_solution[a+1:b]\n            new_solution = np.concatenate([new_solution[:a+1], new_solution[b:], segment])\n\n            # Validate and repair if needed\n            if len(np.unique(new_solution)) != n:\n                # Probabilistic repair: swap conflicting nodes\n                duplicates = np.where(np.diff(new_solution) == 0)[0]\n                for d in duplicates:\n                    swap_pos = np.random.randint(0, n)\n                    new_solution[d], new_solution[swap_pos] = new_solution[swap_pos], new_solution[d]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 2:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, c - a)\n        new_solution[a:b] = rotated_segment\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i+1, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7819487473173561,
            2.406254529953003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 2:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        rotated_segment = np.roll(segment, c - a)\n        new_solution[a:b] = rotated_segment\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i+1, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, guided by solution density and Pareto front proximity to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        rotated_segment = np.concatenate([new_solution[b:c], new_solution[a:b]])\n        new_solution[a:c] = rotated_segment\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8707413107302091,
            2.2358017563819885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        rotated_segment = np.concatenate([new_solution[b:c], new_solution[a:b]])\n        new_solution[a:c] = rotated_segment\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8669993832187759,
            2.0146886706352234
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9531954613959213,
            0.8526988625526428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment crossover with a dynamic edge reordering mechanism, prioritizing edges that show potential for Pareto improvement while maintaining feasibility through a probabilistic validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for Pareto improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment crossover\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create new segments by mixing the selected segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Calculate potential improvement for both objectives\n        cost1_before = distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[a-1], new_solution[a]]\n        cost2_before = distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[a]]\n\n        cost1_after = distance_matrix_1[new_solution[b-1], segment2[0]] + distance_matrix_1[segment2[-1], new_solution[a]]\n        cost2_after = distance_matrix_2[new_solution[b-1], segment2[0]] + distance_matrix_2[segment2[-1], new_solution[a]]\n\n        # Accept if at least one objective improves\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Dynamic edge reordering\n    if n > 2:\n        # Select a random edge to reorder\n        i = np.random.randint(0, n-1)\n\n        # Calculate current and potential new costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        # Try swapping with a random node\n        j = np.random.randint(0, n)\n        while j == i or j == i+1:\n            j = np.random.randint(0, n)\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # With 50% probability, repair by restoring a random missing node\n        if np.random.rand() < 0.5:\n            missing = list(set(range(n)) - set(new_solution))\n            if missing:\n                node = np.random.choice(missing)\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]  # Ensure length is preserved\n\n    return new_solution\n\n",
        "score": [
            -0.9315831281162557,
            0.8722702264785767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for Pareto improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment crossover\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create new segments by mixing the selected segments\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Calculate potential improvement for both objectives\n        cost1_before = distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[a-1], new_solution[a]]\n        cost2_before = distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[a-1], new_solution[a]]\n\n        cost1_after = distance_matrix_1[new_solution[b-1], segment2[0]] + distance_matrix_1[segment2[-1], new_solution[a]]\n        cost2_after = distance_matrix_2[new_solution[b-1], segment2[0]] + distance_matrix_2[segment2[-1], new_solution[a]]\n\n        # Accept if at least one objective improves\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Dynamic edge reordering\n    if n > 2:\n        # Select a random edge to reorder\n        i = np.random.randint(0, n-1)\n\n        # Calculate current and potential new costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        # Try swapping with a random node\n        j = np.random.randint(0, n)\n        while j == i or j == i+1:\n            j = np.random.randint(0, n)\n\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Probabilistic validation and repair\n    if len(np.unique(new_solution)) != n:\n        # With 50% probability, repair by restoring a random missing node\n        if np.random.rand() < 0.5:\n            missing = list(set(range(n)) - set(new_solution))\n            if missing:\n                node = np.random.choice(missing)\n                pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)\n                new_solution = new_solution[:n]  # Ensure length is preserved\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with high potential for improvement by analyzing the trade-off between objectives and performing targeted moves to diversify the search while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (highest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    potential_scores = [o1 + o2 for o1, o2 in objectives]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Identify the segment with highest average distance in either objective\n        segment_length = max(2, n // 5)\n        max_avg_cost = -1\n        best_a = 0\n\n        for a in range(0, n - segment_length + 1):\n            segment = new_solution[a:a+segment_length]\n            avg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length)) / (segment_length - 1)\n            avg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length)) / (segment_length - 1)\n            avg_cost = (avg_cost1 + avg_cost2) / 2\n\n            if avg_cost > max_avg_cost:\n                max_avg_cost = avg_cost\n                best_a = a\n\n        # Relocate this segment to a new position\n        if best_a != 0 and best_a + segment_length < n:\n            segment = new_solution[best_a:best_a+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:best_a],\n                new_solution[best_a+segment_length:],\n                segment\n            ])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        k = np.random.randint(2, min(5, n))\n        for _ in range(k):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8892950536709842,
            2.560612678527832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (highest sum of objectives)\n    objectives = [obj for _, obj in archive]\n    potential_scores = [o1 + o2 for o1, o2 in objectives]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        # Identify the segment with highest average distance in either objective\n        segment_length = max(2, n // 5)\n        max_avg_cost = -1\n        best_a = 0\n\n        for a in range(0, n - segment_length + 1):\n            segment = new_solution[a:a+segment_length]\n            avg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length)) / (segment_length - 1)\n            avg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length)) / (segment_length - 1)\n            avg_cost = (avg_cost1 + avg_cost2) / 2\n\n            if avg_cost > max_avg_cost:\n                max_avg_cost = avg_cost\n                best_a = a\n\n        # Relocate this segment to a new position\n        if best_a != 0 and best_a + segment_length < n:\n            segment = new_solution[best_a:best_a+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:best_a],\n                new_solution[best_a+segment_length:],\n                segment\n            ])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        k = np.random.randint(2, min(5, n))\n        for _ in range(k):\n            i, j = sorted(np.random.choice(n, size=2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation with multi-objective aware node swapping, using a dynamic selection mechanism that balances exploration and exploitation by prioritizing solutions with high crowding distance in the Pareto front while ensuring feasibility through a constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = segment\n\n    # Multi-objective aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        # Calculate cost before swap\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept swap if it improves at least one objective or is non-dominated\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 + 1e-8) or \\\n           (new_cost2 < original_cost2 and new_cost1 <= original_cost1 + 1e-8):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Constraint-aware repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.49172305342476785,
            2.277786672115326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(objectives.shape[1]):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = segment\n\n    # Multi-objective aware node swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n\n        # Calculate cost before swap\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept swap if it improves at least one objective or is non-dominated\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 + 1e-8) or \\\n           (new_cost2 < original_cost2 and new_cost1 <= original_cost1 + 1e-8):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Constraint-aware repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This algorithm combines multi-objective edge selection with adaptive segment swapping, prioritizing edges that show potential for improvement in both objective spaces while dynamically adjusting segment lengths to maintain diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores based on both objectives\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        current = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        edge_scores[i] = 0.5 * (distance_matrix_1[current, next_node] + distance_matrix_2[current, next_node])\n\n    # Adaptive segment swapping based on edge importance\n    for _ in range(5):\n        # Select critical edges to prioritize\n        critical_edges = np.argsort(edge_scores)[-3:]\n        a, b, c = np.random.choice(critical_edges, size=3, replace=False)\n\n        # Swap segments between critical edges\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Advanced repair: reconstruct tour using remaining nodes\n        remaining = set(range(n)) - set(new_solution)\n        for node in remaining:\n            # Insert at position that minimizes both objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                temp_sol = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]] for j in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]] for j in range(n))\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7767418571777063,
            0.7285872101783752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores based on both objectives\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        current = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        edge_scores[i] = 0.5 * (distance_matrix_1[current, next_node] + distance_matrix_2[current, next_node])\n\n    # Adaptive segment swapping based on edge importance\n    for _ in range(5):\n        # Select critical edges to prioritize\n        critical_edges = np.argsort(edge_scores)[-3:]\n        a, b, c = np.random.choice(critical_edges, size=3, replace=False)\n\n        # Swap segments between critical edges\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Advanced repair: reconstruct tour using remaining nodes\n        remaining = set(range(n)) - set(new_solution)\n        for node in remaining:\n            # Insert at position that minimizes both objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                temp_sol = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[temp_sol[j], temp_sol[(j+1)%n]] for j in range(n))\n                cost2 = sum(distance_matrix_2[temp_sol[j], temp_sol[(j+1)%n]] for j in range(n))\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, guided by a combination of crowding distance and Pareto dominance to explore under-explored regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7952708473594157,
            1.1226165890693665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        k = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, k)\n\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9600321155442478,
            2.2623770236968994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        k = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, k)\n\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{A novel local search operator that combines a multi-objective aware segment relocation with a randomized edge inversion, prioritizing solutions with high crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        # Find insertion point that improves at least one objective\n        best_insert = a\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for pos in range(n - len(segment) + 1):\n            if pos == a:\n                continue\n\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            for i in range(n-1):\n                cost1 += distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n                cost2 += distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_cost1, best_cost2 = cost1, cost2\n                best_insert = pos\n\n        new_solution = np.concatenate([new_solution[:best_insert], segment, new_solution[best_insert:]])\n\n    # Step 2: Randomized edge inversion\n    if n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before inversion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after inversion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept inversion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8725946847224766,
            5.459959387779236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        # Find insertion point that improves at least one objective\n        best_insert = a\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for pos in range(n - len(segment) + 1):\n            if pos == a:\n                continue\n\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            for i in range(n-1):\n                cost1 += distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n                cost2 += distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n            if (cost1 < best_cost1) or (cost2 < best_cost2):\n                best_cost1, best_cost2 = cost1, cost2\n                best_insert = pos\n\n        new_solution = np.concatenate([new_solution[:best_insert], segment, new_solution[best_insert:]])\n\n    # Step 2: Randomized edge inversion\n    if n > 2:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before inversion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after inversion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept inversion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a dominance-aware node insertion, prioritizing solutions with higher Pareto dominance to guide the search toward non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with Pareto dominance\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for other_obj in [o for s, o in archive]:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if pareto_front:\n        selected_idx = np.random.choice(len(pareto_front))\n        base_solution = pareto_front[selected_idx].copy()\n    else:\n        selected_idx = np.random.choice(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 2:\n        k = np.random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    # Step 2: Dominance-aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8647808973070681,
            2.9439640045166016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with Pareto dominance\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for other_obj in [o for s, o in archive]:\n            if (other_obj[0] < obj[0] and other_obj[1] < obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if pareto_front:\n        selected_idx = np.random.choice(len(pareto_front))\n        base_solution = pareto_front[selected_idx].copy()\n    else:\n        selected_idx = np.random.choice(len(archive))\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment rotation\n    if n > 2:\n        k = np.random.randint(1, n-1)\n        new_solution = np.roll(new_solution, k)\n\n    # Step 2: Dominance-aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{A novel hybrid local search algorithm combines segment reversals with edge swaps, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment reversal with edge swap\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Reverse segment [a, b] and swap with segment [c, d]\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9590202029850503,
            0.8584923148155212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment reversal with edge swap\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Reverse segment [a, b] and swap with segment [c, d]\n        segment1 = new_solution[a:b+1][::-1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment reversal with multi-objective edge prioritization, dynamically balancing improvements in both objective spaces while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective prioritization\n    for _ in range(3):\n        # Identify segments with potential for improvement\n        segment_scores = []\n        for i in range(n-1):\n            for j in range(i+1, min(i+5, n-1)):\n                # Calculate improvement potential in both objectives\n                old_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n                old_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n                # Weighted improvement score\n                score = (new_cost1 - old_cost1) / (old_cost1 + 1e-8) + (new_cost2 - old_cost2) / (old_cost2 + 1e-8)\n                segment_scores.append((score, i, j))\n\n        if not segment_scores:\n            break\n\n        # Select top 3 segments and reverse them with probability based on score\n        segment_scores.sort(reverse=True, key=lambda x: x[0])\n        for score, i, j in segment_scores[:3]:\n            if np.random.rand() < 0.7 * (1 - np.exp(-score)):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Probabilistic repair if invalid\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        np.random.shuffle(missing)\n        for pos in range(n):\n            if new_solution[pos] not in missing:\n                continue\n            # Insert missing node at this position with probability\n            if np.random.rand() < 0.5:\n                new_solution[pos] = missing.pop(0)\n                if not missing:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.7929156132035056,
            8.783114671707153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective prioritization\n    for _ in range(3):\n        # Identify segments with potential for improvement\n        segment_scores = []\n        for i in range(n-1):\n            for j in range(i+1, min(i+5, n-1)):\n                # Calculate improvement potential in both objectives\n                old_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n                old_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n                # Weighted improvement score\n                score = (new_cost1 - old_cost1) / (old_cost1 + 1e-8) + (new_cost2 - old_cost2) / (old_cost2 + 1e-8)\n                segment_scores.append((score, i, j))\n\n        if not segment_scores:\n            break\n\n        # Select top 3 segments and reverse them with probability based on score\n        segment_scores.sort(reverse=True, key=lambda x: x[0])\n        for score, i, j in segment_scores[:3]:\n            if np.random.rand() < 0.7 * (1 - np.exp(-score)):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Probabilistic repair if invalid\n    if len(np.unique(new_solution)) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        np.random.shuffle(missing)\n        for pos in range(n):\n            if new_solution[pos] not in missing:\n                continue\n            # Insert missing node at this position with probability\n            if np.random.rand() < 0.5:\n                new_solution[pos] = missing.pop(0)\n                if not missing:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{A novel hybrid local search algorithm that combines a dynamic path reversal with a multi-objective aware node insertion strategy, using a dominance-based selection mechanism to prioritize solutions with unexplored trade-off regions while ensuring feasibility through a comprehensive validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance count (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic path reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective aware node insertion\n    if n > 4:\n        # Select a node to insert\n        node_to_insert = np.random.choice(new_solution)\n        insert_pos = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]]\n        original_cost2 = distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[insert_pos-1], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[insert_pos]]\n        new_cost2 = distance_matrix_2[new_solution[insert_pos-1], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[insert_pos]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9415732126282962,
            2.42681086063385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance count (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic path reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective aware node insertion\n    if n > 4:\n        # Select a node to insert\n        node_to_insert = np.random.choice(new_solution)\n        insert_pos = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]]\n        original_cost2 = distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[insert_pos-1], node_to_insert] + distance_matrix_1[node_to_insert, new_solution[insert_pos]]\n        new_cost2 = distance_matrix_2[new_solution[insert_pos-1], node_to_insert] + distance_matrix_2[node_to_insert, new_solution[insert_pos]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with higher crowding distance or Pareto dominance to guide the search toward unexplored regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Calculate cost before and after relocation\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n        # Revert if relocation worsens both objectives\n        if (new_cost1 > original_cost1 and new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8645194544625343,
            2.095259964466095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Calculate cost before and after relocation\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n        # Revert if relocation worsens both objectives\n        if (new_cost1 > original_cost1 and new_cost2 > original_cost2):\n            new_solution = base_solution.copy()\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware path relinking with a randomized segment crossover, prioritizing solutions with high diversity in the archive to guide the search toward unexplored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware path relinking + randomized segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware path relinking\n    if n > 3:\n        # Find a reference solution from the archive\n        ref_idx = np.random.choice(len(archive))\n        ref_solution = archive[ref_idx][0]\n\n        # Identify common segments between base and reference solutions\n        common_indices = np.where(np.isin(base_solution, ref_solution))[0]\n        if len(common_indices) > 1:\n            # Relink segments to improve both objectives\n            for i in range(len(common_indices) - 1):\n                a, b = common_indices[i], common_indices[i+1]\n                if a < b - 1:\n                    # Calculate cost before relinking\n                    original_cost1 = distance_matrix_1[base_solution[a], base_solution[a+1]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n                    original_cost2 = distance_matrix_2[base_solution[a], base_solution[a+1]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n\n                    # Calculate cost after relinking\n                    new_cost1 = distance_matrix_1[base_solution[a], ref_solution[np.where(ref_solution == base_solution[a+1])[0][0]+1]] + distance_matrix_1[ref_solution[np.where(ref_solution == base_solution[b-1])[0][0]-1], base_solution[b]]\n                    new_cost2 = distance_matrix_2[base_solution[a], ref_solution[np.where(ref_solution == base_solution[a+1])[0][0]+1]] + distance_matrix_2[ref_solution[np.where(ref_solution == base_solution[b-1])[0][0]-1], base_solution[b]]\n\n                    # Accept relinking if it improves at least one objective\n                    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                        new_solution[a+1:b] = ref_solution[np.where(ref_solution == base_solution[a+1])[0][0]+1:np.where(ref_solution == base_solution[b-1])[0][0]]\n\n    # Step 2: Randomized segment crossover\n    if n > 4:\n        # Select two random segments and swap them\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Ensure segments are of similar length\n        if abs(b - a) == abs(d - c):\n            temp = new_solution[a:b].copy()\n            new_solution[a:b] = new_solution[c:d]\n            new_solution[c:d] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5529020882907086,
            5.018158257007599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware path relinking + randomized segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware path relinking\n    if n > 3:\n        # Find a reference solution from the archive\n        ref_idx = np.random.choice(len(archive))\n        ref_solution = archive[ref_idx][0]\n\n        # Identify common segments between base and reference solutions\n        common_indices = np.where(np.isin(base_solution, ref_solution))[0]\n        if len(common_indices) > 1:\n            # Relink segments to improve both objectives\n            for i in range(len(common_indices) - 1):\n                a, b = common_indices[i], common_indices[i+1]\n                if a < b - 1:\n                    # Calculate cost before relinking\n                    original_cost1 = distance_matrix_1[base_solution[a], base_solution[a+1]] + distance_matrix_1[base_solution[b-1], base_solution[b]]\n                    original_cost2 = distance_matrix_2[base_solution[a], base_solution[a+1]] + distance_matrix_2[base_solution[b-1], base_solution[b]]\n\n                    # Calculate cost after relinking\n                    new_cost1 = distance_matrix_1[base_solution[a], ref_solution[np.where(ref_solution == base_solution[a+1])[0][0]+1]] + distance_matrix_1[ref_solution[np.where(ref_solution == base_solution[b-1])[0][0]-1], base_solution[b]]\n                    new_cost2 = distance_matrix_2[base_solution[a], ref_solution[np.where(ref_solution == base_solution[a+1])[0][0]+1]] + distance_matrix_2[ref_solution[np.where(ref_solution == base_solution[b-1])[0][0]-1], base_solution[b]]\n\n                    # Accept relinking if it improves at least one objective\n                    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n                        new_solution[a+1:b] = ref_solution[np.where(ref_solution == base_solution[a+1])[0][0]+1:np.where(ref_solution == base_solution[b-1])[0][0]]\n\n    # Step 2: Randomized segment crossover\n    if n > 4:\n        # Select two random segments and swap them\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Ensure segments are of similar length\n        if abs(b - a) == abs(d - c):\n            temp = new_solution[a:b].copy()\n            new_solution[a:b] = new_solution[c:d]\n            new_solution[c:d] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines objective-aware node relocations with dynamic segment merging, guided by Pareto frontier proximity and crowding distance, while preserving feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto frontier proximity and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node relocation\n    for _ in range(3):\n        # Select nodes based on their contribution to each objective\n        node1 = np.random.choice(n)\n        node2 = np.random.choice(n)\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[node1-1], new_solution[node1]] + distance_matrix_1[new_solution[node2-1], new_solution[node2]]\n        current_cost2 = distance_matrix_2[new_solution[node1-1], new_solution[node1]] + distance_matrix_2[new_solution[node2-1], new_solution[node2]]\n\n        # Try swapping nodes\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n        new_cost1 = distance_matrix_1[new_solution[node1-1], new_solution[node1]] + distance_matrix_1[new_solution[node2-1], new_solution[node2]]\n        new_cost2 = distance_matrix_2[new_solution[node1-1], new_solution[node1]] + distance_matrix_2[new_solution[node2-1], new_solution[node2]]\n\n        # Accept if improves at least one objective\n        if not ((new_cost1 < current_cost1) or (new_cost2 < current_cost2)):\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Dynamic segment merging\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n\n        # Merge segments with probability based on their lengths\n        if np.random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        missing = sorted(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8429519434591525,
            1.0163264870643616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto frontier proximity and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node relocation\n    for _ in range(3):\n        # Select nodes based on their contribution to each objective\n        node1 = np.random.choice(n)\n        node2 = np.random.choice(n)\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[node1-1], new_solution[node1]] + distance_matrix_1[new_solution[node2-1], new_solution[node2]]\n        current_cost2 = distance_matrix_2[new_solution[node1-1], new_solution[node1]] + distance_matrix_2[new_solution[node2-1], new_solution[node2]]\n\n        # Try swapping nodes\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n        new_cost1 = distance_matrix_1[new_solution[node1-1], new_solution[node1]] + distance_matrix_1[new_solution[node2-1], new_solution[node2]]\n        new_cost2 = distance_matrix_2[new_solution[node1-1], new_solution[node1]] + distance_matrix_2[new_solution[node2-1], new_solution[node2]]\n\n        # Accept if improves at least one objective\n        if not ((new_cost1 < current_cost1) or (new_cost2 < current_cost2)):\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Dynamic segment merging\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n\n        # Merge segments with probability based on their lengths\n        if np.random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        missing = sorted(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swaps with objective-aware segment inversions, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for trade-off improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with objective-aware segment inversion\n    for _ in range(5):\n        # Select edges based on potential improvement in both objectives\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            # Perform edge swap\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8391957124588638,
            1.8241150379180908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for trade-off improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with objective-aware segment inversion\n    for _ in range(5):\n        # Select edges based on potential improvement in both objectives\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            # Perform edge swap\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{An adaptive multi-segment relocation algorithm that dynamically combines edge-based swaps with objective-aware segment inversions, prioritizing regions of the solution with high potential for multi-objective improvement while maintaining feasibility through a hybrid validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (balances both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-segment relocation\n    for _ in range(3):\n        # Select segments based on objective-aware distance\n        segment_length = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n\n        # Calculate segment cost in both objectives\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b-1))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b-1))\n\n        # Find insertion point with potential improvement\n        best_pos = None\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate potential improvement\n            improvement1 = (segment_cost1 -\n                          (distance_matrix_1[new_solution[a-1], new_solution[a]] if a > 0 else 0) -\n                          (distance_matrix_1[new_solution[b-1], new_solution[b]] if b < n-1 else 0) +\n                          (distance_matrix_1[new_solution[pos-1], new_solution[a]] if pos > 0 else 0) +\n                          (distance_matrix_1[new_solution[b-1], new_solution[pos]] if pos < n-1 else 0))\n\n            improvement2 = (segment_cost2 -\n                          (distance_matrix_2[new_solution[a-1], new_solution[a]] if a > 0 else 0) -\n                          (distance_matrix_2[new_solution[b-1], new_solution[b]] if b < n-1 else 0) +\n                          (distance_matrix_2[new_solution[pos-1], new_solution[a]] if pos > 0 else 0) +\n                          (distance_matrix_2[new_solution[b-1], new_solution[pos]] if pos < n-1 else 0))\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        if best_pos is not None:\n            # Relocate segment\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n            # Insert at best position\n            if best_pos > a:\n                best_pos -= (b - a)\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Objective-aware segment inversion\n    if n > 3:\n        # Find segment with high potential for inversion\n        best_segment = None\n        best_gain = 0\n\n        for a in range(n):\n            for b in range(a+2, min(a+10, n)):\n                # Calculate current cost\n                current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] if a > 0 else 0) + \\\n                               (distance_matrix_1[new_solution[b-1], new_solution[b]] if b < n-1 else 0)\n\n                current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] if a > 0 else 0) + \\\n                               (distance_matrix_2[new_solution[b-1], new_solution[b]] if b < n-1 else 0)\n\n                # Calculate inverted cost\n                inverted_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] if a > 0 else 0) + \\\n                                (distance_matrix_1[new_solution[a], new_solution[b]] if b < n-1 else 0)\n\n                inverted_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] if a > 0 else 0) + \\\n                                (distance_matrix_2[new_solution[a], new_solution[b]] if b < n-1 else 0)\n\n                gain1 = current_cost1 - inverted_cost1\n                gain2 = current_cost2 - inverted_cost2\n\n                if gain1 + gain2 > best_gain:\n                    best_gain = gain1 + gain2\n                    best_segment = (a, b)\n\n        if best_segment and best_gain > 0:\n            a, b = best_segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution from scratch\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, np.array(list(missing))])\n\n    return new_solution\n\n",
        "score": [
            -0.8964637936263967,
            7.085438430309296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (balances both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-segment relocation\n    for _ in range(3):\n        # Select segments based on objective-aware distance\n        segment_length = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n\n        # Calculate segment cost in both objectives\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b-1))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b-1))\n\n        # Find insertion point with potential improvement\n        best_pos = None\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate potential improvement\n            improvement1 = (segment_cost1 -\n                          (distance_matrix_1[new_solution[a-1], new_solution[a]] if a > 0 else 0) -\n                          (distance_matrix_1[new_solution[b-1], new_solution[b]] if b < n-1 else 0) +\n                          (distance_matrix_1[new_solution[pos-1], new_solution[a]] if pos > 0 else 0) +\n                          (distance_matrix_1[new_solution[b-1], new_solution[pos]] if pos < n-1 else 0))\n\n            improvement2 = (segment_cost2 -\n                          (distance_matrix_2[new_solution[a-1], new_solution[a]] if a > 0 else 0) -\n                          (distance_matrix_2[new_solution[b-1], new_solution[b]] if b < n-1 else 0) +\n                          (distance_matrix_2[new_solution[pos-1], new_solution[a]] if pos > 0 else 0) +\n                          (distance_matrix_2[new_solution[b-1], new_solution[pos]] if pos < n-1 else 0))\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        if best_pos is not None:\n            # Relocate segment\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n            # Insert at best position\n            if best_pos > a:\n                best_pos -= (b - a)\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Objective-aware segment inversion\n    if n > 3:\n        # Find segment with high potential for inversion\n        best_segment = None\n        best_gain = 0\n\n        for a in range(n):\n            for b in range(a+2, min(a+10, n)):\n                # Calculate current cost\n                current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] if a > 0 else 0) + \\\n                               (distance_matrix_1[new_solution[b-1], new_solution[b]] if b < n-1 else 0)\n\n                current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] if a > 0 else 0) + \\\n                               (distance_matrix_2[new_solution[b-1], new_solution[b]] if b < n-1 else 0)\n\n                # Calculate inverted cost\n                inverted_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] if a > 0 else 0) + \\\n                                (distance_matrix_1[new_solution[a], new_solution[b]] if b < n-1 else 0)\n\n                inverted_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] if a > 0 else 0) + \\\n                                (distance_matrix_2[new_solution[a], new_solution[b]] if b < n-1 else 0)\n\n                gain1 = current_cost1 - inverted_cost1\n                gain2 = current_cost2 - inverted_cost2\n\n                if gain1 + gain2 > best_gain:\n                    best_gain = gain1 + gain2\n                    best_segment = (a, b)\n\n        if best_segment and best_gain > 0:\n            a, b = best_segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair\n    if len(np.unique(new_solution)) != n:\n        # Reconstruct solution from scratch\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, np.array(list(missing))])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This novel algorithm combines adaptive segment relocations with multi-objective edge prioritization, dynamically balancing local and global improvements while ensuring feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with multi-objective prioritization\n    for _ in range(5):\n        # Identify promising edges in both objectives\n        potential_edges = []\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            potential_edges.append((cost1 + cost2, i))\n\n        potential_edges.sort(key=lambda x: x[0], reverse=True)\n\n        # Select top 3 edges for potential relocation\n        for _, edge_idx in potential_edges[:3]:\n            a, b = edge_idx, edge_idx + 1\n            if a > b:\n                a, b = b, a\n\n            # Relocate segment with probabilistic validation\n            if np.random.random() < 0.7:  # 70% chance to relocate\n                segment = new_solution[a:b+1]\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n                # Check validity with probability\n                if np.random.random() < 0.3 and len(np.unique(new_solution)) != n:\n                    # Repair by restoring original segment\n                    new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:]])\n                break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Create a complete permutation\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n\n    return new_solution\n\n",
        "score": [
            -0.9180848004498764,
            3.445190727710724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with multi-objective prioritization\n    for _ in range(5):\n        # Identify promising edges in both objectives\n        potential_edges = []\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            potential_edges.append((cost1 + cost2, i))\n\n        potential_edges.sort(key=lambda x: x[0], reverse=True)\n\n        # Select top 3 edges for potential relocation\n        for _, edge_idx in potential_edges[:3]:\n            a, b = edge_idx, edge_idx + 1\n            if a > b:\n                a, b = b, a\n\n            # Relocate segment with probabilistic validation\n            if np.random.random() < 0.7:  # 70% chance to relocate\n                segment = new_solution[a:b+1]\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n                # Check validity with probability\n                if np.random.random() < 0.3 and len(np.unique(new_solution)) != n:\n                    # Repair by restoring original segment\n                    new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:]])\n                break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Create a complete permutation\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm combines a multi-objective aware segment relocation with a randomized edge reversal, prioritizing solutions with higher crowding distance or Pareto dominance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = np.random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7805786126358321,
            2.4327850937843323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = np.random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node displacement with a multi-objective aware segment rotation, prioritizing solutions with high diversity in the archive to guide the search toward unexplored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (randomly for simplicity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node displacement\n    if n > 2:\n        k = np.random.randint(1, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Multi-objective aware segment rotation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate cost before rotation\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Rotate segment (left or right)\n        if np.random.rand() > 0.5:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        new_solution[a:b] = segment\n\n        # Calculate cost after rotation\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Revert if rotation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.708582686456677,
            1.8388471007347107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (randomly for simplicity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node displacement\n    if n > 2:\n        k = np.random.randint(1, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Multi-objective aware segment rotation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate cost before rotation\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Rotate segment (left or right)\n        if np.random.rand() > 0.5:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        new_solution[a:b] = segment\n\n        # Calculate cost after rotation\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Revert if rotation worsens both objectives\n        if (new_cost1 > original_cost1) and (new_cost2 > original_cost2):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware node relocation with a guided segment crossover, prioritizing nodes with high potential for improvement in both objectives while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with guided segment crossover\n    for _ in range(5):\n        # Select a node with high potential improvement\n        node_scores = []\n        for i in range(n):\n            # Calculate potential improvement in both objectives\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1) % n]\n            current_cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n            current_cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n\n            # Try relocating to a random position\n            new_pos = np.random.randint(0, n)\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n            new_cost1 = distance_matrix_1[new_prev, new_solution[i]] + distance_matrix_1[new_solution[i], new_next]\n            new_cost2 = distance_matrix_2[new_prev, new_solution[i]] + distance_matrix_2[new_solution[i], new_next]\n\n            # Score based on improvement in both objectives\n            score = (current_cost1 - new_cost1) * (current_cost2 - new_cost2)\n            node_scores.append(score)\n\n        # Select node with highest improvement potential\n        if node_scores:\n            selected_node_idx = np.argmax(node_scores)\n            selected_node = new_solution[selected_node_idx]\n\n            # Perform relocation\n            new_pos = np.random.randint(0, n)\n            if new_pos > selected_node_idx:\n                new_solution = np.concatenate([new_solution[:selected_node_idx], new_solution[selected_node_idx+1:new_pos], [selected_node], new_solution[new_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:new_pos], [selected_node], new_solution[new_pos:selected_node_idx], new_solution[selected_node_idx+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8139874528443171,
            2.8073110580444336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with guided segment crossover\n    for _ in range(5):\n        # Select a node with high potential improvement\n        node_scores = []\n        for i in range(n):\n            # Calculate potential improvement in both objectives\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1) % n]\n            current_cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n            current_cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n\n            # Try relocating to a random position\n            new_pos = np.random.randint(0, n)\n            new_prev = new_solution[new_pos-1]\n            new_next = new_solution[new_pos]\n            new_cost1 = distance_matrix_1[new_prev, new_solution[i]] + distance_matrix_1[new_solution[i], new_next]\n            new_cost2 = distance_matrix_2[new_prev, new_solution[i]] + distance_matrix_2[new_solution[i], new_next]\n\n            # Score based on improvement in both objectives\n            score = (current_cost1 - new_cost1) * (current_cost2 - new_cost2)\n            node_scores.append(score)\n\n        # Select node with highest improvement potential\n        if node_scores:\n            selected_node_idx = np.argmax(node_scores)\n            selected_node = new_solution[selected_node_idx]\n\n            # Perform relocation\n            new_pos = np.random.randint(0, n)\n            if new_pos > selected_node_idx:\n                new_solution = np.concatenate([new_solution[:selected_node_idx], new_solution[selected_node_idx+1:new_pos], [selected_node], new_solution[new_pos:]])\n            else:\n                new_solution = np.concatenate([new_solution[:new_pos], [selected_node], new_solution[new_pos:selected_node_idx], new_solution[selected_node_idx+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-aware edge insertion, prioritizing solutions with higher crowding distance or Pareto dominance to explore diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Pareto-aware edge insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9158226549063855,
            1.8501243591308594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Pareto-aware edge insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware segment relocation with a randomized edge crossing, prioritizing solutions with high hypervolume contribution to guide the search toward diverse and high-quality regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high hypervolume contribution\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Step 2: Randomized edge crossing\n    if n > 4:\n        i, j, k, l = sorted(np.random.choice(n, size=4, replace=False))\n        # Calculate cost before crossing\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Calculate cost after crossing\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[k]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[l]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[k]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[l]])\n\n        # Accept crossing if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9448095756686068,
            2.468532085418701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high hypervolume contribution\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relocation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Step 2: Randomized edge crossing\n    if n > 4:\n        i, j, k, l = sorted(np.random.choice(n, size=4, replace=False))\n        # Calculate cost before crossing\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Calculate cost after crossing\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[k]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[l]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[k]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[l]])\n\n        # Accept crossing if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node reassignment with a dynamic segment crossover, prioritizing solutions with high potential for improvement by analyzing both objective gradients and solution structure, while ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (considering both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized.sum(axis=1) * (1 - objectives[:, 0] / objectives[:, 1] + 1e-8)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node reassignment with dynamic segment crossover\n    if n > 3:\n        # Identify critical segments based on both objectives\n        segment_length = max(2, n // 4)\n        for _ in range(3):\n            a = np.random.randint(0, n - segment_length)\n            b = a + segment_length\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n            segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n            # Find a better segment to crossover\n            for _ in range(3):\n                c = np.random.randint(0, n - segment_length)\n                d = c + segment_length\n\n                # Calculate potential new segment costs\n                new_segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(c, d+1))\n                new_segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(c, d+1))\n\n                # Accept if it improves at least one objective\n                if (new_segment_cost1 < segment_cost1) or (new_segment_cost2 < segment_cost2):\n                    # Perform crossover\n                    new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1].copy(), new_solution[a:b+1].copy()\n                    break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes at optimal positions\n        missing = sorted(set(range(n)) - set(new_solution))\n        for node in missing:\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n):\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                if cost1 + cost2 < min_cost:\n                    min_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8851216254353437,
            2.7885323762893677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (considering both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_potential = normalized.sum(axis=1) * (1 - objectives[:, 0] / objectives[:, 1] + 1e-8)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node reassignment with dynamic segment crossover\n    if n > 3:\n        # Identify critical segments based on both objectives\n        segment_length = max(2, n // 4)\n        for _ in range(3):\n            a = np.random.randint(0, n - segment_length)\n            b = a + segment_length\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n            segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n\n            # Find a better segment to crossover\n            for _ in range(3):\n                c = np.random.randint(0, n - segment_length)\n                d = c + segment_length\n\n                # Calculate potential new segment costs\n                new_segment_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(c, d+1))\n                new_segment_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(c, d+1))\n\n                # Accept if it improves at least one objective\n                if (new_segment_cost1 < segment_cost1) or (new_segment_cost2 < segment_cost2):\n                    # Perform crossover\n                    new_solution[a:b+1], new_solution[c:d+1] = new_solution[c:d+1].copy(), new_solution[a:b+1].copy()\n                    break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes at optimal positions\n        missing = sorted(set(range(n)) - set(new_solution))\n        for node in missing:\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(n):\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                if cost1 + cost2 < min_cost:\n                    min_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware edge insertion, prioritizing solutions with higher crowding distance or Pareto dominance to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8002144503401161,
            1.2489466667175293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a Pareto-optimality-aware edge insertion, prioritizing solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + Pareto-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Pareto-aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it is Pareto-dominant\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8563107457642911,
            1.1945406794548035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + Pareto-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Pareto-aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it is Pareto-dominant\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment reversal with multi-objective edge swapping, where segments are selected based on their potential to improve both objectives while maintaining feasibility through a dynamic validation and repair mechanism using node reinsertion and edge rebalancing.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective edge swapping\n    for _ in range(3):\n        # Select segment to reverse based on potential improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Reverse the segment\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Perform edge swapping between objectives\n        for i in range(start, end - 1):\n            if np.random.rand() < 0.3:  # 30% chance to swap edges\n                j = np.random.randint(start, end)\n                if i != j:\n                    # Calculate potential improvement\n                    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                    # Swap if improvement in at least one objective\n                    if (new_cost1 < current_cost1 or new_cost2 < current_cost2) and new_cost1 + new_cost2 < current_cost1 + current_cost2:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Dynamic repair: reinsert missing nodes with edge balancing\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find best insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(n):\n                if pos > 0 and new_solution[pos-1] == node:\n                    continue\n                if pos < n-1 and new_solution[pos+1] == node:\n                    continue\n\n                # Calculate insertion cost for both objectives\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_score:\n                    best_score = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8296360699162195,
            1.4694371223449707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective edge swapping\n    for _ in range(3):\n        # Select segment to reverse based on potential improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Reverse the segment\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Perform edge swapping between objectives\n        for i in range(start, end - 1):\n            if np.random.rand() < 0.3:  # 30% chance to swap edges\n                j = np.random.randint(start, end)\n                if i != j:\n                    # Calculate potential improvement\n                    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                    # Swap if improvement in at least one objective\n                    if (new_cost1 < current_cost1 or new_cost2 < current_cost2) and new_cost1 + new_cost2 < current_cost1 + current_cost2:\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Dynamic repair: reinsert missing nodes with edge balancing\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find best insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n            for pos in range(n):\n                if pos > 0 and new_solution[pos-1] == node:\n                    continue\n                if pos < n-1 and new_solution[pos+1] == node:\n                    continue\n\n                # Calculate insertion cost for both objectives\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_score:\n                    best_score = total_cost\n                    best_pos = pos\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A novel hybrid local search algorithm combines guided edge swaps with probabilistic segment reversals, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with probabilistic segment reversals\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Probabilistically reverse a segment\n        if np.random.rand() < 0.3:\n            rev_start, rev_end = np.random.choice(n, size=2, replace=False)\n            if rev_start > rev_end:\n                rev_start, rev_end = rev_end, rev_start\n            new_solution[rev_start:rev_end+1] = new_solution[rev_start:rev_end+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9443399069962503,
            1.1400819420814514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: guided edge swaps with probabilistic segment reversals\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Probabilistically reverse a segment\n        if np.random.rand() < 0.3:\n            rev_start, rev_end = np.random.choice(n, size=2, replace=False)\n            if rev_start > rev_end:\n                rev_start, rev_end = rev_end, rev_start\n            new_solution[rev_start:rev_end+1] = new_solution[rev_start:rev_end+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel hybrid local search operator that combines a randomized partial tour reversal with a multi-objective aware node insertion, leveraging the solution's objective values to guide the search toward more balanced improvements in both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized partial tour reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i - 1) % n or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7857279956220417,
            1.880832552909851
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized partial tour reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i - 1) % n or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive and applies a hybrid local search combining a randomized node relocation with a multi-objective aware 3-opt move, prioritizing solutions with better Pareto dominance or crowding distance to explore less crowded regions of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with better Pareto dominance or crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before 3-opt\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Calculate cost after 3-opt\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                     distance_matrix_1[new_solution[a], new_solution[c-1]] +\n                     distance_matrix_1[new_solution[b], new_solution[c]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                     distance_matrix_2[new_solution[a], new_solution[c-1]] +\n                     distance_matrix_2[new_solution[b], new_solution[c]])\n\n        # Accept 3-opt if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7478462026967586,
            1.5551919341087341
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with better Pareto dominance or crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before 3-opt\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Calculate cost after 3-opt\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                     distance_matrix_1[new_solution[a], new_solution[c-1]] +\n                     distance_matrix_1[new_solution[b], new_solution[c]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                     distance_matrix_2[new_solution[a], new_solution[c-1]] +\n                     distance_matrix_2[new_solution[b], new_solution[c]])\n\n        # Accept 3-opt if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment reversal with an adaptive multi-objective edge insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward unexplored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: probabilistic segment reversal + adaptive edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Adaptive edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1 * 1.1) or (new_cost2 < original_cost2 * 1.1):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8719773200834893,
            1.4101378917694092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: probabilistic segment reversal + adaptive edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Adaptive edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1 * 1.1) or (new_cost2 < original_cost2 * 1.1):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware segment rotation with a guided edge elimination strategy, where segments are rotated based on their potential for improving both objectives, while edges are eliminated and reinserted in positions that optimize the combined cost across both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    combined = objectives.sum(axis=1)\n    selected_idx = np.argmax(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment rotation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement for both objectives\n        prev_node = new_solution[a-1]\n        next_node = new_solution[b-1]\n\n        # Rotate segment in both directions and evaluate\n        rotated_cw = np.roll(segment, 1)\n        rotated_ccw = np.roll(segment, -1)\n\n        # Calculate costs for original and rotated segments\n        original_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        original_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        cost_cw1 = distance_matrix_1[prev_node, rotated_cw[0]] + distance_matrix_1[rotated_cw[-1], next_node]\n        cost_cw2 = distance_matrix_2[prev_node, rotated_cw[0]] + distance_matrix_2[rotated_cw[-1], next_node]\n\n        cost_ccw1 = distance_matrix_1[prev_node, rotated_ccw[0]] + distance_matrix_1[rotated_ccw[-1], next_node]\n        cost_ccw2 = distance_matrix_2[prev_node, rotated_ccw[0]] + distance_matrix_2[rotated_ccw[-1], next_node]\n\n        # Choose the rotation that improves both objectives\n        if (cost_cw1 < original_cost1 and cost_cw2 < original_cost2) or \\\n           (cost_ccw1 < original_cost1 and cost_ccw2 < original_cost2):\n            if cost_cw1 + cost_cw2 < cost_ccw1 + cost_ccw2:\n                new_solution[a:b] = rotated_cw\n            else:\n                new_solution[a:b] = rotated_ccw\n\n    # Step 2: Guided edge elimination and reinsertion\n    if n > 3:\n        # Select an edge to eliminate\n        i = np.random.randint(0, n-1)\n        eliminated_node = new_solution[i]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n\n        # Find the best position to reinsert it\n        best_pos = 0\n        best_cost = float('inf')\n\n        for j in range(n-1):\n            # Calculate cost of inserting at position j\n            cost1 = distance_matrix_1[new_solution[j-1], eliminated_node] + distance_matrix_1[eliminated_node, new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[j-1], eliminated_node] + distance_matrix_2[eliminated_node, new_solution[j]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = j\n\n        # Reinsert the node in the best position\n        new_solution = np.insert(new_solution, best_pos, eliminated_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7788342565061639,
            2.166901409626007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    combined = objectives.sum(axis=1)\n    selected_idx = np.argmax(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment rotation\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate potential improvement for both objectives\n        prev_node = new_solution[a-1]\n        next_node = new_solution[b-1]\n\n        # Rotate segment in both directions and evaluate\n        rotated_cw = np.roll(segment, 1)\n        rotated_ccw = np.roll(segment, -1)\n\n        # Calculate costs for original and rotated segments\n        original_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        original_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        cost_cw1 = distance_matrix_1[prev_node, rotated_cw[0]] + distance_matrix_1[rotated_cw[-1], next_node]\n        cost_cw2 = distance_matrix_2[prev_node, rotated_cw[0]] + distance_matrix_2[rotated_cw[-1], next_node]\n\n        cost_ccw1 = distance_matrix_1[prev_node, rotated_ccw[0]] + distance_matrix_1[rotated_ccw[-1], next_node]\n        cost_ccw2 = distance_matrix_2[prev_node, rotated_ccw[0]] + distance_matrix_2[rotated_ccw[-1], next_node]\n\n        # Choose the rotation that improves both objectives\n        if (cost_cw1 < original_cost1 and cost_cw2 < original_cost2) or \\\n           (cost_ccw1 < original_cost1 and cost_ccw2 < original_cost2):\n            if cost_cw1 + cost_cw2 < cost_ccw1 + cost_ccw2:\n                new_solution[a:b] = rotated_cw\n            else:\n                new_solution[a:b] = rotated_ccw\n\n    # Step 2: Guided edge elimination and reinsertion\n    if n > 3:\n        # Select an edge to eliminate\n        i = np.random.randint(0, n-1)\n        eliminated_node = new_solution[i]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n\n        # Find the best position to reinsert it\n        best_pos = 0\n        best_cost = float('inf')\n\n        for j in range(n-1):\n            # Calculate cost of inserting at position j\n            cost1 = distance_matrix_1[new_solution[j-1], eliminated_node] + distance_matrix_1[eliminated_node, new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[j-1], eliminated_node] + distance_matrix_2[eliminated_node, new_solution[j]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = j\n\n        # Reinsert the node in the best position\n        new_solution = np.insert(new_solution, best_pos, eliminated_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of crowding distance and Pareto dominance, then applies a hybrid local search combining a randomized segment inversion with a multi-objective aware edge swap, prioritizing improvements in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7215207946097347,
            1.3587151765823364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment rotation with a multi-objective aware node insertion, favoring solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8169671597547276,
            1.3445809483528137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The new algorithm combines a multi-objective aware partial tour reconstruction with a randomized edge crossover, prioritizing solutions with high crowding distance or Pareto dominance to explore less crowded regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Partial tour reconstruction\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Reconstruct segment by sorting nodes based on their positions in both objective spaces\n        segment_coords = instance[segment]\n        centroid1 = np.mean(segment_coords[:, :2], axis=0)\n        centroid2 = np.mean(segment_coords[:, 2:], axis=0)\n\n        def sort_key(node_idx):\n            node_coords = instance[node_idx]\n            dist1 = np.linalg.norm(node_coords[:2] - centroid1)\n            dist2 = np.linalg.norm(node_coords[2:] - centroid2)\n            return dist1 + dist2\n\n        sorted_segment = sorted(segment, key=sort_key)\n        new_solution[a:b] = sorted_segment\n\n    # Step 2: Randomized edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before crossover\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after crossover\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        # Accept crossover if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8430292471348109,
            2.372284471988678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Partial tour reconstruction\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Reconstruct segment by sorting nodes based on their positions in both objective spaces\n        segment_coords = instance[segment]\n        centroid1 = np.mean(segment_coords[:, :2], axis=0)\n        centroid2 = np.mean(segment_coords[:, 2:], axis=0)\n\n        def sort_key(node_idx):\n            node_coords = instance[node_idx]\n            dist1 = np.linalg.norm(node_coords[:2] - centroid1)\n            dist2 = np.linalg.norm(node_coords[2:] - centroid2)\n            return dist1 + dist2\n\n        sorted_segment = sorted(segment, key=sort_key)\n        new_solution[a:b] = sorted_segment\n\n    # Step 2: Randomized edge crossover\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before crossover\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after crossover\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        # Accept crossover if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment reversal with a multi-objective aware node insertion, prioritizing solutions with high crowding distance or Pareto dominance in the archive to guide the search toward diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.7:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(1, n)\n        while j == i or j == i-1 or j == i+1:\n            j = np.random.randint(1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.83412811790906,
            2.4339197278022766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.random() < 0.7:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(1, n)\n        while j == i or j == i-1 or j == i+1:\n            j = np.random.randint(1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1 * 0.95) or (new_cost2 < original_cost2 * 0.95):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = np.random.randint(1, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This novel hybrid local search algorithm combines a multi-segment crossover with adaptive edge selection, prioritizing edges with high potential for Pareto frontier improvement while maintaining feasibility through a dynamic segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-segment crossover with adaptive edge selection\n    for _ in range(3):\n        # Select two random segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Evaluate edge potential for improvement\n        def edge_potential(i, j):\n            return (distance_matrix_1[i, j] + distance_matrix_2[i, j]) / (distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + 1e-8)\n\n        # Find best edges to swap\n        best_i, best_j = None, None\n        best_score = -1\n\n        for i in range(a, b+1):\n            for j in range(c, d+1):\n                if i != j:\n                    score = edge_potential(i, j)\n                    if score > best_score:\n                        best_score = score\n                        best_i, best_j = i, j\n\n        if best_i is not None and best_j is not None:\n            # Perform the swap\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Dynamic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n",
        "score": [
            -0.9109562540715355,
            6.599420428276062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Multi-segment crossover with adaptive edge selection\n    for _ in range(3):\n        # Select two random segments\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Evaluate edge potential for improvement\n        def edge_potential(i, j):\n            return (distance_matrix_1[i, j] + distance_matrix_2[i, j]) / (distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + 1e-8)\n\n        # Find best edges to swap\n        best_i, best_j = None, None\n        best_score = -1\n\n        for i in range(a, b+1):\n            for j in range(c, d+1):\n                if i != j:\n                    score = edge_potential(i, j)\n                    if score > best_score:\n                        best_score = score\n                        best_i, best_j = i, j\n\n        if best_i is not None and best_j is not None:\n            # Perform the swap\n            new_solution[best_i], new_solution[best_j] = new_solution[best_j], new_solution[best_i]\n\n    # Dynamic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm implements a novel hybrid local search that combines a multi-objective aware node chain reversal with a dynamic edge replacement strategy, prioritizing solutions with high crowding distance while ensuring feasibility through a two-phase validation mechanism that maintains tour continuity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n    crowding_distances = np.zeros(n_solutions)\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n\n        for i in range(1, n_solutions-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                crowding_distances[sorted_idx[i]] += 0\n            else:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Multi-objective aware node chain reversal\n    if n > 3:\n        # Find the segment with highest potential improvement\n        max_improvement = -np.inf\n        best_segment = None\n\n        for i in range(n-2):\n            for j in range(i+2, min(i+10, n-1)):  # Limit segment size for efficiency\n                # Calculate original cost\n                orig_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[j+1]])\n                orig_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                # Calculate reversed cost\n                rev_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[i], new_solution[j+1]])\n                rev_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n                # Calculate improvement potential\n                improvement = (min(rev_cost1, orig_cost1) - orig_cost1) + (min(rev_cost2, orig_cost2) - orig_cost2)\n\n                if improvement > max_improvement:\n                    max_improvement = improvement\n                    best_segment = (i, j)\n\n        if best_segment and max_improvement > 0:\n            i, j = best_segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Dynamic edge replacement\n    for _ in range(3):\n        # Select random nodes for potential replacement\n        a, b, c = np.random.choice(n, size=3, replace=False)\n\n        # Calculate original cost\n        orig_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]])\n        orig_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        # Calculate new cost if we swap edges\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                   distance_matrix_1[new_solution[a], new_solution[b-1]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                   distance_matrix_2[new_solution[a], new_solution[b-1]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Rebuild solution from scratch if invalid\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, np.array(list(missing))])\n\n    return new_solution\n\n",
        "score": [
            -0.6644567891017679,
            6.232513129711151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distances for all solutions\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(objectives)\n    crowding_distances = np.zeros(n_solutions)\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n\n        for i in range(1, n_solutions-1):\n            if objectives[sorted_idx[-1], m] == objectives[sorted_idx[0], m]:\n                crowding_distances[sorted_idx[i]] += 0\n            else:\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Multi-objective aware node chain reversal\n    if n > 3:\n        # Find the segment with highest potential improvement\n        max_improvement = -np.inf\n        best_segment = None\n\n        for i in range(n-2):\n            for j in range(i+2, min(i+10, n-1)):  # Limit segment size for efficiency\n                # Calculate original cost\n                orig_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j], new_solution[j+1]])\n                orig_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                # Calculate reversed cost\n                rev_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[i], new_solution[j+1]])\n                rev_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n                # Calculate improvement potential\n                improvement = (min(rev_cost1, orig_cost1) - orig_cost1) + (min(rev_cost2, orig_cost2) - orig_cost2)\n\n                if improvement > max_improvement:\n                    max_improvement = improvement\n                    best_segment = (i, j)\n\n        if best_segment and max_improvement > 0:\n            i, j = best_segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Phase 2: Dynamic edge replacement\n    for _ in range(3):\n        # Select random nodes for potential replacement\n        a, b, c = np.random.choice(n, size=3, replace=False)\n\n        # Calculate original cost\n        orig_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]])\n        orig_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        # Calculate new cost if we swap edges\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                   distance_matrix_1[new_solution[a], new_solution[b-1]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                   distance_matrix_2[new_solution[a], new_solution[b-1]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Validation and repair\n    if len(np.unique(new_solution)) != n:\n        # Rebuild solution from scratch if invalid\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, np.array(list(missing))])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic path reversal with a multi-objective aware node relocation, using a dynamic selection of segments based on their potential improvement in both objectives while maintaining feasibility through a node consistency check and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (highest normalized objective sum)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: probabilistic path reversal with multi-objective aware node relocation\n    for _ in range(3):\n        # Randomly select a segment to reverse with probability based on potential improvement\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential improvement for reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        reversed_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        improvement1 = original_cost1 - reversed_cost1\n\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        improvement2 = original_cost2 - reversed_cost2\n\n        # Apply reversal if it improves at least one objective\n        if (improvement1 > 0) or (improvement2 > 0):\n            new_solution[a:b+1] = segment[::-1]\n\n    # Node relocation based on multi-objective potential\n    for _ in range(3):\n        # Select a node to relocate\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = -np.inf\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos - 1) % n:\n                continue\n\n            # Calculate potential improvement for insertion\n            original_cost1 = distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]] + distance_matrix_1[new_solution[node_pos], new_solution[(node_pos+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[node_pos-1], new_solution[(node_pos+1)%n]] + distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]] + distance_matrix_2[new_solution[node_pos], new_solution[(node_pos+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[node_pos-1], new_solution[(node_pos+1)%n]] + distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements (simple sum for this example)\n            combined_improvement = improvement1 + improvement2\n\n            if combined_improvement > best_improvement:\n                best_improvement = combined_improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Remove node and insert at best position\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8772553988210243,
            3.62089866399765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (highest normalized objective sum)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: probabilistic path reversal with multi-objective aware node relocation\n    for _ in range(3):\n        # Randomly select a segment to reverse with probability based on potential improvement\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential improvement for reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        reversed_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        improvement1 = original_cost1 - reversed_cost1\n\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n        improvement2 = original_cost2 - reversed_cost2\n\n        # Apply reversal if it improves at least one objective\n        if (improvement1 > 0) or (improvement2 > 0):\n            new_solution[a:b+1] = segment[::-1]\n\n    # Node relocation based on multi-objective potential\n    for _ in range(3):\n        # Select a node to relocate\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = -np.inf\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos - 1) % n:\n                continue\n\n            # Calculate potential improvement for insertion\n            original_cost1 = distance_matrix_1[new_solution[node_pos-1], new_solution[node_pos]] + distance_matrix_1[new_solution[node_pos], new_solution[(node_pos+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[node_pos-1], new_solution[(node_pos+1)%n]] + distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[new_solution[node_pos-1], new_solution[node_pos]] + distance_matrix_2[new_solution[node_pos], new_solution[(node_pos+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[node_pos-1], new_solution[(node_pos+1)%n]] + distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements (simple sum for this example)\n            combined_improvement = improvement1 + improvement2\n\n            if combined_improvement > best_improvement:\n                best_improvement = combined_improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            # Remove node and insert at best position\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with probability based on solution quality\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with adaptive selection\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Adaptive acceptance criterion\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7709098548675247,
            1.9626072645187378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion with probability based on solution quality\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap with adaptive selection\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Adaptive acceptance criterion\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment reversal with multi-objective aware node swaps, guided by a diversity-aware selection criterion that balances exploitation of high-quality regions with exploration of less crowded areas, while maintaining feasibility through a probabilistic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    # Select solution with highest crowding distance (promising for exploration)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware node swap\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        # Accept swap if it improves at least one objective or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) and (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Probabilistic validation and repair\n    if np.random.random() < 0.3 and len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.5836556071555962,
            2.537879705429077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection: prioritize solutions in less crowded regions\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = float('inf')\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n\n    # Select solution with highest crowding distance (promising for exploration)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware node swap\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n-1)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n        # Accept swap if it improves at least one objective or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) and (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Probabilistic validation and repair\n    if np.random.random() < 0.3 and len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective-aware node relocation strategy with a dynamic edge inversion mechanism, guided by the Pareto front's knee points to balance exploration and exploitation while ensuring feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee points in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    distances = np.linalg.norm(normalized[:, np.newaxis] - normalized, axis=2)\n    knee_idx = np.argmax(np.min(distances, axis=1))\n    base_solution = archive[knee_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware node relocation\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate potential improvement\n            orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Dynamic edge inversion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        if np.random.random() < 0.7:  # 70% chance to invert segment\n            segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    # Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        # Randomly repair by inserting missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n",
        "score": [
            -0.7473410407323515,
            2.895110547542572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify knee points in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    distances = np.linalg.norm(normalized[:, np.newaxis] - normalized, axis=2)\n    knee_idx = np.argmax(np.min(distances, axis=1))\n    base_solution = archive[knee_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware node relocation\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Calculate potential improvement\n            orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Dynamic edge inversion\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        if np.random.random() < 0.7:  # 70% chance to invert segment\n            segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    # Probabilistic validation\n    if len(np.unique(new_solution)) != n:\n        # Randomly repair by inserting missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm combines a randomized insertion of a segment with a multi-objective aware node relocation, favoring solutions with better Pareto dominance or higher crowding distance to guide exploration toward less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment insertion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Calculate cost after relocation\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept relocation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8452900800972347,
            2.2906188368797302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment insertion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Step 2: Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Calculate cost after relocation\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept relocation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{A novel hybrid local search algorithm combines edge inversions with adaptive segment relocations, prioritizing edges with high potential for multi-objective improvement through a dynamic scoring mechanism that considers both distance matrices, while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective sum (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge inversion with adaptive segment relocation\n    for _ in range(3):\n        # Calculate edge scores based on both distance matrices\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            edge_scores[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                             distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n        # Select segment to invert based on highest score\n        a = np.argmax(edge_scores)\n        b = (a + np.random.randint(2, 5)) % n  # Variable segment length\n\n        # Invert segment and relocate\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n        # Ensure validity with probabilistic repair\n        if np.random.random() < 0.3 and len(np.unique(new_solution)) != n:\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9188973142076582,
            3.1661157608032227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective sum (prioritize first objective)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Higher weight for first objective\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge inversion with adaptive segment relocation\n    for _ in range(3):\n        # Calculate edge scores based on both distance matrices\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            edge_scores[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                             distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n        # Select segment to invert based on highest score\n        a = np.argmax(edge_scores)\n        b = (a + np.random.randint(2, 5)) % n  # Variable segment length\n\n        # Invert segment and relocate\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n        # Ensure validity with probabilistic repair\n        if np.random.random() < 0.3 and len(np.unique(new_solution)) != n:\n            missing = set(range(n)) - set(new_solution)\n            for node in missing:\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel hybrid local search algorithm combines a multi-objective aware segment crossover with a dynamic edge perturbation mechanism, prioritizing solutions with high Pareto dominance while ensuring feasibility through a constrained repair process that maintains the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment crossover\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n\n        # Calculate cost before crossover\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Perform crossover\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Calculate cost after crossover\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[a+len(segment2)-1], new_solution[a+len(segment2)]] +\n                    distance_matrix_1[new_solution[a+len(segment2)+len(segment1)-1], new_solution[a+len(segment2)+len(segment1)]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a+len(segment2)-1], new_solution[a+len(segment2)]] +\n                    distance_matrix_2[new_solution[a+len(segment2)+len(segment1)-1], new_solution[a+len(segment2)+len(segment1)]])\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()\n\n    # Dynamic edge perturbation\n    if n > 1:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before perturbation\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Perform perturbation\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Calculate cost after perturbation\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring original order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7731171669575778,
            2.8741647005081177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmin(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment crossover\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n\n        # Calculate cost before crossover\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Perform crossover\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Calculate cost after crossover\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_1[new_solution[a+len(segment2)-1], new_solution[a+len(segment2)]] +\n                    distance_matrix_1[new_solution[a+len(segment2)+len(segment1)-1], new_solution[a+len(segment2)+len(segment1)]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                    distance_matrix_2[new_solution[a+len(segment2)-1], new_solution[a+len(segment2)]] +\n                    distance_matrix_2[new_solution[a+len(segment2)+len(segment1)-1], new_solution[a+len(segment2)+len(segment1)]])\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution = base_solution.copy()\n\n    # Dynamic edge perturbation\n    if n > 1:\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before perturbation\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Perform perturbation\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Calculate cost after perturbation\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Accept if at least one objective improves\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring original order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{ A novel hybrid local search algorithm that combines adaptive edge swaps with objective-weighted segment relocations, prioritizing high-improvement edges while dynamically balancing feasibility through a multi-phase validation and repair mechanism. }",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        if np.random.rand() < 0.7:\n            # Adaptive edge swap\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n        else:\n            # Objective-weighted segment relocation\n            a, b, c = np.random.choice(n, size=3, replace=False)\n            if a > b:\n                a, b = b, a\n            segment = new_solution[b+1:c+1]\n            weights = np.array([distance_matrix_1[new_solution[a-1], node] + distance_matrix_2[new_solution[a-1], node] for node in segment])\n            segment = segment[np.argsort(weights)]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6292813724556956,
            2.2530463337898254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        if np.random.rand() < 0.7:\n            # Adaptive edge swap\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n        else:\n            # Objective-weighted segment relocation\n            a, b, c = np.random.choice(n, size=3, replace=False)\n            if a > b:\n                a, b = b, a\n            segment = new_solution[b+1:c+1]\n            weights = np.array([distance_matrix_1[new_solution[a-1], node] + distance_matrix_2[new_solution[a-1], node] for node in segment])\n            segment = segment[np.argsort(weights)]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        if len(np.unique(new_solution)) == n:\n            break\n\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{An adaptive multi-criteria local search operator that combines dynamic segment rearrangement with objective-aware edge prioritization, using a hybrid selection mechanism that balances solution quality and diversity while ensuring feasibility through a probabilistic repair scheme.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: combine quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = normalized.sum(axis=1)\n\n    # Calculate diversity scores (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        diversity_scores[i] = np.mean(distances)\n\n    # Combine scores with adaptive weighting\n    alpha = 0.7 if np.random.random() < 0.5 else 0.3  # Dynamic weighting\n    combined_scores = alpha * quality_scores + (1 - alpha) * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rearrangement\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))\n        segments = np.random.choice(n, size=k, replace=False)\n        segments.sort()\n        segments = np.concatenate([[0], segments, [n]])\n\n        # Recombine segments in new order\n        new_order = np.random.permutation(len(segments)-1)\n        new_segments = []\n        for i in new_order:\n            new_segments.append(new_solution[segments[i]:segments[i+1]])\n        new_solution = np.concatenate(new_segments)\n\n    # Objective-aware edge prioritization\n    if n > 4:\n        # Calculate edge importance scores\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev, curr = new_solution[i-1], new_solution[i]\n            next_node = new_solution[(i+1) % n]\n            score1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            score2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            edge_scores[i] = score1 + score2\n\n        # Select worst edge and try to improve\n        worst_edge = np.argmax(edge_scores)\n        i, j = worst_edge, (worst_edge + 1) % n\n\n        # Try to find better insertion point\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n):\n            if pos == i or pos == j:\n                continue\n            # Calculate improvement for both objectives\n            orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the insertion\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:best_pos], segment, new_solution[best_pos:]])\n\n    # Probabilistic repair for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Reinsert missing nodes with probability based on their importance\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            # Calculate insertion importance\n            importance = 0\n            for i in range(n):\n                prev, curr = new_solution[i-1], new_solution[i]\n                importance += distance_matrix_1[prev, node] + distance_matrix_1[node, curr]\n                importance += distance_matrix_2[prev, node] + distance_matrix_2[node, curr]\n\n            # Insert with probability proportional to importance\n            if np.random.random() < (importance / (2 * n * (distance_matrix_1.max() + distance_matrix_2.max()))):\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8913628977601704,
            9.308483004570007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive selection: combine quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = normalized.sum(axis=1)\n\n    # Calculate diversity scores (distance to other solutions in objective space)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = np.linalg.norm(objectives - objectives[i], axis=1)\n        diversity_scores[i] = np.mean(distances)\n\n    # Combine scores with adaptive weighting\n    alpha = 0.7 if np.random.random() < 0.5 else 0.3  # Dynamic weighting\n    combined_scores = alpha * quality_scores + (1 - alpha) * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rearrangement\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))\n        segments = np.random.choice(n, size=k, replace=False)\n        segments.sort()\n        segments = np.concatenate([[0], segments, [n]])\n\n        # Recombine segments in new order\n        new_order = np.random.permutation(len(segments)-1)\n        new_segments = []\n        for i in new_order:\n            new_segments.append(new_solution[segments[i]:segments[i+1]])\n        new_solution = np.concatenate(new_segments)\n\n    # Objective-aware edge prioritization\n    if n > 4:\n        # Calculate edge importance scores\n        edge_scores = np.zeros(n)\n        for i in range(n):\n            prev, curr = new_solution[i-1], new_solution[i]\n            next_node = new_solution[(i+1) % n]\n            score1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            score2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            edge_scores[i] = score1 + score2\n\n        # Select worst edge and try to improve\n        worst_edge = np.argmax(edge_scores)\n        i, j = worst_edge, (worst_edge + 1) % n\n\n        # Try to find better insertion point\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(n):\n            if pos == i or pos == j:\n                continue\n            # Calculate improvement for both objectives\n            orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            improvement = (orig_cost1 - new_cost1) + (orig_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the insertion\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:best_pos], segment, new_solution[best_pos:]])\n\n    # Probabilistic repair for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Reinsert missing nodes with probability based on their importance\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            # Calculate insertion importance\n            importance = 0\n            for i in range(n):\n                prev, curr = new_solution[i-1], new_solution[i]\n                importance += distance_matrix_1[prev, node] + distance_matrix_1[node, curr]\n                importance += distance_matrix_2[prev, node] + distance_matrix_2[node, curr]\n\n            # Insert with probability proportional to importance\n            if np.random.random() < (importance / (2 * n * (distance_matrix_1.max() + distance_matrix_2.max()))):\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective aware node insertion, favoring solutions with higher crowding distance or Pareto dominance to explore diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8395051501482615,
            1.4392651319503784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A novel hybrid local search algorithm that combines random segment reversals with guided edge swaps, prioritizing edges with high potential for multi-objective improvement while dynamically adjusting segment lengths to maintain feasibility and explore diverse solution spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: random segment reversal with guided edge swaps\n    for _ in range(5):\n        # Randomly select segment to reverse\n        seg_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Reverse the segment\n        new_solution[start:start+seg_length] = segment[::-1]\n\n        # Guided edge swap: swap edges that improve both objectives\n        for i in range(start, start+seg_length-1):\n            a, b = new_solution[i], new_solution[i+1]\n            for j in range(start+seg_length, n):\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                # Calculate potential improvement\n                delta1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b] -\n                         distance_matrix_1[a, b] - distance_matrix_1[c, d])\n                delta2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b] -\n                         distance_matrix_2[a, b] - distance_matrix_2[c, d])\n                if delta1 < 0 and delta2 < 0:\n                    # Perform the swap\n                    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n                    break\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.986064951447656,
            2.4440136551856995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: random segment reversal with guided edge swaps\n    for _ in range(5):\n        # Randomly select segment to reverse\n        seg_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Reverse the segment\n        new_solution[start:start+seg_length] = segment[::-1]\n\n        # Guided edge swap: swap edges that improve both objectives\n        for i in range(start, start+seg_length-1):\n            a, b = new_solution[i], new_solution[i+1]\n            for j in range(start+seg_length, n):\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                # Calculate potential improvement\n                delta1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b] -\n                         distance_matrix_1[a, b] - distance_matrix_1[c, d])\n                delta2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b] -\n                         distance_matrix_2[a, b] - distance_matrix_2[c, d])\n                if delta1 < 0 and delta2 < 0:\n                    # Perform the swap\n                    new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n                    break\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{A novel hybrid local search algorithm combines edge crossings with adaptive segment reversals, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge crossings with adaptive segment reversals\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Cross segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse segments with probability 0.5\n        if np.random.rand() > 0.5:\n            segment1 = segment1[::-1]\n        if np.random.rand() > 0.5:\n            segment2 = segment2[::-1]\n\n        # Swap segments\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.95944689038749,
            1.1170220971107483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge crossings with adaptive segment reversals\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Cross segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Reverse segments with probability 0.5\n        if np.random.rand() > 0.5:\n            segment1 = segment1[::-1]\n        if np.random.rand() > 0.5:\n            segment2 = segment2[::-1]\n\n        # Swap segments\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9179251483380997,
            1.3699048161506653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment reversal with a dominance-aware edge insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Dominance-aware edge insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution = np.concatenate([new_solution[:j], [new_solution[i]], new_solution[j:i], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7684244962511977,
            2.3152621388435364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Probabilistic segment reversal\n    if n > 2 and np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Dominance-aware edge insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution = np.concatenate([new_solution[:j], [new_solution[i]], new_solution[j:i], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment relinking with multi-objective aware edge perturbation, dynamically selecting segments based on their potential improvement in both objectives while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(np.prod(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relinking with edge perturbation\n    for _ in range(5):\n        # Select segment based on potential improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for this segment\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n\n        # Relink the segment with probability proportional to its potential improvement\n        if np.random.rand() < (1 - seg_cost1/np.max(distance_matrix_1)) * (1 - seg_cost2/np.max(distance_matrix_2)):\n            # Perturb the segment by rotating it\n            rotate_pos = np.random.randint(1, segment_length)\n            segment = np.roll(segment, rotate_pos)\n\n            # Insert back into solution\n            new_solution = np.concatenate([new_solution[:start], segment, new_solution[start+segment_length:]])\n\n            # Ensure validity with probabilistic repair\n            if len(np.unique(new_solution)) != n:\n                missing = set(range(n)) - set(new_solution)\n                for node in missing:\n                    if np.random.rand() < 0.3:  # 30% chance to repair\n                        insert_pos = np.random.randint(0, n)\n                        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8263623327928109,
            2.7425877451896667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for balanced improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(np.prod(normalized, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relinking with edge perturbation\n    for _ in range(5):\n        # Select segment based on potential improvement\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement for this segment\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n\n        # Relink the segment with probability proportional to its potential improvement\n        if np.random.rand() < (1 - seg_cost1/np.max(distance_matrix_1)) * (1 - seg_cost2/np.max(distance_matrix_2)):\n            # Perturb the segment by rotating it\n            rotate_pos = np.random.randint(1, segment_length)\n            segment = np.roll(segment, rotate_pos)\n\n            # Insert back into solution\n            new_solution = np.concatenate([new_solution[:start], segment, new_solution[start+segment_length:]])\n\n            # Ensure validity with probabilistic repair\n            if len(np.unique(new_solution)) != n:\n                missing = set(range(n)) - set(new_solution)\n                for node in missing:\n                    if np.random.rand() < 0.3:  # 30% chance to repair\n                        insert_pos = np.random.randint(0, n)\n                        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversions with objective-aware edge swaps, dynamically balancing exploration of high-potential regions in both objective spaces while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    hv_contributions = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion with objective awareness\n    for _ in range(3):\n        # Select segment based on edge potential\n        edge_potentials = []\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            potential = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n            edge_potentials.append(potential)\n\n        if edge_potentials:\n            start = np.random.choice(range(n-1), p=np.array(edge_potentials)/sum(edge_potentials))\n            length = min(10, n - start - 1)\n            end = start + length\n\n            # Invert the selected segment\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n            # Objective-aware edge swap\n            if np.random.rand() < 0.7:\n                swap_pos = np.random.randint(0, n)\n                swap_len = min(5, n - swap_pos - 1)\n                if swap_len > 0:\n                    u1, v1 = new_solution[swap_pos], new_solution[swap_pos+1]\n                    u2, v2 = new_solution[swap_pos+swap_len], new_solution[(swap_pos+swap_len+1)%n]\n\n                    gain1 = (distance_matrix_1[u1, v2] + distance_matrix_2[u1, v2]) - (distance_matrix_1[u1, v1] + distance_matrix_2[u1, v1])\n                    gain2 = (distance_matrix_1[u2, v1] + distance_matrix_2[u2, v1]) - (distance_matrix_1[u2, v2] + distance_matrix_2[u2, v2])\n\n                    if gain1 + gain2 < 0:\n                        new_solution[swap_pos+1:swap_pos+swap_len+1] = new_solution[swap_pos+1:swap_pos+swap_len+1][::-1]\n\n            # Validate and repair if needed\n            if len(np.unique(new_solution)) != n:\n                # Probabilistic repair: swap duplicate nodes\n                unique, counts = np.unique(new_solution, return_counts=True)\n                duplicates = unique[counts > 1]\n                for dup in duplicates:\n                    dup_indices = np.where(new_solution == dup)[0]\n                    for i in dup_indices[1:]:\n                        swap_pos = np.random.randint(0, n)\n                        while new_solution[swap_pos] in duplicates:\n                            swap_pos = np.random.randint(0, n)\n                        new_solution[i], new_solution[swap_pos] = new_solution[swap_pos], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.919672966154871,
            2.589755117893219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    hv_contributions = np.prod(normalized, axis=1)\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion with objective awareness\n    for _ in range(3):\n        # Select segment based on edge potential\n        edge_potentials = []\n        for i in range(n-1):\n            u, v = new_solution[i], new_solution[i+1]\n            potential = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n            edge_potentials.append(potential)\n\n        if edge_potentials:\n            start = np.random.choice(range(n-1), p=np.array(edge_potentials)/sum(edge_potentials))\n            length = min(10, n - start - 1)\n            end = start + length\n\n            # Invert the selected segment\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n            # Objective-aware edge swap\n            if np.random.rand() < 0.7:\n                swap_pos = np.random.randint(0, n)\n                swap_len = min(5, n - swap_pos - 1)\n                if swap_len > 0:\n                    u1, v1 = new_solution[swap_pos], new_solution[swap_pos+1]\n                    u2, v2 = new_solution[swap_pos+swap_len], new_solution[(swap_pos+swap_len+1)%n]\n\n                    gain1 = (distance_matrix_1[u1, v2] + distance_matrix_2[u1, v2]) - (distance_matrix_1[u1, v1] + distance_matrix_2[u1, v1])\n                    gain2 = (distance_matrix_1[u2, v1] + distance_matrix_2[u2, v1]) - (distance_matrix_1[u2, v2] + distance_matrix_2[u2, v2])\n\n                    if gain1 + gain2 < 0:\n                        new_solution[swap_pos+1:swap_pos+swap_len+1] = new_solution[swap_pos+1:swap_pos+swap_len+1][::-1]\n\n            # Validate and repair if needed\n            if len(np.unique(new_solution)) != n:\n                # Probabilistic repair: swap duplicate nodes\n                unique, counts = np.unique(new_solution, return_counts=True)\n                duplicates = unique[counts > 1]\n                for dup in duplicates:\n                    dup_indices = np.where(new_solution == dup)[0]\n                    for i in dup_indices[1:]:\n                        swap_pos = np.random.randint(0, n)\n                        while new_solution[swap_pos] in duplicates:\n                            swap_pos = np.random.randint(0, n)\n                        new_solution[i], new_solution[swap_pos] = new_solution[swap_pos], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{A novel hybrid local search algorithm combines pattern-based segment swaps with objective-aware edge prioritization, using multi-criteria edge selection to identify high-improvement opportunities while maintaining feasibility through a dynamic segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Pattern-based segment swap with objective-aware edge prioritization\n    for _ in range(5):\n        # Identify high-potential edges in both objectives\n        edge_scores = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            score = (distance_matrix_1[u,v] + distance_matrix_2[u,v]) / (objectives[selected_idx][0] + objectives[selected_idx][1] + 1e-8)\n            edge_scores.append(score)\n\n        # Select edges with highest scores\n        top_edges = np.argsort(edge_scores)[-3:]\n        if len(top_edges) < 3:\n            break\n\n        a, b, c = top_edges\n        if a > b:\n            a, b = b, a\n\n        # Swap segments between positions a and b\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8652885023434607,
            1.3280518054962158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Pattern-based segment swap with objective-aware edge prioritization\n    for _ in range(5):\n        # Identify high-potential edges in both objectives\n        edge_scores = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            score = (distance_matrix_1[u,v] + distance_matrix_2[u,v]) / (objectives[selected_idx][0] + objectives[selected_idx][1] + 1e-8)\n            edge_scores.append(score)\n\n        # Select edges with highest scores\n        top_edges = np.argsort(edge_scores)[-3:]\n        if len(top_edges) < 3:\n            break\n\n        a, b, c = top_edges\n        if a > b:\n            a, b = b, a\n\n        # Swap segments between positions a and b\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware path relinking with a randomized segment crossover, prioritizing solutions with high Pareto front diversity and leveraging both distance matrices to identify promising edges for recombination while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto front diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: path relinking with randomized segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Path relinking (multi-objective aware)\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Identify common path segments between base and another solution\n        other_solution = archive[np.random.choice(len(archive))][0]\n        common_path = [node for node in base_solution if node in other_solution]\n\n        if len(common_path) > 1:\n            # Create a new path by combining segments\n            new_path = []\n            in_common = False\n            for node in base_solution:\n                if node in common_path:\n                    if not in_common:\n                        new_path.extend(common_path)\n                        in_common = True\n                else:\n                    if in_common:\n                        break\n                    new_path.append(node)\n\n            # Fill remaining nodes\n            remaining_nodes = [node for node in base_solution if node not in new_path]\n            new_solution = np.array(new_path + remaining_nodes)\n\n        # Step 2: Randomized segment crossover\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n        segment1 = base_solution[a:b]\n        segment2 = base_solution[c:d]\n\n        # Combine segments with multi-objective consideration\n        combined = np.concatenate([segment1, segment2])\n        unique_combined, indices = np.unique(combined, return_index=True)\n        sorted_indices = np.argsort(indices)\n        new_segment = unique_combined[sorted_indices]\n\n        # Insert new segment into solution\n        if len(new_segment) > 0:\n            pos = np.random.randint(0, n - len(new_segment) + 1)\n            new_solution[pos:pos+len(new_segment)] = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6457191622869645,
            1.618918776512146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto front diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: path relinking with randomized segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Step 1: Path relinking (multi-objective aware)\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Identify common path segments between base and another solution\n        other_solution = archive[np.random.choice(len(archive))][0]\n        common_path = [node for node in base_solution if node in other_solution]\n\n        if len(common_path) > 1:\n            # Create a new path by combining segments\n            new_path = []\n            in_common = False\n            for node in base_solution:\n                if node in common_path:\n                    if not in_common:\n                        new_path.extend(common_path)\n                        in_common = True\n                else:\n                    if in_common:\n                        break\n                    new_path.append(node)\n\n            # Fill remaining nodes\n            remaining_nodes = [node for node in base_solution if node not in new_path]\n            new_solution = np.array(new_path + remaining_nodes)\n\n        # Step 2: Randomized segment crossover\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n        segment1 = base_solution[a:b]\n        segment2 = base_solution[c:d]\n\n        # Combine segments with multi-objective consideration\n        combined = np.concatenate([segment1, segment2])\n        unique_combined, indices = np.unique(combined, return_index=True)\n        sorted_indices = np.argsort(indices)\n        new_segment = unique_combined[sorted_indices]\n\n        # Insert new segment into solution\n        if len(new_segment) > 0:\n            pos = np.random.randint(0, n - len(new_segment) + 1)\n            new_solution[pos:pos+len(new_segment)] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware segment reversal, prioritizing solutions with higher crowding distance or Pareto dominance to explore promising regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware segment reversal\n    if n > 3:\n        a = np.random.randint(0, n-1)\n        b = np.random.randint(a+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.881590785421977,
            1.796962320804596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware segment reversal\n    if n > 3:\n        a = np.random.randint(0, n-1)\n        b = np.random.randint(a+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-segment shuffle with a guided edge insertion, prioritizing segments that show potential for improvement in both objectives while maintaining feasibility through an adaptive segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (balanced improvement potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle and guided insertion\n    for _ in range(3):\n        # Select segments with potential for improvement\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Find insertion point that improves both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n - segment_length):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate new cost if inserted at pos\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n - segment_length else new_solution[0]\n\n            new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n\n            improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9781440725194157,
            2.2254273891448975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (balanced improvement potential)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle and guided insertion\n    for _ in range(3):\n        # Select segments with potential for improvement\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Find insertion point that improves both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n - segment_length):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Calculate new cost if inserted at pos\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n - segment_length else new_solution[0]\n\n            new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n\n            improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[start+segment_length:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment relocations, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap edges between a and b, and between b and c\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8803838672199363,
            1.9476120471954346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Swap edges between a and b, and between b and c\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This novel algorithm combines multi-objective edge prioritization with adaptive segment swapping, dynamically balancing improvements in both objective spaces while maintaining feasibility through probabilistic validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores for both objectives\n    def calculate_edge_scores(sol):\n        scores = np.zeros(n)\n        for i in range(n):\n            u, v = sol[i], sol[(i+1)%n]\n            scores[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n        return scores\n\n    edge_scores = calculate_edge_scores(new_solution)\n    sorted_edges = np.argsort(edge_scores)[::-1]\n\n    # Adaptive segment swapping based on edge importance\n    for _ in range(5):\n        # Select important edges to consider\n        top_k = min(5, n//2)\n        selected_edges = sorted_edges[:top_k]\n\n        # Randomly select two segments to swap\n        if len(selected_edges) >= 2:\n            a, b = np.random.choice(selected_edges, size=2, replace=False)\n            start_a, end_a = min(a, (a+1)%n), max(a, (a+1)%n)\n            start_b, end_b = min(b, (b+1)%n), max(b, (b+1)%n)\n\n            # Swap segments\n            segment_a = new_solution[start_a:end_a]\n            segment_b = new_solution[start_b:end_b]\n            new_solution = np.concatenate([\n                new_solution[:start_a],\n                segment_b,\n                new_solution[end_a:start_b],\n                segment_a,\n                new_solution[end_b:]\n            ])\n\n            # Probabilistic validation\n            if np.random.random() < 0.7 or len(np.unique(new_solution)) == n:\n                break\n\n    # Repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.choice([i for i in range(n) if new_solution[i] != node])\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9262748531561111,
            1.7020887732505798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance scores for both objectives\n    def calculate_edge_scores(sol):\n        scores = np.zeros(n)\n        for i in range(n):\n            u, v = sol[i], sol[(i+1)%n]\n            scores[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n        return scores\n\n    edge_scores = calculate_edge_scores(new_solution)\n    sorted_edges = np.argsort(edge_scores)[::-1]\n\n    # Adaptive segment swapping based on edge importance\n    for _ in range(5):\n        # Select important edges to consider\n        top_k = min(5, n//2)\n        selected_edges = sorted_edges[:top_k]\n\n        # Randomly select two segments to swap\n        if len(selected_edges) >= 2:\n            a, b = np.random.choice(selected_edges, size=2, replace=False)\n            start_a, end_a = min(a, (a+1)%n), max(a, (a+1)%n)\n            start_b, end_b = min(b, (b+1)%n), max(b, (b+1)%n)\n\n            # Swap segments\n            segment_a = new_solution[start_a:end_a]\n            segment_b = new_solution[start_b:end_b]\n            new_solution = np.concatenate([\n                new_solution[:start_a],\n                segment_b,\n                new_solution[end_a:start_b],\n                segment_a,\n                new_solution[end_b:]\n            ])\n\n            # Probabilistic validation\n            if np.random.random() < 0.7 or len(np.unique(new_solution)) == n:\n                break\n\n    # Repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.choice([i for i in range(n) if new_solution[i] != node])\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive node swapping with guided multi-objective path smoothing, prioritizing segments with high potential for improvement by leveraging both objective space information while ensuring feasibility through a dynamic segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive node swapping with path smoothing\n    for _ in range(5):\n        # Select critical segments based on both objectives\n        segment_lengths = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            segment_lengths.append(cost1 + cost2)\n\n        # Identify worst segments to improve\n        worst_indices = np.argsort(segment_lengths)[-3:]\n        a, b, c = sorted(np.random.choice(worst_indices, size=3, replace=False))\n\n        # Perform adaptive node swapping\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n        # Smooth the path by rearranging surrounding nodes\n        if np.random.random() > 0.5:\n            segment = new_solution[b:c+1]\n            new_solution = np.concatenate([new_solution[:b], segment[::-1], new_solution[c+1:]])\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes in optimal positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find best insertion point based on both objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                cost1 = distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[(i-1)%n], node] + distance_matrix_2[node, new_solution[i]]\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9337624190821792,
            2.163914144039154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive node swapping with path smoothing\n    for _ in range(5):\n        # Select critical segments based on both objectives\n        segment_lengths = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            segment_lengths.append(cost1 + cost2)\n\n        # Identify worst segments to improve\n        worst_indices = np.argsort(segment_lengths)[-3:]\n        a, b, c = sorted(np.random.choice(worst_indices, size=3, replace=False))\n\n        # Perform adaptive node swapping\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n        # Smooth the path by rearranging surrounding nodes\n        if np.random.random() > 0.5:\n            segment = new_solution[b:c+1]\n            new_solution = np.concatenate([new_solution[:b], segment[::-1], new_solution[c+1:]])\n\n        # Ensure validity\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by reinserting missing nodes in optimal positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find best insertion point based on both objectives\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                cost1 = distance_matrix_1[new_solution[(i-1)%n], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[(i-1)%n], node] + distance_matrix_2[node, new_solution[i]]\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{A novel hybrid local search operator that combines a randomized block rotation with a multi-objective aware node insertion, favoring solutions with higher crowding distance or Pareto dominance to explore underrepresented regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block rotation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], block, new_solution[c:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8903731651847303,
            1.4514105916023254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized block rotation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        block = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], block, new_solution[c:]])\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i+1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel hybrid local search operator that combines a multi-segment inversion with a dominance-aware edge insertion, prioritizing solutions with high crowding distance to explore diverse regions while ensuring feasibility through a permutation repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-segment inversion + dominance-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-segment inversion\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))\n        segments = sorted(np.random.choice(n, size=k, replace=False))\n        for i in range(0, k-1, 2):\n            new_solution[segments[i]:segments[i+1]] = new_solution[segments[i]:segments[i+1]][::-1]\n\n    # Step 2: Dominance-aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        if i < j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n        else:\n            new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it dominates or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Repair mechanism: reorder missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for m in missing:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, m)\n\n    return new_solution\n\n",
        "score": [
            -0.9218314940734976,
            1.779934287071228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-segment inversion + dominance-aware edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-segment inversion\n    if n > 3:\n        k = np.random.randint(2, min(5, n//2))\n        segments = sorted(np.random.choice(n, size=k, replace=False))\n        for i in range(0, k-1, 2):\n            new_solution[segments[i]:segments[i+1]] = new_solution[segments[i]:segments[i+1]][::-1]\n\n    # Step 2: Dominance-aware edge insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        if i < j:\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n        else:\n            new_cost1 = distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept insertion if it dominates or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Repair mechanism: reorder missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for m in missing:\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, m)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7977233651863266,
            2.1746386289596558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{A novel hybrid local search algorithm combines segment reversals with adaptive edge swaps, balancing multi-objective improvements through dynamic priority scoring while ensuring feasibility through a constraint-aware validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment reversal with adaptive edge swaps\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive edge swap based on distance differences\n        if c < n - 1:\n            d1 = distance_matrix_1[new_solution[c], new_solution[c+1]] + distance_matrix_2[new_solution[c], new_solution[c+1]]\n            d2 = distance_matrix_1[new_solution[c], new_solution[c-1]] + distance_matrix_2[new_solution[c], new_solution[c-1]]\n            if d1 > d2:\n                new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in order\n        missing = sorted(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9598392066639385,
            2.573906421661377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: segment reversal with adaptive edge swaps\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Reverse segment [a, b]\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Adaptive edge swap based on distance differences\n        if c < n - 1:\n            d1 = distance_matrix_1[new_solution[c], new_solution[c+1]] + distance_matrix_2[new_solution[c], new_solution[c+1]]\n            d2 = distance_matrix_1[new_solution[c], new_solution[c-1]] + distance_matrix_2[new_solution[c], new_solution[c-1]]\n            if d1 > d2:\n                new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring missing nodes in order\n        missing = sorted(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8638427401057371,
            1.4728901386260986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{The new algorithm combines a multi-objective-aware node relocation with a probabilistic edge reversal, prioritizing solutions with high crowding distance or Pareto dominance to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate cost after relocation\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept relocation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Probabilistic edge reversal\n    if n > 1 and np.random.random() < 0.3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i+1, n+1) % n\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9016166853946448,
            1.4322736859321594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node relocation\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before relocation\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate cost after relocation\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept relocation if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Probabilistic edge reversal\n    if n > 1 and np.random.random() < 0.3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(i+1, n+1) % n\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{A novel hybrid local search operator that combines a randomized multi-segment shuffle with a Pareto front-aware edge reversal, prioritizing solutions with high diversity in the archive to explore uncharted regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (random selection for simplicity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized multi-segment shuffle\n    if n > 3:\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_lengths = np.random.randint(2, n//num_segments, size=num_segments)\n        segment_lengths[-1] = n - sum(segment_lengths[:-1])\n        segments = []\n        start = 0\n        for length in segment_lengths:\n            segments.append(new_solution[start:start+length])\n            start += length\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Step 2: Pareto front-aware edge reversal\n    if n > 2:\n        # Find edges that are non-dominated in the Pareto front\n        edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            edges.append((cost1, cost2, i, j))\n\n        # Sort edges by non-dominated status (simplified)\n        edges.sort(key=lambda x: (x[0], x[1]))\n\n        # Reverse a randomly selected non-dominated edge\n        if edges:\n            selected_edge = edges[np.random.randint(0, len(edges)//2)]\n            i, j = selected_edge[2], selected_edge[3]\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8526093260930774,
            2.4285184741020203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (random selection for simplicity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized multi-segment shuffle\n    if n > 3:\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_lengths = np.random.randint(2, n//num_segments, size=num_segments)\n        segment_lengths[-1] = n - sum(segment_lengths[:-1])\n        segments = []\n        start = 0\n        for length in segment_lengths:\n            segments.append(new_solution[start:start+length])\n            start += length\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Step 2: Pareto front-aware edge reversal\n    if n > 2:\n        # Find edges that are non-dominated in the Pareto front\n        edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            edges.append((cost1, cost2, i, j))\n\n        # Sort edges by non-dominated status (simplified)\n        edges.sort(key=lambda x: (x[0], x[1]))\n\n        # Reverse a randomly selected non-dominated edge\n        if edges:\n            selected_edge = edges[np.random.randint(0, len(edges)//2)]\n            i, j = selected_edge[2], selected_edge[3]\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{A novel hybrid local search algorithm combines edge reversals with objective-aware segment relocations, prioritizing segments that show potential for multi-objective improvement through dynamic edge evaluation and feasibility-preserving operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: objective-aware segment reversal\n    for _ in range(5):\n        # Select a segment to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Reverse segment if it shows potential improvement in both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8095484492748819,
            2.7506821751594543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: objective-aware segment reversal\n    for _ in range(5):\n        # Select a segment to reverse\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate potential improvement\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Reverse segment if it shows potential improvement in both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.2:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{An adaptive multi-objective local search operator that combines guided segment relocations with a dynamic edge selection mechanism, prioritizing edges that show potential for Pareto improvement while maintaining feasibility through a probabilistic validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for Pareto improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with dynamic edge selection\n    for _ in range(5):\n        # Select segments based on potential improvement\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate potential improvement\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j-1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n        # Probabilistic acceptance based on improvement\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.1) or \\\n           (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.1):\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.rand() < 0.7:  # 70% chance to repair\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9112938060228652,
            2.6028029322624207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for Pareto improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with dynamic edge selection\n    for _ in range(5):\n        # Select segments based on potential improvement\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate potential improvement\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[j-1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[j-1]])\n\n        # Probabilistic acceptance based on improvement\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.1) or \\\n           (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.1):\n            # Perform the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Probabilistic repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            if np.random.rand() < 0.7:  # 70% chance to repair\n                insert_pos = np.random.randint(0, n)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive edge swaps with multi-objective-aware segment relocations, prioritizing high-potential edges using a weighted dominance score while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted dominance score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random weights for objectives\n    weighted_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with segment relocation\n    for _ in range(5):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            score = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n            edge_scores.append(score)\n        edge_scores = np.array(edge_scores)\n\n        # Select top 20% edges to potentially modify\n        threshold = np.percentile(edge_scores, 80)\n        candidates = np.where(edge_scores >= threshold)[0]\n\n        if len(candidates) > 0:\n            a = np.random.choice(candidates)\n            b = (a + np.random.randint(1, n//2)) % n\n\n            # Perform segment relocation\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8391024328337142,
            2.807413399219513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted dominance score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)  # Random weights for objectives\n    weighted_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swaps with segment relocation\n    for _ in range(5):\n        # Select edges with high potential for improvement\n        edge_scores = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            score = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) / 2\n            edge_scores.append(score)\n        edge_scores = np.array(edge_scores)\n\n        # Select top 20% edges to potentially modify\n        threshold = np.percentile(edge_scores, 80)\n        candidates = np.where(edge_scores >= threshold)[0]\n\n        if len(candidates) > 0:\n            a = np.random.choice(candidates)\n            b = (a + np.random.randint(1, n//2)) % n\n\n            # Perform segment relocation\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n            # Ensure validity\n            if len(np.unique(new_solution)) == n:\n                break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, favoring solutions with higher crowding distance or Pareto dominance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7967485353587724,
            2.2932987213134766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8933670492382824,
            1.0185275077819824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swap with adaptive segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive edge swaps with Pareto-dominant segment relocations, guided by a weighted objective score to prioritize high-potential regions while ensuring feasibility through a dynamic constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with segment relocation\n    for _ in range(5):\n        # Select segments based on objective improvement potential\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b = sorted([a, b])\n        c, d = sorted([c, d])\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair: insert missing nodes at random positions\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9033521841988035,
            0.8150829672813416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weighted_scores = objectives[:, 0] * weights[0] + objectives[:, 1] * weights[1]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: adaptive edge swap with segment relocation\n    for _ in range(5):\n        # Select segments based on objective improvement potential\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b = sorted([a, b])\n        c, d = sorted([c, d])\n\n        # Swap segments [a, b] and [c, d]\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair: insert missing nodes at random positions\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel hybrid local search operator that combines a multi-objective aware node relocation with a guided edge reversal, leveraging both Pareto dominance and crowding distance to explore the solution space while ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for exploration)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for each solution\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with edge reversal\n    if n > 3:\n        # Select a node to relocate\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion position based on multi-objective criteria\n        best_pos = -1\n        best_score = -np.inf\n\n        for i in range(n):\n            if i == node_pos or i == (node_pos + 1) % n:\n                continue\n\n            # Calculate cost before and after relocation\n            original_cost1 = distance_matrix_1[new_solution[node_pos-1], node] + distance_matrix_1[node, new_solution[node_pos+1 if node_pos+1 < n else 0]]\n            original_cost2 = distance_matrix_2[new_solution[node_pos-1], node] + distance_matrix_2[node, new_solution[node_pos+1 if node_pos+1 < n else 0]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n\n            # Score based on multi-objective improvement\n            score = 0\n            if new_cost1 < original_cost1:\n                score += 1\n            if new_cost2 < original_cost2:\n                score += 1\n\n            if score > best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1 and best_score > 0:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n            # Guided edge reversal to further improve\n            if np.random.random() < 0.5:\n                a, b = sorted(np.random.choice(n-1, size=2, replace=False))\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore missing nodes in order\n        missing = list(set(range(n)) - set(new_solution))\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9337263044807964,
            3.021079361438751
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance (promising for exploration)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    # Calculate crowding distance for each solution\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: multi-objective aware node relocation with edge reversal\n    if n > 3:\n        # Select a node to relocate\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find best insertion position based on multi-objective criteria\n        best_pos = -1\n        best_score = -np.inf\n\n        for i in range(n):\n            if i == node_pos or i == (node_pos + 1) % n:\n                continue\n\n            # Calculate cost before and after relocation\n            original_cost1 = distance_matrix_1[new_solution[node_pos-1], node] + distance_matrix_1[node, new_solution[node_pos+1 if node_pos+1 < n else 0]]\n            original_cost2 = distance_matrix_2[new_solution[node_pos-1], node] + distance_matrix_2[node, new_solution[node_pos+1 if node_pos+1 < n else 0]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n\n            # Score based on multi-objective improvement\n            score = 0\n            if new_cost1 < original_cost1:\n                score += 1\n            if new_cost2 < original_cost2:\n                score += 1\n\n            if score > best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1 and best_score > 0:\n            # Perform relocation\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n            # Guided edge reversal to further improve\n            if np.random.random() < 0.5:\n                a, b = sorted(np.random.choice(n-1, size=2, replace=False))\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore missing nodes in order\n        missing = list(set(range(n)) - set(new_solution))\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm implements a dynamic segment relocation strategy combined with a multi-objective aware edge reversal, where the selection of segments and edges is guided by both solution quality and diversity, ensuring exploration of less-explored regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Extract and relocate segment\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Step 2: Multi-objective aware edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8492069994509623,
            2.1735703349113464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Extract and relocate segment\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Step 2: Multi-objective aware edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The backbone idea in the provided algorithms is combining randomized segment inversion with multi-objective aware edge swaps, prioritizing solutions with high crowding distance or Pareto dominance to guide the search toward less explored regions. A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[b]\n        new_solution = np.delete(new_solution, b)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9574432000484183,
            2.4017428755760193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        node = new_solution[b]\n        new_solution = np.delete(new_solution, b)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n)\n\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-objective aware partial tour reversal with a dynamic edge insertion mechanism, prioritizing nodes with the highest combined improvement potential based on both distance matrices while ensuring feasibility through a probabilistic validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    combined_potential = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware partial tour reversal\n    if n > 3:\n        # Identify nodes with highest combined improvement potential\n        improvement_potential = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            improvement_potential[i] = (distance_matrix_1[prev, current] + distance_matrix_1[current, next_node] +\n                                       distance_matrix_2[prev, current] + distance_matrix_2[current, next_node])\n\n        # Select top 3 nodes for potential reversal\n        top_nodes = np.argsort(improvement_potential)[-3:]\n\n        # Perform partial reversal between two selected nodes\n        a, b = sorted(np.random.choice(top_nodes, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Dynamic edge insertion\n    for _ in range(3):\n        # Select a random node and find its best insertion position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate insertion costs for all possible positions\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            if i == node_idx or i == (node_idx-1)%n:\n                insertion_costs[i] = np.inf\n                continue\n            prev = new_solution[i-1]\n            next_node = new_solution[i]\n            insertion_costs[i] = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n                                 distance_matrix_1[prev, next_node] +\n                                 distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n                                 distance_matrix_2[prev, next_node])\n\n        # Find best insertion position that improves at least one objective\n        valid_positions = np.where(insertion_costs < 0)[0]\n        if len(valid_positions) > 0:\n            best_pos = valid_positions[np.argmin(insertion_costs[valid_positions])]\n            # Remove node from current position and insert at best position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Rebuild tour with missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8091695931093434,
            3.1750694513320923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    combined_potential = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmax(combined_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware partial tour reversal\n    if n > 3:\n        # Identify nodes with highest combined improvement potential\n        improvement_potential = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            improvement_potential[i] = (distance_matrix_1[prev, current] + distance_matrix_1[current, next_node] +\n                                       distance_matrix_2[prev, current] + distance_matrix_2[current, next_node])\n\n        # Select top 3 nodes for potential reversal\n        top_nodes = np.argsort(improvement_potential)[-3:]\n\n        # Perform partial reversal between two selected nodes\n        a, b = sorted(np.random.choice(top_nodes, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Dynamic edge insertion\n    for _ in range(3):\n        # Select a random node and find its best insertion position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Calculate insertion costs for all possible positions\n        insertion_costs = np.zeros(n)\n        for i in range(n):\n            if i == node_idx or i == (node_idx-1)%n:\n                insertion_costs[i] = np.inf\n                continue\n            prev = new_solution[i-1]\n            next_node = new_solution[i]\n            insertion_costs[i] = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n                                 distance_matrix_1[prev, next_node] +\n                                 distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n                                 distance_matrix_2[prev, next_node])\n\n        # Find best insertion position that improves at least one objective\n        valid_positions = np.where(insertion_costs < 0)[0]\n        if len(valid_positions) > 0:\n            best_pos = valid_positions[np.argmin(insertion_costs[valid_positions])]\n            # Remove node from current position and insert at best position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Rebuild tour with missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in sorted(missing):\n            insert_pos = np.random.randint(0, len(new_solution)+1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{The new algorithm combines a multi-objective aware node sequence reordering with a probabilistic edge reversal mechanism, leveraging both solution quality metrics and spatial proximity to explore the search space while maintaining feasibility through dynamic validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.max(axis=1) - normalized.min(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node sequence reordering\n    if n > 4:\n        # Select three segments to reorder\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # Extract and reorder segments\n        segments = [new_solution[a:b], new_solution[b:c], new_solution[c:d]]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate([new_solution[:a], *segments, new_solution[d:]])\n\n    # Probabilistic edge reversal\n    for i in range(1, n):\n        if np.random.random() < 0.3:\n            # Calculate cost before reversal\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n            # Calculate cost after reversal\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[i-1]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[i-1]]\n\n            # Accept reversal if it improves at least one objective or is equally good\n            if (new_cost1 <= original_cost1) and (new_cost2 <= original_cost2):\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Rebuild solution with missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7063568056004766,
            2.3433068990707397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmin(normalized.max(axis=1) - normalized.min(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware node sequence reordering\n    if n > 4:\n        # Select three segments to reorder\n        a, b, c, d = np.random.choice(n, size=4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # Extract and reorder segments\n        segments = [new_solution[a:b], new_solution[b:c], new_solution[c:d]]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate([new_solution[:a], *segments, new_solution[d:]])\n\n    # Probabilistic edge reversal\n    for i in range(1, n):\n        if np.random.random() < 0.3:\n            # Calculate cost before reversal\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n            # Calculate cost after reversal\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[i-1]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[i-1]]\n\n            # Accept reversal if it improves at least one objective or is equally good\n            if (new_cost1 <= original_cost1) and (new_cost2 <= original_cost2):\n                new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Rebuild solution with missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with a multi-objective aware 3-opt move, prioritizing solutions with better Pareto dominance and higher crowding distance to guide the search toward Pareto fronts while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before 3-opt\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Generate all possible 3-opt configurations\n        configs = [\n            [i, j, k],\n            [i, k, j],\n            [j, i, k],\n            [j, k, i],\n            [k, i, j],\n            [k, j, i]\n        ]\n\n        best_config = [i, j, k]\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for config in configs:\n            x, y, z = config\n            cost1 = (distance_matrix_1[new_solution[x-1], new_solution[x]] +\n                     distance_matrix_1[new_solution[y-1], new_solution[y]] +\n                     distance_matrix_1[new_solution[z-1], new_solution[z]])\n            cost2 = (distance_matrix_2[new_solution[x-1], new_solution[x]] +\n                     distance_matrix_2[new_solution[y-1], new_solution[y]] +\n                     distance_matrix_2[new_solution[z-1], new_solution[z]])\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_config = config\n                best_cost1, best_cost2 = cost1, cost2\n\n        if best_config != [i, j, k]:\n            x, y, z = best_config\n            new_solution[x:y] = new_solution[x:y][::-1]\n            new_solution[y:z] = new_solution[y:z][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8183514451339051,
            1.636189579963684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment relocation\n    if n > 3:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Step 2: Multi-objective aware 3-opt move\n    if n > 4:\n        i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate cost before 3-opt\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n        # Generate all possible 3-opt configurations\n        configs = [\n            [i, j, k],\n            [i, k, j],\n            [j, i, k],\n            [j, k, i],\n            [k, i, j],\n            [k, j, i]\n        ]\n\n        best_config = [i, j, k]\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for config in configs:\n            x, y, z = config\n            cost1 = (distance_matrix_1[new_solution[x-1], new_solution[x]] +\n                     distance_matrix_1[new_solution[y-1], new_solution[y]] +\n                     distance_matrix_1[new_solution[z-1], new_solution[z]])\n            cost2 = (distance_matrix_2[new_solution[x-1], new_solution[x]] +\n                     distance_matrix_2[new_solution[y-1], new_solution[y]] +\n                     distance_matrix_2[new_solution[z-1], new_solution[z]])\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_config = config\n                best_cost1, best_cost2 = cost1, cost2\n\n        if best_config != [i, j, k]:\n            x, y, z = best_config\n            new_solution[x:y] = new_solution[x:y][::-1]\n            new_solution[y:z] = new_solution[y:z][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic node reordering strategy with a multi-objective aware path reversal, guided by both edge dominance and solution diversity metrics to explore high-quality regions of the search space while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity metric (promising for exploration)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax([np.std(archive[i][0]) * diversity for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic node reordering with path reversal\n    if n > 3:\n        # Identify edge dominance in both objectives\n        edge_dominance = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_dominance.append((cost1 + cost2) / (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))\n\n        # Select segment to reverse based on edge dominance\n        threshold = np.percentile(edge_dominance, 75)\n        candidate_segments = [i for i in range(n-1) if edge_dominance[i] > threshold]\n\n        if candidate_segments:\n            a = np.random.choice(candidate_segments)\n            b = np.random.randint(a+1, min(a+5, n))\n\n            # Reverse segment with probabilistic validation\n            if np.random.random() < 0.7:  # 70% chance to reverse\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective aware path reversal\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before reversal\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate cost after reversal\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept reversal if it improves at least one objective or maintains diversity\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9566422697195449,
            11.776433885097504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity metric (promising for exploration)\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax([np.std(archive[i][0]) * diversity for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic node reordering with path reversal\n    if n > 3:\n        # Identify edge dominance in both objectives\n        edge_dominance = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            edge_dominance.append((cost1 + cost2) / (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))\n\n        # Select segment to reverse based on edge dominance\n        threshold = np.percentile(edge_dominance, 75)\n        candidate_segments = [i for i in range(n-1) if edge_dominance[i] > threshold]\n\n        if candidate_segments:\n            a = np.random.choice(candidate_segments)\n            b = np.random.randint(a+1, min(a+5, n))\n\n            # Reverse segment with probabilistic validation\n            if np.random.random() < 0.7:  # 70% chance to reverse\n                new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective aware path reversal\n    if n > 4:\n        i = np.random.randint(0, n-3)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before reversal\n        original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n        original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        # Calculate cost after reversal\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_1[new_solution[i], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                    distance_matrix_2[new_solution[i], new_solution[j]])\n\n        # Accept reversal if it improves at least one objective or maintains diversity\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (np.random.random() < 0.3):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node relocation with a Pareto-optimal edge insertion, favoring solutions with higher crowding distance to explore less crowded regions of the Pareto front while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 2: Pareto-optimal edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8489766572125741,
            1.5790688395500183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node relocation\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 2: Pareto-optimal edge insertion\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm combines a multi-objective aware node relocation with a Pareto-dominance guided segment rotation to explore diverse regions of the search space while maintaining feasibility, balancing exploration and exploitation through adaptive selection based on solution quality and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_cost1, base_cost2 = archive[selected_idx][1]\n\n    # Calculate dominance count for the selected solution\n    dominance_count = sum(1 for _, (cost1, cost2) in archive if (cost1 <= base_cost1 and cost2 < base_cost2) or (cost1 < base_cost1 and cost2 <= base_cost2))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion position based on both objectives\n        best_pos = -1\n        min_cost1, min_cost2 = float('inf'), float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            prev_node = new_solution[pos - 1]\n            next_node = new_solution[pos]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine objectives with dominance count consideration\n            combined_cost = (new_cost1 + new_cost2) / (1 + dominance_count)\n\n            if combined_cost < (min_cost1 + min_cost2):\n                min_cost1, min_cost2 = new_cost1, new_cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Pareto-dominance guided segment rotation\n    if n > 4 and dominance_count > 0:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Rotate segment based on objective dominance\n        if np.random.rand() < 0.5:\n            rotated_segment = np.roll(segment, 1)  # Left rotation\n        else:\n            rotated_segment = np.roll(segment, -1)  # Right rotation\n\n        # Check if rotation improves at least one objective\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = rotated_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7669018894380502,
            2.223498225212097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    base_cost1, base_cost2 = archive[selected_idx][1]\n\n    # Calculate dominance count for the selected solution\n    dominance_count = sum(1 for _, (cost1, cost2) in archive if (cost1 <= base_cost1 and cost2 < base_cost2) or (cost1 < base_cost1 and cost2 <= base_cost2))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Find best insertion position based on both objectives\n        best_pos = -1\n        min_cost1, min_cost2 = float('inf'), float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            prev_node = new_solution[pos - 1]\n            next_node = new_solution[pos]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine objectives with dominance count consideration\n            combined_cost = (new_cost1 + new_cost2) / (1 + dominance_count)\n\n            if combined_cost < (min_cost1 + min_cost2):\n                min_cost1, min_cost2 = new_cost1, new_cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 2: Pareto-dominance guided segment rotation\n    if n > 4 and dominance_count > 0:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Rotate segment based on objective dominance\n        if np.random.rand() < 0.5:\n            rotated_segment = np.roll(segment, 1)  # Left rotation\n        else:\n            rotated_segment = np.roll(segment, -1)  # Right rotation\n\n        # Check if rotation improves at least one objective\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = rotated_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.874975468790365,
            2.2197534441947937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{A novel hybrid local search algorithm combines edge swaps with adaptive segment inversions, prioritizing edges with high potential for multi-objective improvement while maintaining feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swaps with adaptive segment inversions\n    for _ in range(3):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Invert segment [a, b]\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.880896445658325,
            2.3910922408103943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.prod(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge swaps with adaptive segment inversions\n    for _ in range(3):\n        # Randomly select segments to manipulate\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Invert segment [a, b]\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective aware 2-opt-like edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized node insertion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware edge swap (2-opt-like)\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9009006881816447,
            1.8631752729415894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized node insertion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Multi-objective aware edge swap (2-opt-like)\n    if n > 3:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive node swapping with multi-objective edge prioritization, dynamically balancing improvements in both objective spaces through a probabilistic selection mechanism that considers both edge quality and solution structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge quality scores for both objectives\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        edge_scores[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                          distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n    # Adaptive node swapping with probabilistic selection\n    for _ in range(5):\n        # Select nodes with high edge scores\n        probs = edge_scores / edge_scores.sum()\n        i, j = np.random.choice(n, size=2, p=probs, replace=False)\n\n        # Perform node swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Validate and repair if needed\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8739621094695387,
            2.490872383117676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge quality scores for both objectives\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        edge_scores[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                          distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n    # Adaptive node swapping with probabilistic selection\n    for _ in range(5):\n        # Select nodes with high edge scores\n        probs = edge_scores / edge_scores.sum()\n        i, j = np.random.choice(n, size=2, p=probs, replace=False)\n\n        # Perform node swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Validate and repair if needed\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Final validation and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a multi-objective aware edge insertion, prioritizing solutions with high dominance rank or diversity metrics in the archive to guide the search toward Pareto-optimal regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank or diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Multi-objective aware edge insertion\n    if n > 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(1, n-2)\n        if i == j:\n            j = (j + 1) % (n-2)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.where(new_solution == new_solution[j])[0][0]\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8210326452643224,
            1.4096079468727112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance rank or diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Multi-objective aware edge insertion\n    if n > 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(1, n-2)\n        if i == j:\n            j = (j + 1) % (n-2)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.where(new_solution == new_solution[j])[0][0]\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines edge insertions with guided segment relocations, prioritizing edges with high potential for multi-objective improvement, while maintaining feasibility through a dynamic validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selected_idx = np.argmax(normalized.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operation: edge insertion with guided segment relocation\n    for _ in range(5):\n        # Randomly select segments to manipulate\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Insert segment [b+1, c] before position a\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b+1], new_solution[c+1:]])\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: restore order of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This novel algorithm combines multi-objective aware path segmentation with dynamic edge reallocation, prioritizing segments that show promise for improvement in both objectives while maintaining feasibility through a hybrid validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance score (more non-dominated solutions)\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count += 1\n        dominance_scores[i] = -dominated_count  # Higher score = more non-dominated\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware path segmentation\n    for _ in range(3):\n        # Randomly select segments to manipulate\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate potential improvement for both objectives\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Create new segment by rotating the selected segment\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n        # Validate and repair if needed\n        if len(np.unique(new_solution)) != n:\n            # Simple repair: restore original segment if invalid\n            new_solution[a:b+1] = segment\n            continue\n\n        # Check if improvement in at least one objective\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.8043614619551139,
            1.959919273853302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance score (more non-dominated solutions)\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count += 1\n        dominance_scores[i] = -dominated_count  # Higher score = more non-dominated\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware path segmentation\n    for _ in range(3):\n        # Randomly select segments to manipulate\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Calculate potential improvement for both objectives\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[c-1], new_solution[c]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Create new segment by rotating the selected segment\n        segment = new_solution[a:b+1]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[a:b+1] = rotated_segment\n\n        # Validate and repair if needed\n        if len(np.unique(new_solution)) != n:\n            # Simple repair: restore original segment if invalid\n            new_solution[a:b+1] = segment\n            continue\n\n        # Check if improvement in at least one objective\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{The common backbone idea in the provided algorithms is a hybrid local search that combines randomized segment inversion with multi-objective aware edge swaps, prioritizing solutions with high crowding distance or Pareto dominance to guide the search toward less explored regions. The new algorithm will employ a multi-objective aware segment crossover combined with a randomized edge reversal, focusing on solutions with high diversity in the archive to explore uncharted regions of the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (low crowding distance)\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.linalg.norm(np.diff(np.sort(objectives, axis=0), axis=0), axis=1)\n    crowding_distances = np.append(crowding_distances, crowding_distances[-1])\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment crossover + randomized edge reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment crossover\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = base_solution[a:b]\n\n        # Find a partner solution with complementary objectives\n        partner_idx = np.random.choice(len(archive))\n        partner_solution = archive[partner_idx][0]\n\n        # Identify the segment in partner that complements the base segment\n        partner_segment = []\n        for node in partner_solution:\n            if node not in segment:\n                partner_segment.append(node)\n                if len(partner_segment) == len(segment):\n                    break\n\n        if len(partner_segment) == len(segment):\n            # Replace the base segment with the partner segment\n            new_solution[a:b] = partner_segment\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9379245304321563,
            1.3235713839530945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (low crowding distance)\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.linalg.norm(np.diff(np.sort(objectives, axis=0), axis=0), axis=1)\n    crowding_distances = np.append(crowding_distances, crowding_distances[-1])\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective aware segment crossover + randomized edge reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment crossover\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = base_solution[a:b]\n\n        # Find a partner solution with complementary objectives\n        partner_idx = np.random.choice(len(archive))\n        partner_solution = archive[partner_idx][0]\n\n        # Identify the segment in partner that complements the base segment\n        partner_segment = []\n        for node in partner_solution:\n            if node not in segment:\n                partner_segment.append(node)\n                if len(partner_segment) == len(segment):\n                    break\n\n        if len(partner_segment) == len(segment):\n            # Replace the base segment with the partner segment\n            new_solution[a:b] = partner_segment\n\n    # Step 2: Randomized edge reversal\n    if n > 2:\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Calculate cost before reversal\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept reversal if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm implements a novel hybrid local search strategy that combines a multi-objective aware segment relinking with adaptive edge insertion, prioritizing solutions with high crowding distance or Pareto dominance to guide the search toward unexplored regions while maintaining feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relinking\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Find insertion point that improves at least one objective\n        best_insert = None\n        best_improvement = 0\n\n        for i in range(n):\n            if i >= a and i < b:\n                continue\n\n            # Calculate insertion cost\n            if i == 0:\n                insert_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[1]]\n                insert_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[1]]\n            elif i == n-1:\n                insert_cost1 = distance_matrix_1[new_solution[-2], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                insert_cost2 = distance_matrix_2[new_solution[-2], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                insert_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                insert_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n\n            # Calculate improvement\n            improvement = (seg_cost1 - insert_cost1) + (seg_cost2 - insert_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = i\n\n        if best_insert is not None:\n            # Remove original segment\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            # Insert segment at new position\n            if best_insert == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_insert == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_insert], segment, new_solution[best_insert:]])\n\n    # Step 2: Adaptive edge insertion\n    if n > 2:\n        # Select a node to relocate\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Find best insertion position that improves at least one objective\n        best_pos = k\n        best_improvement = 0\n\n        for i in range(n):\n            if i == k or (i == k+1 and k < n-1) or (i == k-1 and k > 0):\n                continue\n\n            # Calculate cost before and after insertion\n            if k == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[-2], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-2], new_solution[0]]\n            elif k == n-1:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[-2], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-2], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n                original_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n\n            if i == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n                new_cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n            elif i == n-1:\n                new_cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i+1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i+1]]\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        if best_pos != k:\n            # Remove node from current position\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            # Insert node at new position\n            if best_pos == 0:\n                new_solution = np.concatenate([[node], new_solution])\n            elif best_pos == len(new_solution):\n                new_solution = np.concatenate([new_solution, [node]])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8567630249243731,
            2.656254529953003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Multi-objective aware segment relinking\n    if n > 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Find insertion point that improves at least one objective\n        best_insert = None\n        best_improvement = 0\n\n        for i in range(n):\n            if i >= a and i < b:\n                continue\n\n            # Calculate insertion cost\n            if i == 0:\n                insert_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[1]]\n                insert_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[1]]\n            elif i == n-1:\n                insert_cost1 = distance_matrix_1[new_solution[-2], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n                insert_cost2 = distance_matrix_2[new_solution[-2], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n            else:\n                insert_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[i+1]]\n                insert_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[i+1]]\n\n            # Calculate improvement\n            improvement = (seg_cost1 - insert_cost1) + (seg_cost2 - insert_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert = i\n\n        if best_insert is not None:\n            # Remove original segment\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            # Insert segment at new position\n            if best_insert == 0:\n                new_solution = np.concatenate([segment, new_solution])\n            elif best_insert == len(new_solution):\n                new_solution = np.concatenate([new_solution, segment])\n            else:\n                new_solution = np.concatenate([new_solution[:best_insert], segment, new_solution[best_insert:]])\n\n    # Step 2: Adaptive edge insertion\n    if n > 2:\n        # Select a node to relocate\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n\n        # Find best insertion position that improves at least one objective\n        best_pos = k\n        best_improvement = 0\n\n        for i in range(n):\n            if i == k or (i == k+1 and k < n-1) or (i == k-1 and k > 0):\n                continue\n\n            # Calculate cost before and after insertion\n            if k == 0:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[-2], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-2], new_solution[0]]\n            elif k == n-1:\n                original_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[-2], new_solution[0]]\n                original_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-2], new_solution[0]]\n            else:\n                original_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n                original_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n\n            if i == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n                new_cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n            elif i == n-1:\n                new_cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n                new_cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i+1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i+1]]\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        if best_pos != k:\n            # Remove node from current position\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            # Insert node at new position\n            if best_pos == 0:\n                new_solution = np.concatenate([[node], new_solution])\n            elif best_pos == len(new_solution):\n                new_solution = np.concatenate([new_solution, [node]])\n            else:\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A novel hybrid local search operator that combines a randomized partial route reversal with a dominance-aware node insertion, focusing on solutions with high crowding distance to explore less crowded regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = np.array([obj[1] for _, obj in archive])  # Assuming obj[1] is crowding distance\n    selected_idx = np.random.choice(len(archive), p=crowding_distances/np.sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized partial route reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Dominance-aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i-1 or j == i+1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept insertion if it dominates or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7181756745533622,
            1.8513693809509277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    crowding_distances = np.array([obj[1] for _, obj in archive])  # Assuming obj[1] is crowding distance\n    selected_idx = np.random.choice(len(archive), p=crowding_distances/np.sum(crowding_distances))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized partial route reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Dominance-aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(0, n)\n        while j == i or j == i-1 or j == i+1:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept insertion if it dominates or is non-dominated\n        if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment reversal with a multi-objective aware node insertion, prioritizing solutions with high crowding distance or Pareto dominance in the archive to guide the search toward diverse regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8198242204536204,
            1.530605435371399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment reversal\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a randomized segment inversion with a multi-objective aware edge swap, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: randomized segment inversion + multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized segment inversion\n    if n > 2:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective aware edge swap\n    if n > 3:\n        i = np.random.randint(0, n-2)\n        j = np.random.randint(i+2, n)\n\n        # Calculate cost before swap\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after swap\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{A novel hybrid local search operator that combines a randomized k-segment inversion with a multi-objective aware node insertion, prioritizing solutions with higher crowding distance or Pareto dominance in the archive to guide the search toward less explored regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-segment inversion (k=2 to 4)\n    if n > 3:\n        k = np.random.randint(2, 5)\n        segments = sorted(np.random.choice(n, size=k, replace=False))\n        segments = np.concatenate([[0], segments, [n]])\n        for i in range(1, len(segments)):\n            start, end = segments[i-1], segments[i]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8398620153273296,
            2.1715826392173767
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomized k-segment inversion (k=2 to 4)\n    if n > 3:\n        k = np.random.randint(2, 5)\n        segments = sorted(np.random.choice(n, size=k, replace=False))\n        segments = np.concatenate([[0], segments, [n]])\n        for i in range(1, len(segments)):\n            start, end = segments[i-1], segments[i]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Multi-objective aware node insertion\n    if n > 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n:\n            j = np.random.randint(0, n)\n\n        # Calculate cost before insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        # Accept insertion if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n"
    }
]