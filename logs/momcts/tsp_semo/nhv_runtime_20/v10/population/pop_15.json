[
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted probability favoring solutions with lower average normalized objective values, then applies either a standard 2-opt operation or a novel segment inversion/reinsertion strategy to generate a neighbor solution while ensuring feasibility. The segment operation specifically inverts a random segment of the tour and reinserts it at the best position to minimize the combined cost of both objectives, providing a more exploratory local search compared to pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and segment inversion/reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment operation\n    if random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion and reinsertion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9353011851346344,
            1.5762245655059814
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8179669842566333,
            0.3183813691139221
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing Pareto-efficient solutions (non-dominated by others) and falling back to the lowest-sum objective if none exist. It then applies a hybrid local search combining segment reversal (randomly reversing a segment of the tour) and adaptive node relocation (probabilistically relocating nodes based on combined cost improvements in both objectives), ensuring feasibility by maintaining valid TSP tours throughout. The method balances exploration and exploitation through randomness and dynamic trade-off considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto-efficient front and objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        pareto_front[i] = not dominated\n\n    if np.any(pareto_front):\n        candidates = [i for i, is_pareto in enumerate(pareto_front) if is_pareto]\n        selected_idx = np.random.choice(candidates)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + adaptive node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment reversal\n    start = np.random.randint(0, n-2)\n    end = np.random.randint(start+2, min(start+10, n))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node relocation\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n\n        # Calculate potential insertion positions based on both objectives\n        costs = []\n        for pos in range(n):\n            if pos == current_pos:\n                costs.append(np.inf)\n                continue\n\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            costs.append((cost1 + cost2) * (1 + np.random.uniform(-0.1, 0.1)))\n\n        best_pos = np.argmin(costs)\n        if costs[best_pos] < np.inf:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9538456537192214,
            10.783259153366089
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a promising solution from the archive by prioritizing balanced objectives (40% weight for the first cost, 60% for the second) and randomly applies either a node swap or a path reversal to generate a neighbor, ensuring feasibility by verifying no nodes are duplicated or missing. The method balances exploration and exploitation by favoring more balanced solutions and using a hybrid local search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower weighted objectives (prioritize balanced solutions)\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)  # Select from top 5 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or path reversal\n    if random.random() < 0.6:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path reversal between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.9229999080145157,
            1.1371864676475525
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined objective costs (weighted 60% for the first objective and 40% for the second), then applies a hybrid local search that randomly chooses between segment reversal (reversing a random segment of the tour) or edge swapping (swapping two non-adjacent edges) to generate a neighbor solution, ensuring feasibility by checking for duplicate nodes. The selection process biases toward high-potential solutions, while the local search diversifies exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective (exponential weighting)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    selected_idx = min(15, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal or edge swapping\n    if random.random() < 0.6:\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge swapping\n        if n >= 4:\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify solution validity\n    assert len(new_solution) == len(selected_solution), \"Solution length mismatch\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes detected\"\n\n    return new_solution\n\n",
        "score": [
            -0.9076585486137072,
            1.1378300786018372
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive based on hypervolume contribution, then applies a hybrid local search combining edge exchange (prioritizing weighted cost improvements) and biased random insertion (favoring cost reductions in the first objective space). It ensures feasibility by validating all operations and dynamically adjusts trade-offs between objectives. The weighted costs (0.6 for first objective, 0.4 for second) guide edge exchanges, while insertions prioritize the first objective (0.7 weight) over the second (0.3).",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using hypervolume contribution\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0) * 1.1\n    contributions = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            contributions[i] = np.prod(ref_point - objectives[i])\n\n    if np.any(contributions > 0):\n        candidates = np.where(contributions > 0)[0]\n        selected_idx = np.random.choice(candidates)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Edge exchange with objective bias\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_sol = new_solution.copy()\n        temp_sol[a], temp_sol[b] = temp_sol[b], temp_sol[a]\n\n        cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n        weighted_cost = cost1 * 0.6 + cost2 * 0.4\n\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_weighted = current_cost1 * 0.6 + current_cost2 * 0.4\n\n        if weighted_cost < current_weighted:\n            new_solution = temp_sol\n\n    # Biased random insertion\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n\n        candidates = []\n        for pos in range(n):\n            if pos == current_pos:\n                continue\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            candidates.append((temp_sol.copy(), cost1, cost2))\n\n        if candidates:\n            candidates.sort(key=lambda x: (x[1] * 0.7 + x[2] * 0.3))\n            selected = np.random.choice(min(3, len(candidates)))\n            new_solution = candidates[selected][0]\n\n    return new_solution\n\n",
        "score": [
            -0.9181888481622597,
            14.267144739627838
        ]
    },
    {
        "algorithm": "The algorithm combines weighted selection of solutions based on normalized objective values with a hybrid local search that dynamically partitions tours into segments, inverts them probabilistically based on their contribution to objectives, and reinserts them optimally, while also applying probabilistic edge swaps to refine the solution. It balances exploration and exploitation by adapting segment size and inversion probability to the segment's impact on objectives, ensuring feasibility and promoting diverse high-quality solutions across the bi-objective space. The selection prioritizes solutions with lower objective sums, while the local search intelligently explores the solution space through segment manipulation and edge swapping.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objective sum\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = 1 / (scores + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment partitioning and inversion\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate the segment's contribution to each objective\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    total_seg_cost = seg_cost1 + seg_cost2\n\n    # Dynamic inversion probability based on segment contribution\n    inversion_prob = min(0.9, 0.5 + (total_seg_cost / (seg_cost1 + seg_cost2 + 1e-10)) * 0.4)\n\n    if random.random() < inversion_prob:\n        segment = segment[::-1]\n\n    # Find best insertion point for the segment\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.903495168346596,
            4.518869042396545
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-efficient front with weighted probability, then applies a hybrid local search that combines segment inversion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility. The selection prioritizes non-dominated solutions, and the local search explores diverse neighborhoods by inverting segments and adaptively swapping edges, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto-efficient front with weighted probability\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        pareto_front[i] = not dominated\n\n    if np.any(pareto_front):\n        candidates = np.where(pareto_front)[0]\n        weights = 1 / (1 + np.sum(objectives[candidates], axis=1))\n        weights = weights / weights.sum()\n        selected_idx = np.random.choice(candidates, p=weights)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with adaptive edge swapping\n    if n >= 4:\n        # Segment inversion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n        # Adaptive edge swapping\n        for _ in range(2):\n            i, j = sorted(random.sample(range(n), 2))\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost * 1.1:  # Only accept if not significantly worse\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9072523421337589,
            7.819187700748444
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with higher combined objective values (70% weight for the first cost, 30% for the second) and applies a hybrid local search combining a 3-opt move with a segment shift to generate a neighbor, ensuring feasibility by validating the solution's structure. The selection process focuses on high-performing solutions, while the local search explores diverse neighborhood structures to improve solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with higher weighted objectives (prioritize high combined value)\n    archive_sorted = sorted(archive, key=lambda x: -(0.7 * x[1][0] + 0.3 * x[1][1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt move combined with segment shift\n    if random.random() < 0.5:\n        # 3-opt move: select 3 random edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Segment shift: move a random segment to a different position\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8709666729923933,
            1.2935565114021301
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with high potential for improvement based on a weighted combination of normalized objectives (70% weight on the first objective), then applies a hybrid local search that randomly combines edge reversal or node relocation on a randomly selected segment of the tour to generate a neighbor solution while ensuring feasibility. The selection process balances both objectives, while the local search explores the solution space through randomized segment manipulation and adaptive neighborhood selection.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using weighted objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Compute weighted objectives for selection\n    obj1 = np.array([obj[0] for obj in archive_objectives])\n    obj2 = np.array([obj[1] for obj in archive_objectives])\n\n    # Normalize and weight objectives\n    if len(obj1) > 1:\n        obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n        obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n    weight = 0.7  # Higher weight for first objective\n    fitness = weight * obj1 + (1 - weight) * obj2\n\n    # Select the solution with the highest fitness (most potential for improvement)\n    selected_idx = np.argmax(fitness)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length and position\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Hybrid local search: combine edge reversal and node relocation\n    if np.random.rand() < 0.6:\n        # Edge reversal: reverse a segment of the tour\n        segment = new_solution[start_pos:start_pos+segment_length]\n        new_solution[start_pos:start_pos+segment_length] = segment[::-1]\n    else:\n        # Node relocation: move a segment to a new position\n        segment = new_solution[start_pos:start_pos+segment_length]\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8963389812243644,
            1.603386640548706
        ]
    }
]