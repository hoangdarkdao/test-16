[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three non-consecutive edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n    if i + 1 == j or j + 1 == k:\n        return new_solution  # Skip if edges are consecutive\n\n    # Step 2: Reconnect the edges in a new order (8 possible configurations)\n    reconnect_options = [\n        (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i),\n        (i, j, k), (i, k, j)  # Additional novel configurations\n    ]\n    chosen = reconnect_options[np.random.randint(len(reconnect_options))]\n\n    # Reconstruct the tour\n    a, b, c = chosen\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Step 3: Novel edge-based perturbation - swap a random pair of edges\n    if np.random.random() < 0.3:\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8487308637935458,
            0.47968876361846924
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply segment reversal between i and j, and k and l\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment reversal causes duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8073223583080259,
            0.42307573556900024
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three non-consecutive edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n    if i + 1 == j or j + 1 == k:\n        return new_solution  # Skip if edges are consecutive\n\n    # Step 2: Reconnect the edges in a new order (8 possible configurations)\n    reconnect_options = [\n        (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i),\n        (i, j, k), (i, k, j)  # Additional novel configurations\n    ]\n    chosen = reconnect_options[np.random.randint(len(reconnect_options))]\n\n    # Reconstruct the tour\n    a, b, c = chosen\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Step 3: Novel edge-based perturbation - swap a random pair of edges\n    if np.random.random() < 0.3:\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        if abs(a - b) > 1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8487308637935458,
            0.47968876361846924
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])  # Sort by sum of objectives\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply segment reversal between i and j, and k and l\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment reversal causes duplicates\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8073223583080259,
            0.42307573556900024
        ]
    }
]