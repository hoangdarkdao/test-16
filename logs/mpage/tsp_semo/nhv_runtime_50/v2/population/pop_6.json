[
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Centric Path Decomposition and Reconstruction with Dynamic Segment Fusion,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective dominance\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then reconstructed using a dynamic fusion strategy that merges segments of the same objective type while preserving their original order, followed by an \"objective-aware segment inversion\" phase that probabilistically reverses segments of one objective to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.5 * cost2 or cost2 > 1.5 * cost1:\n            # If significantly dominated by one objective, end current segment\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic segment fusion\n    merged_segments = []\n    i = 0\n    while i < len(segments):\n        current_obj = 1 if sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1)) > \\\n                           sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1)) else 2\n\n        j = i + 1\n        while j < len(segments):\n            next_obj = 1 if sum(distance_matrix_1[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1)) > \\\n                            sum(distance_matrix_2[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1)) else 2\n\n            if current_obj == next_obj:\n                # Merge segments of the same objective\n                segments[i] = segments[i] + segments[j][1:]\n                j += 1\n            else:\n                break\n\n        merged_segments.append(segments[i])\n        i = j\n\n    # Step 4: Objective-aware segment inversion\n    for i in range(len(merged_segments)):\n        segment = merged_segments[i]\n        if len(segment) < 3:\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Decide whether to invert based on objective dominance\n        if cost1 > 1.3 * cost2:\n            # More dominated by objective 2, consider inversion\n            if random.random() < 0.5:\n                merged_segments[i] = segment[::-1]\n        elif cost2 > 1.3 * cost1:\n            # More dominated by objective 1, consider inversion\n            if random.random() < 0.5:\n                merged_segments[i] = segment[::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in merged_segments:\n        new_solution.extend(segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        if len(merged_segments) > 1:\n            i = random.randint(0, len(merged_segments)-1)\n            merged_segments[i] = merged_segments[i][::-1]\n            new_solution = []\n            for segment in merged_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9650858580707128,
               0.1937757134437561
          ]
     },
     {
          "algorithm": "{This novel algorithm, named \"Adaptive Objective-Driven Path Fusion and Multi-Space Edge Optimization,\" begins by identifying the solution in the archive with the highest combined objective value and then partitions it into multiple segments based on spatial clustering in both objective spaces. It then constructs a new solution by strategically fusing these segments through an adaptive path fusion process that prioritizes edges which show the most significant improvement in either objective space, while maintaining tour feasibility. The algorithm dynamically adjusts the fusion strategy based on the current solution's performance in both objectives, using a multi-space edge optimization phase to refine the tour by replacing edges with alternatives that offer better trade-offs between the objectives. The method employs a novel \"objective-aware edge selection\" mechanism that evaluates each edge's impact on both objectives before refinement, and includes a \"path diversity preservation\" step to ensure the solution maintains structural diversity while improving the objectives. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"solution quality validation\" mechanism that verifies the new solution's feasibility before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Spatial clustering-based segmentation\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n\n        # Calculate distance in both spaces\n        dist1 = distance_matrix_1[prev_node, curr_node]\n        dist2 = distance_matrix_2[prev_node, curr_node]\n\n        # Check if the edge is \"significant\" in either space\n        if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n            segments.append(current_segment)\n            current_segment = [curr_node]\n        else:\n            current_segment.append(curr_node)\n    segments.append(current_segment)\n\n    # Step 3: Adaptive path fusion\n    merged_solution = []\n    for i in range(len(segments)):\n        seg = segments[i]\n        if not merged_solution:\n            merged_solution.extend(seg)\n            continue\n\n        # Find the best connection between current end and next segment start\n        last_node = merged_solution[-1]\n        next_seg = segments[(i+1) % len(segments)]\n        first_node = next_seg[0]\n\n        # Evaluate potential connections\n        candidates = []\n        for node in seg:\n            candidates.append((last_node, node))\n            candidates.append((node, first_node))\n\n        # Select the best connection based on objective improvement\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for (a, b) in candidates:\n            # Calculate improvement in both objectives\n            original_cost1 = distance_matrix_1[last_node, first_node]\n            new_cost1 = distance_matrix_1[a, b]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[last_node, first_node]\n            new_cost2 = distance_matrix_2[a, b]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements with objective weights\n            obj1, obj2 = selected[1]\n            total_improvement = (improvement1 * obj1 + improvement2 * obj2) / (obj1 + obj2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_candidate = (a, b)\n\n        # Apply the best connection\n        if best_candidate:\n            a, b = best_candidate\n            if a == last_node:\n                merged_solution.extend(seg)\n            else:\n                # Find the node in seg that connects to first_node\n                connection_node = None\n                for node in seg:\n                    if node == b:\n                        connection_node = node\n                        break\n\n                if connection_node is not None:\n                    idx = np.where(seg == connection_node)[0][0]\n                    merged_solution.extend(seg[:idx+1])\n                    merged_solution.extend(seg[idx+1:])\n                else:\n                    merged_solution.extend(seg)\n        else:\n            merged_solution.extend(seg)\n\n    # Step 4: Multi-space edge optimization\n    for i in range(n):\n        current_node = merged_solution[i]\n        next_node = merged_solution[(i+1) % n]\n\n        # Find potential replacements\n        candidates = []\n        for j in range(n):\n            if j != i and j != (i+1) % n:\n                candidates.append((current_node, j, merged_solution[(i+1) % n]))\n\n        # Evaluate candidates\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for (a, b, c) in candidates:\n            # Calculate improvement in both objectives\n            original_cost1 = distance_matrix_1[a, c]\n            new_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[a, c]\n            new_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements with objective weights\n            obj1, obj2 = selected[1]\n            total_improvement = (improvement1 * obj1 + improvement2 * obj2) / (obj1 + obj2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_candidate = (a, b, c)\n\n        # Apply the best replacement if it improves both objectives\n        if best_candidate and best_improvement > 0:\n            a, b, c = best_candidate\n            # Insert the new node\n            merged_solution = np.insert(merged_solution, (i+1) % n, b)\n            # Remove duplicates if any\n            unique_nodes = np.unique(merged_solution)\n            if len(unique_nodes) < n:\n                # Rebuild the solution if duplicates exist\n                remaining_nodes = [node for node in range(n) if node not in unique_nodes]\n                merged_solution = np.concatenate([unique_nodes, remaining_nodes])\n            # Ensure circular tour\n            if merged_solution[0] != merged_solution[-1]:\n                merged_solution = np.append(merged_solution, merged_solution[0])\n\n    # Step 5: Verify feasibility\n    if len(set(merged_solution)) != n or len(merged_solution) != n:\n        merged_solution = base_solution.copy()\n\n    return merged_solution\n\n",
          "score": [
               -0.9987503052685248,
               5.6584725975990295
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8144581164160893,
               0.09934872388839722
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Driven Segment Reallocation with Dynamic Neighborhood Expansion,\" builds upon the common backbone of solution selection from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective dominance\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then reallocated using an adaptive strategy that dynamically expands the neighborhood by considering both local and global segment interactions, followed by an \"objective-balanced segment permutation\" phase that probabilistically reorders segments to explore alternative configurations. The method dynamically adjusts the decomposition and reallocation parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if cost1 > 1.2 * cost2 or cost2 > 1.2 * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive segment reallocation with dynamic neighborhood expansion\n    expanded_segments = []\n    for segment in segments:\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Expand neighborhood by considering local and global interactions\n        if cost1 > 1.5 * cost2:\n            # Expand segment by merging with next segment if beneficial\n            if len(expanded_segments) > 0 and len(segments) > 1:\n                last_segment = expanded_segments[-1]\n                last_cost1 = sum(distance_matrix_1[last_segment[j], last_segment[j+1]] for j in range(len(last_segment)-1))\n                last_cost2 = sum(distance_matrix_2[last_segment[j], last_segment[j+1]] for j in range(len(last_segment)-1))\n\n                if last_cost1 > 1.5 * last_cost2:\n                    expanded_segments[-1] = last_segment + segment\n                    continue\n\n        expanded_segments.append(segment)\n\n    # Step 4: Objective-balanced segment permutation\n    if len(expanded_segments) > 1:\n        for i in range(len(expanded_segments)):\n            if len(expanded_segments[i]) < 3:\n                continue\n\n            cost1 = sum(distance_matrix_1[expanded_segments[i][j], expanded_segments[i][j+1]] for j in range(len(expanded_segments[i])-1))\n            cost2 = sum(distance_matrix_2[expanded_segments[i][j], expanded_segments[i][j+1]] for j in range(len(expanded_segments[i])-1))\n\n            if cost1 > 1.3 * cost2:\n                if random.random() < 0.6:\n                    expanded_segments[i] = expanded_segments[i][::-1]\n            elif cost2 > 1.3 * cost1:\n                if random.random() < 0.6:\n                    expanded_segments[i] = expanded_segments[i][::-1]\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in expanded_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(expanded_segments) > 1:\n            i = random.randint(0, len(expanded_segments)-1)\n            expanded_segments[i] = expanded_segments[i][::-1]\n            new_solution = []\n            for segment in expanded_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8696070846348665,
               0.1638835072517395
          ]
     },
     {
          "algorithm": "{This novel algorithm, named \"Adaptive Objective-Centric Tour Reconstruction with Dynamic Path Realignment,\" begins by selecting the solution from the archive with the most balanced objective values, then decomposes the tour into segments based on their primary objective contribution using a novel \"objective dominance\" metric. It then reconstructs the tour by strategically realigning these segments through a dynamic path fusion process that prioritizes edges which show the most significant improvement in either objective space, while maintaining tour feasibility. The algorithm dynamically adjusts the fusion strategy based on the current solution's performance in both objectives, using a multi-space edge optimization phase to refine the tour by replacing edges with alternatives that offer better trade-offs between the objectives. The method employs a novel \"objective-aware edge selection\" mechanism that evaluates each edge's impact on both objectives before refinement, and includes a \"path diversity preservation\" step to ensure the solution maintains structural diversity while improving the objectives. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"solution quality validation\" mechanism that verifies the new solution's feasibility before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.5 * cost2:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        elif cost2 > 1.5 * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic path realignment\n    merged_solution = []\n    for i in range(len(segments)):\n        current_seg = segments[i]\n        if not merged_solution:\n            merged_solution.extend(current_seg)\n            continue\n\n        # Find the best connection between current end and next segment start\n        last_node = merged_solution[-1]\n        next_seg = segments[(i+1) % len(segments)]\n        first_node = next_seg[0]\n\n        # Evaluate potential connections\n        candidates = []\n        for node in current_seg:\n            candidates.append((last_node, node, first_node))\n\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for (a, b, c) in candidates:\n            # Calculate improvement in both objectives\n            original_cost1 = distance_matrix_1[a, c]\n            new_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[a, c]\n            new_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements with objective weights\n            obj1, obj2 = archive_sorted[0][1]\n            total_improvement = (improvement1 * obj1 + improvement2 * obj2) / (obj1 + obj2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_candidate = (a, b, c)\n\n        # Apply the best connection\n        if best_candidate and best_improvement > 0:\n            a, b, c = best_candidate\n            merged_solution.append(b)\n\n    # Complete the tour\n    merged_solution.extend(segments[-1][1:])\n    merged_solution.append(merged_solution[0])\n\n    # Step 4: Verify feasibility\n    unique_nodes = np.unique(merged_solution)\n    if len(unique_nodes) != n or len(merged_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        i = random.randint(0, len(segments)-1)\n        segments[i] = segments[i][::-1]\n        merged_solution = []\n        for seg in segments:\n            merged_solution.extend(seg)\n        merged_solution.append(merged_solution[0])\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.9701877202285001,
               0.23711872100830078
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Aware Tour Partitioning with Dynamic Segment Realignment,\" fundamentally diverges from both existing approaches by first partitioning the tour into segments based on their objective dominance using a novel \"objective divergence\" metric that measures the relative contribution of each segment to both objectives. These segments are then realigned using a dynamic segment shifting mechanism that probabilistically shifts segments between objectives while maintaining their order, followed by an \"objective-balanced segment rotation\" phase that rotates segments of both objectives to explore alternative configurations. The method dynamically adjusts the partitioning and shifting parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = random.choices(\n        [sol for sol, _ in archive_sorted[:min(5, len(archive_sorted))]],\n        weights=[1/(i+1) for i in range(min(5, len(archive_sorted)))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Partition tour into segments based on objective divergence\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Calculate objective divergence\n        divergence = abs(cost1 - cost2) / max(cost1, cost2, 1e-6)\n\n        if divergence > 0.7:  # High divergence, consider new segment\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic segment shifting\n    shifted_segments = segments.copy()\n    for i in range(len(shifted_segments)):\n        if len(shifted_segments[i]) < 2:\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[shifted_segments[i][j], shifted_segments[i][j+1]] for j in range(len(shifted_segments[i])-1))\n        cost2 = sum(distance_matrix_2[shifted_segments[i][j], shifted_segments[i][j+1]] for j in range(len(shifted_segments[i])-1))\n\n        # Decide whether to shift based on objective balance\n        if cost1 > 1.2 * cost2 and random.random() < 0.4:\n            # Shift to objective 2\n            shifted_segments[i] = shifted_segments[i][::-1]\n        elif cost2 > 1.2 * cost1 and random.random() < 0.4:\n            # Shift to objective 1\n            shifted_segments[i] = shifted_segments[i][::-1]\n\n    # Step 4: Objective-balanced segment rotation\n    for i in range(len(shifted_segments)):\n        if len(shifted_segments[i]) < 3:\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[shifted_segments[i][j], shifted_segments[i][j+1]] for j in range(len(shifted_segments[i])-1))\n        cost2 = sum(distance_matrix_2[shifted_segments[i][j], shifted_segments[i][j+1]] for j in range(len(shifted_segments[i])-1))\n\n        # Decide whether to rotate based on objective balance\n        if cost1 > cost2 and random.random() < 0.3:\n            # Rotate right\n            shifted_segments[i] = [shifted_segments[i][-1]] + shifted_segments[i][:-1]\n        elif cost2 > cost1 and random.random() < 0.3:\n            # Rotate left\n            shifted_segments[i] = shifted_segments[i][1:] + [shifted_segments[i][0]]\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in shifted_segments:\n        new_solution.extend(segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        if len(shifted_segments) > 1:\n            i = random.randint(0, len(shifted_segments)-1)\n            shifted_segments[i] = shifted_segments[i][::-1]\n            new_solution = []\n            for segment in shifted_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8570839226861593,
               0.21186941862106323
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Multi-Objective Tour Fragmentation and Reconstruction,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's Pareto front, then adaptively selects and fragments the tour into multiple segments based on their contribution to each objective. These segments are then reconstructed using a novel \"objective-aware segment merging\" heuristic that prioritizes the most beneficial segments for each objective while maintaining tour feasibility. The method dynamically adjusts the fragmentation size and merging strategy based on the current solution's performance in both objective spaces, allowing for both fine-grained local improvements and more disruptive global explorations. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"segment quality assessment\" mechanism that evaluates each segment's impact on both objectives before merging.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Step 2: Select base solution with probability based on solution quality\n    base_solution = random.choices(\n        non_dominated,\n        weights=[1/(i+1) for i in range(len(non_dominated))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Adaptive tour fragmentation and reconstruction\n    if n > 3:\n        # Determine fragmentation size based on solution quality\n        fragment_size = min(3, max(1, n // 10))\n        num_fragments = max(2, n // fragment_size)\n\n        # Randomly select fragments to reconstruct\n        fragment_indices = sorted(random.sample(range(1, n-1), num_fragments-1))\n        fragments = []\n        start = 0\n        for idx in fragment_indices:\n            fragments.append(new_solution[start:idx])\n            start = idx\n        fragments.append(new_solution[start:])\n\n        # Shuffle fragments with probability based on objective performance\n        if random.random() < 0.7:\n            random.shuffle(fragments)\n\n        # Reconstruct solution with objective-aware merging\n        merged_solution = []\n        for i in range(len(fragments)):\n            # Calculate fragment quality for each objective\n            frag = fragments[i]\n            if len(frag) < 2:\n                merged_solution.extend(frag)\n                continue\n\n            # Calculate objective contributions\n            obj1_contrib = sum(distance_matrix_1[frag[j], frag[j+1]] for j in range(len(frag)-1))\n            obj2_contrib = sum(distance_matrix_2[frag[j], frag[j+1]] for j in range(len(frag)-1))\n\n            # Decide whether to reverse the fragment based on objective performance\n            if i > 0 and i < len(fragments)-1:\n                prev_node = merged_solution[-1] if merged_solution else fragments[i-1][-1]\n                next_node = fragments[i+1][0] if i < len(fragments)-1 else frag[-1]\n\n                # Calculate potential improvement if reversed\n                rev_obj1 = sum(distance_matrix_1[frag[j], frag[j+1]] for j in range(len(frag)-1))\n                rev_obj2 = sum(distance_matrix_2[frag[j], frag[j+1]] for j in range(len(frag)-1))\n\n                if (rev_obj1 < obj1_contrib and rev_obj2 < obj2_contrib) or \\\n                   (random.random() < 0.3 and (rev_obj1 < obj1_contrib or rev_obj2 < obj2_contrib)):\n                    frag = frag[::-1]\n\n            merged_solution.extend(frag)\n\n        # Ensure the tour is circular\n        if merged_solution[0] != merged_solution[-1]:\n            merged_solution.append(merged_solution[0])\n\n        new_solution = np.array(merged_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9578128800630137,
               0.3399670124053955
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Centric Tour Recombination and Adaptive Edge Refinement,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's Pareto front, then selects a base solution based on its objective performance and structural diversity. The algorithm then partitions the tour into multiple segments and recombines them using an objective-centric approach that prioritizes the most beneficial edges for each objective while maintaining tour feasibility. This is followed by an adaptive edge refinement phase that selectively improves the tour by replacing edges with better alternatives from a candidate pool, where the selection of candidates is guided by both objective improvements and spatial proximity in the coordinate spaces. The method dynamically adjusts the refinement intensity based on the current solution's performance in both objective spaces, allowing for both fine-grained local improvements and more disruptive global explorations. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"edge quality assessment\" mechanism that evaluates each edge's impact on both objectives before refinement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Select base solution with probability based on solution quality\n    base_solution = random.choices(\n        non_dominated,\n        weights=[1/(i+1) for i in range(len(non_dominated))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-centric tour recombination\n    if n > 3:\n        # Partition the tour into segments\n        num_segments = max(2, n // 5)\n        segment_length = n // num_segments\n        segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(num_segments)]\n\n        # For each segment, identify the best edges for each objective\n        for i in range(len(segments)):\n            seg = segments[i]\n            if len(seg) < 2:\n                continue\n\n            # Find the best edge in the segment for each objective\n            best_edge1 = (0, 1)\n            best_edge2 = (0, 1)\n            min_dist1 = distance_matrix_1[seg[0], seg[1]]\n            min_dist2 = distance_matrix_2[seg[0], seg[1]]\n\n            for j in range(len(seg)-1):\n                if distance_matrix_1[seg[j], seg[j+1]] < min_dist1:\n                    min_dist1 = distance_matrix_1[seg[j], seg[j+1]]\n                    best_edge1 = (j, j+1)\n                if distance_matrix_2[seg[j], seg[j+1]] < min_dist2:\n                    min_dist2 = distance_matrix_2[seg[j], seg[j+1]]\n                    best_edge2 = (j, j+1)\n\n            # Decide which edges to keep based on objective priorities\n            if random.random() < 0.5:\n                # Prioritize first objective\n                if best_edge1 != best_edge2:\n                    # Replace the non-optimal edges with optimal ones\n                    if best_edge1[0] < best_edge2[0]:\n                        seg[best_edge2[0]:best_edge2[1]] = seg[best_edge1[0]:best_edge1[1]]\n                    else:\n                        seg[best_edge1[0]:best_edge1[1]] = seg[best_edge2[0]:best_edge2[1]]\n            else:\n                # Prioritize second objective\n                if best_edge1 != best_edge2:\n                    if best_edge2[0] < best_edge1[0]:\n                        seg[best_edge1[0]:best_edge1[1]] = seg[best_edge2[0]:best_edge2[1]]\n                    else:\n                        seg[best_edge2[0]:best_edge2[1]] = seg[best_edge1[0]:best_edge1[1]]\n\n            segments[i] = seg\n\n        # Recombine segments with adaptive edge refinement\n        merged_solution = []\n        for i in range(len(segments)):\n            seg = segments[i]\n            if not merged_solution:\n                merged_solution.extend(seg)\n            else:\n                # Find the best connection between current end and next segment start\n                last_node = merged_solution[-1]\n                next_seg = segments[(i+1) % len(segments)]\n                first_node = next_seg[0]\n\n                # Create candidate edges\n                candidates = []\n                for node in seg:\n                    candidates.append((last_node, node))\n                    candidates.append((node, first_node))\n\n                # Evaluate candidates based on both objectives\n                best_candidate = candidates[0]\n                min_cost1 = distance_matrix_1[last_node, seg[0]] + distance_matrix_1[seg[-1], first_node]\n                min_cost2 = distance_matrix_2[last_node, seg[0]] + distance_matrix_2[seg[-1], first_node]\n\n                for (a, b) in candidates:\n                    cost1 = distance_matrix_1[a, b]\n                    cost2 = distance_matrix_2[a, b]\n                    if (cost1 < min_cost1 and cost2 <= min_cost2) or (cost1 <= min_cost1 and cost2 < min_cost2):\n                        min_cost1 = cost1\n                        min_cost2 = cost2\n                        best_candidate = (a, b)\n\n                # Apply the best connection\n                if best_candidate[0] == last_node:\n                    merged_solution.extend(seg)\n                else:\n                    # Find the node in seg that connects to first_node\n                    connection_node = None\n                    for node in seg:\n                        if distance_matrix_1[node, first_node] < distance_matrix_1[seg[0], first_node] or \\\n                           distance_matrix_2[node, first_node] < distance_matrix_2[seg[0], first_node]:\n                            connection_node = node\n                            break\n\n                    if connection_node is not None:\n                        # Split the segment at the connection node\n                        idx = np.where(seg == connection_node)[0][0]\n                        merged_solution.extend(seg[:idx+1])\n                        merged_solution.extend(seg[idx+1:])\n                    else:\n                        merged_solution.extend(seg)\n\n        # Ensure the tour is circular\n        if merged_solution[0] != merged_solution[-1]:\n            merged_solution.append(merged_solution[0])\n\n        new_solution = np.array(merged_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9645529101975834,
               0.40858298540115356
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Driven Tour Decomposition with Dynamic Segment Rebalancing,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective dominance\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then reconstructed using a dynamic rebalancing strategy that redistributes nodes between segments while preserving their original objective dominance, followed by an \"objective-aware node swapping\" phase that exchanges nodes between segments of different objectives to explore alternative configurations. The method dynamically adjusts the decomposition and rebalancing parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.2 * cost2:\n            # Dominated by objective 1\n            segments.append(current_segment)\n            current_segment = [current_node]\n        elif cost2 > 1.2 * cost1:\n            # Dominated by objective 2\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic segment rebalancing\n    for i in range(len(segments)):\n        segment = segments[i]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Decide whether to rebalance based on objective dominance\n        if cost1 > cost2:\n            # More dominated by objective 1, try to transfer nodes to objective 2 segments\n            for j in range(len(segments)):\n                if i == j:\n                    continue\n                other_segment = segments[j]\n                if len(other_segment) < 2:\n                    continue\n\n                # Calculate other segment's costs\n                other_cost1 = sum(distance_matrix_1[other_segment[k], other_segment[k+1]] for k in range(len(other_segment)-1))\n                other_cost2 = sum(distance_matrix_2[other_segment[k], other_segment[k+1]] for k in range(len(other_segment)-1))\n\n                if other_cost2 > other_cost1:\n                    # Transfer a node from objective 1 segment to objective 2 segment\n                    if len(segment) > 2:\n                        node_to_transfer = segment[1]\n                        segment.remove(node_to_transfer)\n                        other_segment.insert(1, node_to_transfer)\n                        break\n        else:\n            # More dominated by objective 2, try to transfer nodes to objective 1 segments\n            for j in range(len(segments)):\n                if i == j:\n                    continue\n                other_segment = segments[j]\n                if len(other_segment) < 2:\n                    continue\n\n                # Calculate other segment's costs\n                other_cost1 = sum(distance_matrix_1[other_segment[k], other_segment[k+1]] for k in range(len(other_segment)-1))\n                other_cost2 = sum(distance_matrix_2[other_segment[k], other_segment[k+1]] for k in range(len(other_segment)-1))\n\n                if other_cost1 > other_cost2:\n                    # Transfer a node from objective 2 segment to objective 1 segment\n                    if len(segment) > 2:\n                        node_to_transfer = segment[1]\n                        segment.remove(node_to_transfer)\n                        other_segment.insert(1, node_to_transfer)\n                        break\n\n    # Step 4: Objective-aware node swapping\n    for i in range(len(segments)):\n        segment1 = segments[i]\n        if len(segment1) < 2:\n            continue\n\n        # Find the most expensive node in this segment\n        max_cost1 = -1\n        max_cost2 = -1\n        max_node1 = -1\n        max_node2 = -1\n\n        for j in range(len(segment1)-1):\n            node1 = segment1[j]\n            node2 = segment1[j+1]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n\n            if cost1 > max_cost1:\n                max_cost1 = cost1\n                max_node1 = j\n\n            if cost2 > max_cost2:\n                max_cost2 = cost2\n                max_node2 = j\n\n        # Swap with a node from another segment if beneficial\n        for j in range(len(segments)):\n            if i == j:\n                continue\n            segment2 = segments[j]\n            if len(segment2) < 2:\n                continue\n\n            # Swap nodes between segments\n            if max_node1 != -1 and len(segment1) > 2 and len(segment2) > 2:\n                node1 = segment1[max_node1]\n                node2 = segment2[random.randint(1, len(segment2)-1)]\n\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[segment1[max_node1-1], segment1[max_node1]] + distance_matrix_1[segment1[max_node1], segment1[max_node1+1]]\n                new_cost1 = distance_matrix_1[segment1[max_node1-1], node2] + distance_matrix_1[node2, segment1[max_node1+1]]\n\n                old_cost2 = distance_matrix_2[segment1[max_node1-1], segment1[max_node1]] + distance_matrix_2[segment1[max_node1], segment1[max_node1+1]]\n                new_cost2 = distance_matrix_2[segment1[max_node1-1], node2] + distance_matrix_2[node2, segment1[max_node1+1]]\n\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (random.random() < 0.3 and (new_cost1 < old_cost1 or new_cost2 < old_cost2)):\n                    # Perform the swap\n                    segment1[max_node1] = node2\n                    segment2[segment2.index(node2)] = node1\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9261454924544686,
               0.27349990606307983
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Objective-Balanced Cluster Refinement with Dynamic Path Realignment,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms by first identifying promising solutions through archive analysis, but instead of decomposing tours into segments based on objective dominance, it employs a novel clustering approach that groups nodes based on their relative importance across both objectives, using a weighted distance metric that dynamically adjusts based on the current solution's objective balance. These clusters are then refined through an adaptive path realignment process that probabilistically reorders nodes within clusters while preserving their relative positions, followed by a dynamic path inversion phase that selectively reverses entire clusters to explore alternative configurations. The method continuously monitors the solution's objective balance and dynamically adjusts the clustering and realignment parameters to maintain a healthy balance between objectives, while ensuring feasibility through a cluster validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Calculate objective balance\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    balance = abs(total_cost1 - total_cost2) / (total_cost1 + total_cost2 + 1e-6)\n\n    # Step 2: Cluster nodes based on objective importance\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Calculate weighted importance\n        importance1 = cost1 / (total_cost1 + 1e-6)\n        importance2 = cost2 / (total_cost2 + 1e-6)\n        weighted_importance = (1 - balance) * importance1 + balance * importance2\n\n        # Decide whether to start new cluster\n        if weighted_importance > 0.3 or random.random() < 0.2:\n            clusters.append(current_cluster)\n            current_cluster = [current_node]\n        else:\n            current_cluster.append(current_node)\n\n    if len(current_cluster) > 0:\n        clusters.append(current_cluster)\n\n    # Ensure at least two clusters exist\n    if len(clusters) < 2:\n        clusters = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive path realignment\n    for i in range(len(clusters)):\n        cluster = clusters[i]\n        if len(cluster) < 3:\n            continue\n\n        # Calculate cluster costs\n        cluster_cost1 = sum(distance_matrix_1[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n\n        # Realign nodes within cluster\n        if cluster_cost1 > cluster_cost2:\n            # More dominated by objective 1, try to realign towards objective 2\n            for j in range(1, len(cluster)-1):\n                if random.random() < 0.4:\n                    # Swap with a node from another cluster\n                    other_cluster_idx = random.choice([k for k in range(len(clusters)) if k != i and len(clusters[k]) > 1])\n                    other_cluster = clusters[other_cluster_idx]\n                    swap_pos = random.randint(1, len(other_cluster)-1)\n                    node_to_swap = other_cluster[swap_pos]\n\n                    # Calculate potential improvement\n                    old_cost1 = distance_matrix_1[cluster[j-1], cluster[j]] + distance_matrix_1[cluster[j], cluster[j+1]]\n                    new_cost1 = distance_matrix_1[cluster[j-1], node_to_swap] + distance_matrix_1[node_to_swap, cluster[j+1]]\n\n                    old_cost2 = distance_matrix_2[cluster[j-1], cluster[j]] + distance_matrix_2[cluster[j], cluster[j+1]]\n                    new_cost2 = distance_matrix_2[cluster[j-1], node_to_swap] + distance_matrix_2[node_to_swap, cluster[j+1]]\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (random.random() < 0.3):\n                        # Perform the swap\n                        cluster[j], other_cluster[swap_pos] = other_cluster[swap_pos], cluster[j]\n        else:\n            # More dominated by objective 2, try to realign towards objective 1\n            for j in range(1, len(cluster)-1):\n                if random.random() < 0.4:\n                    # Swap with a node from another cluster\n                    other_cluster_idx = random.choice([k for k in range(len(clusters)) if k != i and len(clusters[k]) > 1])\n                    other_cluster = clusters[other_cluster_idx]\n                    swap_pos = random.randint(1, len(other_cluster)-1)\n                    node_to_swap = other_cluster[swap_pos]\n\n                    # Calculate potential improvement\n                    old_cost1 = distance_matrix_1[cluster[j-1], cluster[j]] + distance_matrix_1[cluster[j], cluster[j+1]]\n                    new_cost1 = distance_matrix_1[cluster[j-1], node_to_swap] + distance_matrix_1[node_to_swap, cluster[j+1]]\n\n                    old_cost2 = distance_matrix_2[cluster[j-1], cluster[j]] + distance_matrix_2[cluster[j], cluster[j+1]]\n                    new_cost2 = distance_matrix_2[cluster[j-1], node_to_swap] + distance_matrix_2[node_to_swap, cluster[j+1]]\n\n                    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (random.random() < 0.3):\n                        # Perform the swap\n                        cluster[j], other_cluster[swap_pos] = other_cluster[swap_pos], cluster[j]\n\n    # Step 4: Dynamic path inversion\n    for i in range(len(clusters)):\n        cluster = clusters[i]\n        if len(cluster) < 3:\n            continue\n\n        # Calculate cluster costs\n        cluster_cost1 = sum(distance_matrix_1[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n\n        # Decide whether to invert based on objective balance\n        if cluster_cost1 > cluster_cost2 and random.random() < 0.5 * (1 - balance):\n            clusters[i] = cluster[::-1]\n        elif cluster_cost2 > cluster_cost1 and random.random() < 0.5 * balance:\n            clusters[i] = cluster[::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for cluster in clusters:\n        new_solution.extend(cluster)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple cluster reversal\n        if len(clusters) > 1:\n            i = random.randint(0, len(clusters)-1)\n            clusters[i] = clusters[i][::-1]\n            new_solution = []\n            for cluster in clusters:\n                new_solution.extend(cluster)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8030513062003604,
               0.30272477865219116
          ]
     }
]