[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a promising base solution from the archive by prioritizing those with objectives that are neither dominated nor excessively similar to others, ensuring diversity. Then, it applies a hybrid local search operator that combines a novel edge-swapping mechanism with a variable-length segment relocation strategy. The edge-swapping mechanism identifies critical edges in both objective spaces, swapping them while preserving tour validity, while the segment relocation strategy dynamically adjusts the length of relocated segments based on the local topology of the solution, favoring segments that yield significant cost reductions in either objective. The algorithm ensures feasibility by maintaining permutation validity throughout all operations and uses a probabilistic acceptance criterion to balance exploration and exploitation, favoring neighbors that improve Pareto dominance or show potential for further improvement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping mechanism\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Variable-length segment relocation\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure solution remains valid (permutation of all nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.8379564264344043,
               0.2384818196296692
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge assembly with partial 3-opt\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge assembly: reconnect edges to form a new tour segment\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse another segment\n\n    # Partial 3-opt: attempt to improve the tour by reconnecting three edges\n    if np.random.rand() < 0.5:\n        # Randomly select three nodes and attempt to reconnect them\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Ensure feasibility: verify no duplicates and all nodes are included\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8337802753264643,
               0.16590946912765503
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in non_dominated])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1.0 / (normalized_obj + 1e-10)\n    probs = weights.sum(axis=1) / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search - edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to remove and reinsert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n - 1, 5))  # Segment length between 2 and 4\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find a new position to insert the segment\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    if insert_pos == 0:\n        new_solution = np.concatenate([segment, remaining])\n    elif insert_pos == len(remaining):\n        new_solution = np.concatenate([remaining, segment])\n    else:\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly relocate a node\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9880560877894095,
               0.30501770973205566
          ]
     },
     {
          "algorithm": "{This novel algorithm implements a dynamic multi-objective path reconstruction approach that first evaluates solutions based on their Pareto efficiency and objective diversity, then applies a hybrid of probabilistic edge swapping and adaptive segment inversion, where the selection of operations is determined by a learned preference model that dynamically adjusts based on the current solution's performance in both objective spaces, followed by a constrained optimization phase that ensures feasibility by maintaining tour continuity and verifying node uniqueness, with a simulated annealing-inspired acceptance criterion that allows for occasional non-improving moves to escape local optima while progressively tightening the acceptance threshold to focus on high-quality solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions and select a base solution\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-10)\n    diversity_scores = np.std(normalized_obj, axis=0)\n    weights = diversity_scores / diversity_scores.sum()\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)  # Select solution with best trade-off\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Initialize neighbor solution\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Dynamic operation selection\n    temp = 1.0  # Initial temperature for simulated annealing\n    for _ in range(min(10, n//2)):\n        # Randomly choose between edge swap and segment inversion\n        if random.random() < 0.5 or n < 4:\n            # Edge swap operation\n            i, j = sorted(random.sample(range(n), 2))\n            # Calculate potential improvement\n            original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n            original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            swapped_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]])\n            swapped_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Acceptance criterion\n            delta1 = swapped_cost1 - original_cost1\n            delta2 = swapped_cost2 - original_cost2\n            combined_delta = (delta1 * (1 - current_obj[0]/(current_obj[0]+current_obj[1]+1e-10)) +\n                             delta2 * (current_obj[0]/(current_obj[0]+current_obj[1]+1e-10)))\n\n            if combined_delta < 0 or random.random() < np.exp(-combined_delta/temp):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment inversion operation\n            start = random.randint(0, n-3)\n            end = random.randint(start+2, min(start+5, n-1))\n            segment = new_solution[start:end+1]\n\n            # Calculate potential improvement\n            original_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                             distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n            original_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                             distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n            inverted_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_1[new_solution[start], new_solution[(end+1)%n]])\n            inverted_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[end]] +\n                            distance_matrix_2[new_solution[start], new_solution[(end+1)%n]])\n\n            # Acceptance criterion\n            delta1 = inverted_cost1 - original_cost1\n            delta2 = inverted_cost2 - original_cost2\n            combined_delta = (delta1 * (1 - current_obj[0]/(current_obj[0]+current_obj[1]+1e-10)) +\n                            delta2 * (current_obj[0]/(current_obj[0]+current_obj[1]+1e-10)))\n\n            if combined_delta < 0 or random.random() < np.exp(-combined_delta/temp):\n                new_solution[start:end+1] = segment[::-1]\n\n        # Cool down temperature\n        temp *= 0.9\n\n    # Step 4: Validate solution\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.7812941872129973,
               0.2982802987098694
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify edges with high cost in either objective space\n    high_cost_edges = []\n    for i in range(n):\n        u, v = selected_solution[i], selected_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_edges.append((i, (i+1)%n))\n\n    if high_cost_edges:\n        # Randomly select a high-cost edge to modify\n        edge_start, edge_end = random.choice(high_cost_edges)\n        # Apply 3-opt: reconnect three edges to form a new cycle\n        i, j, k = edge_start, (edge_start + 1) % n, (edge_start + 2) % n\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n    return new_solution\n\n",
          "score": [
               -0.9228213845482578,
               0.32953977584838867
          ]
     },
     {
          "algorithm": "{The proposed heuristic function, 'select_neighbor', first identifies promising solutions in the archive by evaluating their non-dominated status and diversity, using a combination of Pareto dominance and crowding distance metrics to prioritize solutions that lie on the Pareto front or are isolated in the objective space. It then applies a hybrid local search operator that integrates a novel \"node cluster inversion\" strategy with a dynamic edge reassembly mechanism. The node cluster inversion randomly selects a contiguous segment of nodes in the tour and inverts their order while preserving their internal structure, while the dynamic edge reassembly identifies the most promising edges to swap based on a weighted combination of their contributions to both objectives, ensuring feasibility by maintaining the tour's Hamiltonian cycle structure. The function intelligently selects a solution from the archive using a roulette wheel selection biased toward higher-quality solutions, and the generated neighbor solution is validated to ensure it remains a valid TSP tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    objectives = np.array([obj for _, obj in archive])\n    fitness = 1.0 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    probabilities = fitness / fitness.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node cluster inversion + Dynamic edge reassembly\n    if n > 4:\n        # Node cluster inversion\n        cluster_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n        inverted_cluster = cluster[::-1]\n\n        # Preserve internal structure by only inverting the cluster\n        new_solution[start:start+cluster_size] = inverted_cluster\n\n        # Dynamic edge reassembly\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Find the most promising edges to swap\n        for _ in range(min(2, n//3)):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n\n            # Calculate potential new costs\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Accept if improvement in at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                current_cost1, current_cost2 = new_cost1, new_cost2\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9077484068161285,
               0.31227391958236694
          ]
     },
     {
          "algorithm": "{This new algorithm first identifies the solution with the highest combined objective value in the archive as the base solution, then applies a novel \"multi-objective segment inversion and insertion\" strategy. It randomly selects a segment of nodes from the base solution, inverts their order within the segment, and strategically reinserts this inverted segment into a different position in the tour. The reinsertion position is chosen based on a weighted combination of the distance matrices from both objectives to ensure balance between the two spaces. The algorithm also includes an optional \"node exchange\" step where nodes are swapped between the inverted segment and the remaining tour if it improves the combined objective. The solution is validated to ensure it remains a valid TSP tour, and the neighbor solution is returned with the improved segment structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_objectives = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Randomly select a segment to invert and reinsert\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(n, 6))  # Segment length between 2 and 5\n    segment_end = (segment_start + segment_length) % n\n\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n        remaining = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n        remaining = new_solution[segment_end:segment_start]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Step 3: Find the best insertion position for the inverted segment\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining) + 1):\n        if pos == 0:\n            candidate = np.concatenate([inverted_segment, remaining])\n        elif pos == len(remaining):\n            candidate = np.concatenate([remaining, inverted_segment])\n        else:\n            candidate = np.concatenate([remaining[:pos], inverted_segment, remaining[pos:]])\n\n        # Calculate the cost of the candidate solution\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the inverted segment at the best position\n    if best_pos == 0:\n        new_solution = np.concatenate([inverted_segment, remaining])\n    elif best_pos == len(remaining):\n        new_solution = np.concatenate([remaining, inverted_segment])\n    else:\n        new_solution = np.concatenate([remaining[:best_pos], inverted_segment, remaining[best_pos:]])\n\n    # Step 4: Optional node exchange between inverted segment and remaining tour\n    if np.random.rand() < 0.3:  # 30% chance to perform exchange\n        segment_nodes = set(inverted_segment)\n        remaining_nodes = [node for node in new_solution if node not in segment_nodes]\n\n        if len(remaining_nodes) > 0:\n            # Select a random node from the inverted segment and a random node from the remaining tour\n            seg_node_idx = np.random.randint(0, len(inverted_segment))\n            rem_node_idx = np.random.randint(0, len(remaining_nodes))\n\n            # Swap the nodes\n            seg_node = inverted_segment[seg_node_idx]\n            rem_node = remaining_nodes[rem_node_idx]\n\n            # Find and replace the nodes in the new solution\n            seg_pos = np.where(new_solution == seg_node)[0][0]\n            rem_pos = np.where(new_solution == rem_node)[0][0]\n            new_solution[seg_pos], new_solution[rem_pos] = new_solution[rem_pos], new_solution[seg_pos]\n\n    # Step 5: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9446570864424071,
               0.6622089743614197
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Rank solutions by combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    ranks = np.argsort(combined_scores)[::-1]\n\n    # Step 2: Probabilistically select a solution based on rank (higher rank = higher probability)\n    selection_probs = np.exp(-0.5 * np.arange(len(archive)))  # Exponential decay\n    selection_probs = selection_probs[ranks]\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Identify critical edges (top 20% edges with highest contribution to total cost)\n    def get_edge_contributions(solution, distance_matrix):\n        total_cost = 0.0\n        edge_costs = []\n        for i in range(len(solution) - 1):\n            cost = distance_matrix[solution[i], solution[i+1]]\n            edge_costs.append(cost)\n            total_cost += cost\n        edge_costs.append(distance_matrix[solution[-1], solution[0]])  # Close the loop\n        total_cost += edge_costs[-1]\n        edge_contributions = np.array(edge_costs) / total_cost\n        return edge_contributions\n\n    edge_contrib_1 = get_edge_contributions(base_solution, distance_matrix_1)\n    edge_contrib_2 = get_edge_contributions(base_solution, distance_matrix_2)\n    combined_contrib = edge_contrib_1 + edge_contrib_2\n    critical_edges = np.argsort(combined_contrib)[-max(2, len(combined_contrib) // 5):]\n\n    # Step 4: Perform dynamic segment relocation\n    new_solution = base_solution.copy()\n    if len(critical_edges) < 2:\n        # Fallback to simple swap if not enough critical edges\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two critical edges and move a segment between them\n        edge1, edge2 = np.random.choice(critical_edges, 2, replace=False)\n        edge1, edge2 = min(edge1, edge2), max(edge1, edge2)\n\n        segment_length = np.random.randint(2, min(10, len(new_solution) // 2) + 1)\n        start_pos = edge1 + 1\n        end_pos = min(start_pos + segment_length, len(new_solution))\n\n        segment = new_solution[start_pos:end_pos]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_solution[end_pos:edge2+1],\n            segment,\n            new_solution[edge2+1:]\n        ])\n\n    # Step 5: Validate the new solution\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.784269083981462,
               0.31758350133895874
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify clusters using hierarchical clustering based on both coordinate spaces\n    from scipy.cluster.hierarchy import fcluster, linkage\n    from scipy.spatial.distance import pdist, squareform\n\n    # Combine coordinates from both spaces\n    combined_coords = np.column_stack((instance[new_solution, 0], instance[new_solution, 1], instance[new_solution, 2], instance[new_solution, 3]))\n\n    # Compute distance matrix for clustering\n    dist_matrix = squareform(pdist(combined_coords, 'euclidean'))\n    linkage_matrix = linkage(dist_matrix, method='ward')\n    clusters = fcluster(linkage_matrix, t=2, criterion='maxclust')\n\n    # Select a random cluster\n    unique_clusters = np.unique(clusters)\n    selected_cluster = np.random.choice(unique_clusters)\n    cluster_indices = np.where(clusters == selected_cluster)[0]\n\n    if len(cluster_indices) > 1:\n        # Rotate the segment by a random angle around the centroid\n        segment = new_solution[cluster_indices]\n        centroid_x1 = np.mean(instance[segment, 0])\n        centroid_y1 = np.mean(instance[segment, 1])\n        centroid_x2 = np.mean(instance[segment, 2])\n        centroid_y2 = np.mean(instance[segment, 3])\n\n        angle = np.random.uniform(0, 2 * np.pi)\n\n        # Rotate coordinates in both spaces\n        for i in segment:\n            x1, y1 = instance[i, 0], instance[i, 1]\n            x2, y2 = instance[i, 2], instance[i, 3]\n\n            # Rotate in first space\n            x1_rot = centroid_x1 + (x1 - centroid_x1) * np.cos(angle) - (y1 - centroid_y1) * np.sin(angle)\n            y1_rot = centroid_y1 + (x1 - centroid_x1) * np.sin(angle) + (y1 - centroid_y1) * np.cos(angle)\n\n            # Rotate in second space\n            x2_rot = centroid_x2 + (x2 - centroid_x2) * np.cos(angle) - (y2 - centroid_y2) * np.sin(angle)\n            y2_rot = centroid_y2 + (x2 - centroid_x2) * np.sin(angle) + (y2 - centroid_y2) * np.cos(angle)\n\n            instance[i, 0], instance[i, 1] = x1_rot, y1_rot\n            instance[i, 2], instance[i, 3] = x2_rot, y2_rot\n\n        # Update distance matrices\n        for i in range(n):\n            for j in range(n):\n                dx1 = instance[i, 0] - instance[j, 0]\n                dy1 = instance[i, 1] - instance[j, 1]\n                dx2 = instance[i, 2] - instance[j, 2]\n                dy2 = instance[i, 3] - instance[j, 3]\n                distance_matrix_1[i, j] = np.sqrt(dx1**2 + dy1**2)\n                distance_matrix_2[i, j] = np.sqrt(dx2**2 + dy2**2)\n\n    # Apply greedy insertion heuristic to refine the solution\n    for _ in range(10):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Try inserting node i after node j\n            temp_solution = np.concatenate([new_solution[:j+1], [new_solution[i]], new_solution[j+1:i], new_solution[i+1:]])\n            # Check if the new solution is better in both objectives\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.1):\n                new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.9183994773416244,
               2.5024824738502502
          ]
     }
]