[
    {
        "algorithm": "{This algorithm employs a multi-objective-aware segment reordering strategy that dynamically selects and reorders segments of varying lengths based on their potential to improve both objectives while maintaining feasibility through a segment validity check and adaptive segment size adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate segment quality scores for both objectives\n    def calculate_segment_scores(solution, segment_length):\n        scores1 = []\n        scores2 = []\n        for i in range(n - segment_length + 1):\n            segment = solution[i:i+segment_length]\n            total1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total1 += distance_matrix_1[segment[-1], segment[0]] if segment_length == n else 0\n            total2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total2 += distance_matrix_2[segment[-1], segment[0]] if segment_length == n else 0\n            scores1.append(total1)\n            scores2.append(total2)\n        return np.array(scores1), np.array(scores2)\n\n    # Dynamic segment length selection\n    segment_length = max(2, min(5, random.randint(2, n//3)))\n\n    scores1, scores2 = calculate_segment_scores(new_solution, segment_length)\n    combined_scores = scores1 + scores2\n\n    # Find worst segments to consider for reordering\n    worst_indices = np.argsort(combined_scores)[-min(3, n//segment_length):]\n\n    # Perform multi-objective-aware segment reordering\n    for idx in worst_indices:\n        i = idx\n        segment = new_solution[i:i+segment_length]\n\n        # Generate candidate reorderings\n        candidates = [\n            segment.copy(),\n            segment[::-1],\n            np.roll(segment, 1),\n            np.roll(segment, -1),\n            np.concatenate([segment[1:], [segment[0]]]),\n            np.concatenate([[segment[-1]], segment[:-1]])\n        ]\n\n        best_candidate = segment\n        best_improvement = 0\n\n        for candidate in candidates:\n            # Calculate improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            old_cost2 = sum(distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n            new_cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = candidate\n\n        if best_improvement > 0:\n            new_solution[i:i+segment_length] = best_candidate\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0254331837621204,
            0.5591902136802673
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective-aware segment reordering strategy that dynamically selects and reorders segments of varying lengths based on their potential to improve both objectives while maintaining feasibility through a segment validity check and adaptive segment size adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate segment quality scores for both objectives\n    def calculate_segment_scores(solution, segment_length):\n        scores1 = []\n        scores2 = []\n        for i in range(n - segment_length + 1):\n            segment = solution[i:i+segment_length]\n            total1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total1 += distance_matrix_1[segment[-1], segment[0]] if segment_length == n else 0\n            total2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total2 += distance_matrix_2[segment[-1], segment[0]] if segment_length == n else 0\n            scores1.append(total1)\n            scores2.append(total2)\n        return np.array(scores1), np.array(scores2)\n\n    # Dynamic segment length selection\n    segment_length = max(2, min(5, random.randint(2, n//3)))\n\n    scores1, scores2 = calculate_segment_scores(new_solution, segment_length)\n    combined_scores = scores1 + scores2\n\n    # Find worst segments to consider for reordering\n    worst_indices = np.argsort(combined_scores)[-min(3, n//segment_length):]\n\n    # Perform multi-objective-aware segment reordering\n    for idx in worst_indices:\n        i = idx\n        segment = new_solution[i:i+segment_length]\n\n        # Generate candidate reorderings\n        candidates = [\n            segment.copy(),\n            segment[::-1],\n            np.roll(segment, 1),\n            np.roll(segment, -1),\n            np.concatenate([segment[1:], [segment[0]]]),\n            np.concatenate([[segment[-1]], segment[:-1]])\n        ]\n\n        best_candidate = segment\n        best_improvement = 0\n\n        for candidate in candidates:\n            # Calculate improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            old_cost2 = sum(distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n            new_cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = candidate\n\n        if best_improvement > 0:\n            new_solution[i:i+segment_length] = best_candidate\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0254331837621204,
            0.5591902136802673
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with an adaptive segment inversion to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with adaptive segment inversion\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Adaptive segment inversion\n            if random.random() < 0.4:\n                new_solution[i:j] = segment1[::-1]\n            else:\n                new_solution[j:k] = segment2[::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9837720932299139,
            0.3236503005027771
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective-aware segment reordering strategy that dynamically selects and reorders segments of varying lengths based on their potential to improve both objectives while maintaining feasibility through a segment validity check and adaptive segment size adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate segment quality scores for both objectives\n    def calculate_segment_scores(solution, segment_length):\n        scores1 = []\n        scores2 = []\n        for i in range(n - segment_length + 1):\n            segment = solution[i:i+segment_length]\n            total1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total1 += distance_matrix_1[segment[-1], segment[0]] if segment_length == n else 0\n            total2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total2 += distance_matrix_2[segment[-1], segment[0]] if segment_length == n else 0\n            scores1.append(total1)\n            scores2.append(total2)\n        return np.array(scores1), np.array(scores2)\n\n    # Dynamic segment length selection\n    segment_length = max(2, min(5, random.randint(2, n//3)))\n\n    scores1, scores2 = calculate_segment_scores(new_solution, segment_length)\n    combined_scores = scores1 + scores2\n\n    # Find worst segments to consider for reordering\n    worst_indices = np.argsort(combined_scores)[-min(3, n//segment_length):]\n\n    # Perform multi-objective-aware segment reordering\n    for idx in worst_indices:\n        i = idx\n        segment = new_solution[i:i+segment_length]\n\n        # Generate candidate reorderings\n        candidates = [\n            segment.copy(),\n            segment[::-1],\n            np.roll(segment, 1),\n            np.roll(segment, -1),\n            np.concatenate([segment[1:], [segment[0]]]),\n            np.concatenate([[segment[-1]], segment[:-1]])\n        ]\n\n        best_candidate = segment\n        best_improvement = 0\n\n        for candidate in candidates:\n            # Calculate improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            old_cost2 = sum(distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n            new_cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = candidate\n\n        if best_improvement > 0:\n            new_solution[i:i+segment_length] = best_candidate\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0254331837621204,
            0.5591902136802673
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective-aware node swapping strategy that dynamically prioritizes edge exchanges based on their potential to improve both objective costs while maintaining solution feasibility through a feasibility-preserving swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate edge quality scores for both objectives\n    def calculate_edge_scores(solution):\n        scores1 = []\n        scores2 = []\n        for i in range(n):\n            a, b = solution[i], solution[(i+1)%n]\n            scores1.append(distance_matrix_1[a,b])\n            scores2.append(distance_matrix_2[a,b])\n        return np.array(scores1), np.array(scores2)\n\n    scores1, scores2 = calculate_edge_scores(new_solution)\n    combined_scores = scores1 + scores2\n\n    # Find worst edges to consider for replacement\n    worst_indices = np.argsort(combined_scores)[-min(3, n//2):]\n\n    # Perform multi-objective-aware node swaps\n    for idx in worst_indices:\n        i = idx\n        j = (i + 1) % n\n\n        # Find best possible swap partner\n        best_k = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or (k+1)%n == i or (k+1)%n == j:\n                continue\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[i], new_solution[(i+1)%n]),\n                (new_solution[k], new_solution[(k+1)%n])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[k]),\n                (new_solution[(i+1)%n], new_solution[(k+1)%n])\n            ]\n\n            improvement = 0\n            for (a,b), (c,d) in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[a,b] + distance_matrix_2[a,b]) - (distance_matrix_1[c,d] + distance_matrix_2[c,d])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_k = k\n\n        if best_k != -1 and best_improvement > 0:\n            # Perform the swap\n            temp = new_solution[i+1]\n            new_solution[i+1] = new_solution[best_k]\n            new_solution[best_k] = temp\n\n            # Ensure feasibility\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9750744537721875,
            0.3008490800857544
        ]
    },
    {
        "algorithm": "{This algorithm uses a novel \"edge-aware segment relocation with multi-objective adaptive perturbation\" that dynamically selects and relocates segments of the tour based on edge criticality in both objective spaces, while applying probabilistic perturbations to escape local optima and maintain solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate edge criticality scores (sum of distances in both objective spaces)\n    edge_scores = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        edge_scores.append(score)\n\n    # Find the least critical edge (potential for improvement)\n    min_idx = np.argmin(edge_scores)\n    a, b = new_solution[min_idx], new_solution[(min_idx+1)%n]\n\n    # Find the most critical node to insert between a and b\n    candidates = [i for i in range(n) if i not in {min_idx, (min_idx+1)%n}]\n    if not candidates:\n        return new_solution\n\n    # Calculate insertion gain for each candidate\n    gains = []\n    for i in candidates:\n        u = new_solution[(i-1)%n]\n        v = new_solution[i]\n        w = new_solution[(i+1)%n]\n\n        # Calculate gain as reduction in combined distance\n        gain = (distance_matrix_1[u, v] + distance_matrix_1[v, w] +\n                distance_matrix_2[u, v] + distance_matrix_2[v, w]) - \\\n               (distance_matrix_1[u, a] + distance_matrix_1[a, b] + distance_matrix_1[b, w] +\n                distance_matrix_2[u, a] + distance_matrix_2[a, b] + distance_matrix_2[b, w])\n        gains.append(gain)\n\n    if not gains or max(gains) <= 0:\n        # Apply probabilistic perturbation if no improvement possible\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n    # Perform the best insertion\n    best_candidate = candidates[np.argmax(gains)]\n    best_pos = (min_idx+1)%n if best_candidate > min_idx else min_idx\n\n    # Create new solution with insertion\n    temp = new_solution.copy()\n    temp = np.concatenate([temp[:best_pos], [temp[best_candidate]], temp[best_pos:]])\n    if best_candidate < best_pos:\n        temp = np.delete(temp, best_candidate)\n\n    # Verify feasibility\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    # Apply additional probabilistic perturbation\n    if random.random() < 0.2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.973243170275442,
            0.2092185616493225
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective-aware segment reordering strategy that dynamically selects and reorders segments of varying lengths based on their potential to improve both objectives while maintaining feasibility through a segment validity check and adaptive segment size adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate segment quality scores for both objectives\n    def calculate_segment_scores(solution, segment_length):\n        scores1 = []\n        scores2 = []\n        for i in range(n - segment_length + 1):\n            segment = solution[i:i+segment_length]\n            total1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total1 += distance_matrix_1[segment[-1], segment[0]] if segment_length == n else 0\n            total2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n            total2 += distance_matrix_2[segment[-1], segment[0]] if segment_length == n else 0\n            scores1.append(total1)\n            scores2.append(total2)\n        return np.array(scores1), np.array(scores2)\n\n    # Dynamic segment length selection\n    segment_length = max(2, min(5, random.randint(2, n//3)))\n\n    scores1, scores2 = calculate_segment_scores(new_solution, segment_length)\n    combined_scores = scores1 + scores2\n\n    # Find worst segments to consider for reordering\n    worst_indices = np.argsort(combined_scores)[-min(3, n//segment_length):]\n\n    # Perform multi-objective-aware segment reordering\n    for idx in worst_indices:\n        i = idx\n        segment = new_solution[i:i+segment_length]\n\n        # Generate candidate reorderings\n        candidates = [\n            segment.copy(),\n            segment[::-1],\n            np.roll(segment, 1),\n            np.roll(segment, -1),\n            np.concatenate([segment[1:], [segment[0]]]),\n            np.concatenate([[segment[-1]], segment[:-1]])\n        ]\n\n        best_candidate = segment\n        best_improvement = 0\n\n        for candidate in candidates:\n            # Calculate improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            old_cost2 = sum(distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] for j in range(i, i+segment_length))\n            new_cost1 = sum(distance_matrix_1[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n            new_cost2 = sum(distance_matrix_2[candidate[j], candidate[(j+1)%segment_length]] for j in range(segment_length))\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_candidate = candidate\n\n        if best_improvement > 0:\n            new_solution[i:i+segment_length] = best_candidate\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0254331837621204,
            0.5591902136802673
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective-aware node swapping strategy that dynamically prioritizes edge exchanges based on their potential to improve both objective costs while maintaining solution feasibility through a feasibility-preserving swap mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate edge quality scores for both objectives\n    def calculate_edge_scores(solution):\n        scores1 = []\n        scores2 = []\n        for i in range(n):\n            a, b = solution[i], solution[(i+1)%n]\n            scores1.append(distance_matrix_1[a,b])\n            scores2.append(distance_matrix_2[a,b])\n        return np.array(scores1), np.array(scores2)\n\n    scores1, scores2 = calculate_edge_scores(new_solution)\n    combined_scores = scores1 + scores2\n\n    # Find worst edges to consider for replacement\n    worst_indices = np.argsort(combined_scores)[-min(3, n//2):]\n\n    # Perform multi-objective-aware node swaps\n    for idx in worst_indices:\n        i = idx\n        j = (i + 1) % n\n\n        # Find best possible swap partner\n        best_k = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or (k+1)%n == i or (k+1)%n == j:\n                continue\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[i], new_solution[(i+1)%n]),\n                (new_solution[k], new_solution[(k+1)%n])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[k]),\n                (new_solution[(i+1)%n], new_solution[(k+1)%n])\n            ]\n\n            improvement = 0\n            for (a,b), (c,d) in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[a,b] + distance_matrix_2[a,b]) - (distance_matrix_1[c,d] + distance_matrix_2[c,d])\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_k = k\n\n        if best_k != -1 and best_improvement > 0:\n            # Perform the swap\n            temp = new_solution[i+1]\n            new_solution[i+1] = new_solution[best_k]\n            new_solution[best_k] = temp\n\n            # Ensure feasibility\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9750744537721875,
            0.3008490800857544
        ]
    }
]